<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pandas.core.generic &mdash; BabyDragon  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            BabyDragon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tasks:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks/llm_task.html">llm_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks/multi_kernel_task.html">multi_kernel_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks/base_task.html">base_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks/topic_tree_task.html">topic_tree_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks/embedding_task.html">embedding_task</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Kernels:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/kernels/memory_kernel.html">memory_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/kernels/kernel_clustering.html">kernel_clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/kernels/multi_kernel.html">multi_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/kernels/multi_kernel_visualization.html">multi_kernel_visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/kernels/kernel_utils.html">kernel_utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Threads:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/threads/base_thread.html">base_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/threads/fifo_thread.html">fifo_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/threads/vector_thread.html">vector_thread</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Indexes:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/memory_index.html">memory_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/pandas_index.html">pandas_index</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Chat:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../chat/base_chat.html">base_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../chat/memory_chat.html">memory_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../chat/chat.html">chat</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utils:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/pandas.html">pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/hf_datasets.html">hf_datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/chatml.html">chatml</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/embedders:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../models/embedders/ada2.html">ada2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/embedders/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/embedders/sbert.html">sbert</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/generators:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../models/generators/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/generators/chatgpt.html">chatgpt</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Processors:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/git_metadata.html">git_metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/visitors.html">visitors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/python_parser.html">python_parser</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Apps:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../apps/auto_perspective/perspective.html">perspective</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BabyDragon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pandas.core.generic</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pandas.core.generic</h1><div class="highlight"><pre>
<span></span><span class="c1"># pyright: reportPropertyTypeMismatch=false</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">from</span> <span class="nn">json</span> <span class="kn">import</span> <span class="n">loads</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">ClassVar</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">NoReturn</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">final</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._config</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">config</span><span class="p">,</span>
    <span class="n">using_copy_on_write</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="kn">from</span> <span class="nn">pandas._libs.lib</span> <span class="kn">import</span> <span class="n">is_range_indexer</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Period</span><span class="p">,</span>
    <span class="n">Tick</span><span class="p">,</span>
    <span class="n">Timestamp</span><span class="p">,</span>
    <span class="n">to_offset</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AlignJoin</span><span class="p">,</span>
    <span class="n">AnyArrayLike</span><span class="p">,</span>
    <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">Axis</span><span class="p">,</span>
    <span class="n">AxisInt</span><span class="p">,</span>
    <span class="n">CompressionOptions</span><span class="p">,</span>
    <span class="n">Dtype</span><span class="p">,</span>
    <span class="n">DtypeArg</span><span class="p">,</span>
    <span class="n">DtypeBackend</span><span class="p">,</span>
    <span class="n">DtypeObj</span><span class="p">,</span>
    <span class="n">FilePath</span><span class="p">,</span>
    <span class="n">FillnaOptions</span><span class="p">,</span>
    <span class="n">FloatFormatType</span><span class="p">,</span>
    <span class="n">FormattersType</span><span class="p">,</span>
    <span class="n">Frequency</span><span class="p">,</span>
    <span class="n">IgnoreRaise</span><span class="p">,</span>
    <span class="n">IndexKeyFunc</span><span class="p">,</span>
    <span class="n">IndexLabel</span><span class="p">,</span>
    <span class="n">IntervalClosedType</span><span class="p">,</span>
    <span class="n">JSONSerializable</span><span class="p">,</span>
    <span class="n">Level</span><span class="p">,</span>
    <span class="n">Manager</span><span class="p">,</span>
    <span class="n">NaPosition</span><span class="p">,</span>
    <span class="n">NDFrameT</span><span class="p">,</span>
    <span class="n">RandomState</span><span class="p">,</span>
    <span class="n">Renamer</span><span class="p">,</span>
    <span class="n">Scalar</span><span class="p">,</span>
    <span class="n">SortKind</span><span class="p">,</span>
    <span class="n">StorageOptions</span><span class="p">,</span>
    <span class="n">Suffixes</span><span class="p">,</span>
    <span class="n">T</span><span class="p">,</span>
    <span class="n">TimeAmbiguous</span><span class="p">,</span>
    <span class="n">TimedeltaConvertibleTypes</span><span class="p">,</span>
    <span class="n">TimeNonexistent</span><span class="p">,</span>
    <span class="n">TimestampConvertibleTypes</span><span class="p">,</span>
    <span class="n">ValueKeyFunc</span><span class="p">,</span>
    <span class="n">WriteBuffer</span><span class="p">,</span>
    <span class="n">npt</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.compat._optional</span> <span class="kn">import</span> <span class="n">import_optional_dependency</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="kn">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractMethodError</span><span class="p">,</span>
    <span class="n">InvalidIndexError</span><span class="p">,</span>
    <span class="n">SettingWithCopyError</span><span class="p">,</span>
    <span class="n">SettingWithCopyWarning</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="n">doc</span>
<span class="kn">from</span> <span class="nn">pandas.util._exceptions</span> <span class="kn">import</span> <span class="n">find_stack_level</span>
<span class="kn">from</span> <span class="nn">pandas.util._validators</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">check_dtype_backend</span><span class="p">,</span>
    <span class="n">validate_ascending</span><span class="p">,</span>
    <span class="n">validate_bool_kwarg</span><span class="p">,</span>
    <span class="n">validate_fillna_kwargs</span><span class="p">,</span>
    <span class="n">validate_inclusive</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.astype</span> <span class="kn">import</span> <span class="n">astype_is_view</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ensure_object</span><span class="p">,</span>
    <span class="n">ensure_platform_int</span><span class="p">,</span>
    <span class="n">ensure_str</span><span class="p">,</span>
    <span class="n">is_bool</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64_any_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64tz_dtype</span><span class="p">,</span>
    <span class="n">is_dict_like</span><span class="p">,</span>
    <span class="n">is_dtype_equal</span><span class="p">,</span>
    <span class="n">is_extension_array_dtype</span><span class="p">,</span>
    <span class="n">is_float</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_number</span><span class="p">,</span>
    <span class="n">is_numeric_dtype</span><span class="p">,</span>
    <span class="n">is_re_compilable</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">is_timedelta64_dtype</span><span class="p">,</span>
    <span class="n">pandas_dtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ABCDataFrame</span><span class="p">,</span>
    <span class="n">ABCSeries</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.inference</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">is_hashable</span><span class="p">,</span>
    <span class="n">is_nested_list_like</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">isna</span><span class="p">,</span>
    <span class="n">notna</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">algorithms</span> <span class="k">as</span> <span class="n">algos</span><span class="p">,</span>
    <span class="n">arraylike</span><span class="p">,</span>
    <span class="n">common</span><span class="p">,</span>
    <span class="n">indexing</span><span class="p">,</span>
    <span class="n">nanops</span><span class="p">,</span>
    <span class="n">sample</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.array_algos.replace</span> <span class="kn">import</span> <span class="n">should_use_regex</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="n">ExtensionArray</span>
<span class="kn">from</span> <span class="nn">pandas.core.base</span> <span class="kn">import</span> <span class="n">PandasObject</span>
<span class="kn">from</span> <span class="nn">pandas.core.construction</span> <span class="kn">import</span> <span class="n">extract_array</span>
<span class="kn">from</span> <span class="nn">pandas.core.flags</span> <span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.api</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DatetimeIndex</span><span class="p">,</span>
    <span class="n">Index</span><span class="p">,</span>
    <span class="n">MultiIndex</span><span class="p">,</span>
    <span class="n">PeriodIndex</span><span class="p">,</span>
    <span class="n">RangeIndex</span><span class="p">,</span>
    <span class="n">default_index</span><span class="p">,</span>
    <span class="n">ensure_index</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ArrayManager</span><span class="p">,</span>
    <span class="n">BlockManager</span><span class="p">,</span>
    <span class="n">SingleArrayManager</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals.construction</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">mgr_to_mgr</span><span class="p">,</span>
    <span class="n">ndarray_to_mgr</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.methods.describe</span> <span class="kn">import</span> <span class="n">describe_ndframe</span>
<span class="kn">from</span> <span class="nn">pandas.core.missing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">clean_fill_method</span><span class="p">,</span>
    <span class="n">clean_reindex_fill_method</span><span class="p">,</span>
    <span class="n">find_valid_index</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.ops</span> <span class="kn">import</span> <span class="n">align_method_FRAME</span>
<span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>
<span class="kn">from</span> <span class="nn">pandas.core.shared_docs</span> <span class="kn">import</span> <span class="n">_shared_docs</span>
<span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="kn">import</span> <span class="n">get_indexer_indexer</span>
<span class="kn">from</span> <span class="nn">pandas.core.window</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Expanding</span><span class="p">,</span>
    <span class="n">ExponentialMovingWindow</span><span class="p">,</span>
    <span class="n">Rolling</span><span class="p">,</span>
    <span class="n">Window</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.io.formats.format</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DataFrameFormatter</span><span class="p">,</span>
    <span class="n">DataFrameRenderer</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats.printing</span> <span class="kn">import</span> <span class="n">pprint_thing</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas._libs.tslibs</span> <span class="kn">import</span> <span class="n">BaseOffset</span>

    <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
    <span class="kn">from</span> <span class="nn">pandas.core.indexers.objects</span> <span class="kn">import</span> <span class="n">BaseIndexer</span>
    <span class="kn">from</span> <span class="nn">pandas.core.resample</span> <span class="kn">import</span> <span class="n">Resampler</span>
    <span class="kn">from</span> <span class="nn">pandas.core.series</span> <span class="kn">import</span> <span class="n">Series</span>

    <span class="kn">from</span> <span class="nn">pandas.io.pytables</span> <span class="kn">import</span> <span class="n">HDFStore</span>


<span class="c1"># goal is to be able to define the docs close to function, while still being</span>
<span class="c1"># able to share</span>
<span class="n">_shared_docs</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">_shared_docs</span><span class="p">}</span>
<span class="n">_shared_doc_kwargs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;axes&quot;</span><span class="p">:</span> <span class="s2">&quot;keywords for axes&quot;</span><span class="p">,</span>
    <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;Series/DataFrame&quot;</span><span class="p">,</span>
    <span class="s2">&quot;axes_single_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;int or labels for object&quot;</span><span class="p">,</span>
    <span class="s2">&quot;args_transpose&quot;</span><span class="p">:</span> <span class="s2">&quot;axes to permute (int or label for object)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;inplace&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    inplace : bool, default False</span>
<span class="s2">        If True, performs operation inplace and returns None.&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;optional_by&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        by : str or list of str</span>
<span class="s2">            Name or list of names to sort by&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;replace_iloc&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    This differs from updating with ``.loc`` or ``.iloc``, which require</span>
<span class="s2">    you to specify a location to update with some value.&quot;&quot;&quot;</span><span class="p">,</span>
<span class="p">}</span>


<span class="n">bool_t</span> <span class="o">=</span> <span class="nb">bool</span>  <span class="c1"># Need alias because NDFrame has def bool:</span>


<span class="k">class</span> <span class="nc">NDFrame</span><span class="p">(</span><span class="n">PandasObject</span><span class="p">,</span> <span class="n">indexing</span><span class="o">.</span><span class="n">IndexingMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    N-dimensional analogue of DataFrame. Store multi-dimensional in a</span>
<span class="sd">    size-mutable, labeled data structure</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : BlockManager</span>
<span class="sd">    axes : list</span>
<span class="sd">    copy : bool, default False</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_internal_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_mgr&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_cacher&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_item_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_is_copy&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_subtyp&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_default_kind&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_default_fill_value&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__array_struct__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__array_interface__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_flags&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">_internal_names_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_internal_names</span><span class="p">)</span>
    <span class="n">_accessors</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">_hidden_attrs</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([])</span>
    <span class="n">_metadata</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">_is_copy</span><span class="p">:</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ReferenceType</span><span class="p">[</span><span class="n">NDFrame</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_mgr</span><span class="p">:</span> <span class="n">Manager</span>
    <span class="n">_attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="n">_typ</span><span class="p">:</span> <span class="nb">str</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Constructors</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Manager</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># copy kwarg is retained for mypy compat, is not used</span>

        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_is_copy&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_mgr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_item_cache&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_attrs&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_flags&quot;</span><span class="p">,</span> <span class="n">Flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allows_duplicate_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_init_mgr</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">mgr</span><span class="p">:</span> <span class="n">Manager</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Manager</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;passed a manager and a axes dict&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">axe</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">axe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">axe</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">axe</span><span class="p">)</span>
                <span class="n">bm_axis</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span><span class="n">axe</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">bm_axis</span><span class="p">)</span>

        <span class="c1"># make a copy if explicitly requested</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># avoid further copies if we can</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="n">mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mgr</span>

    <span class="k">def</span> <span class="nf">_as_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">typ</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private helper function to create a DataFrame with specific manager.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typ : {&quot;block&quot;, &quot;array&quot;}</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Only controls whether the conversion from Block-&gt;ArrayManager</span>
<span class="sd">            copies the 1D arrays (to ensure proper/contiguous memory layout).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            New DataFrame using specified manager type. Is not guaranteed</span>
<span class="sd">            to be a copy or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mgr</span><span class="p">:</span> <span class="n">Manager</span>
        <span class="n">new_mgr</span> <span class="o">=</span> <span class="n">mgr_to_mgr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">typ</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="c1"># fastpath of passing a manager doesn&#39;t check the option/manager class</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_mgr</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># attrs and flags</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary of global attributes of this dataset.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           attrs is experimental and may change without warning.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.flags : Global flags applying to this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span>

    <span class="nd">@attrs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Flags</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the properties associated with this pandas object.</span>

<span class="sd">        The available flags are</span>

<span class="sd">        * :attr:`Flags.allows_duplicate_labels`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Flags : Flags that apply to pandas objects.</span>
<span class="sd">        DataFrame.attrs : Global metadata applying to this dataset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        &quot;Flags&quot; differ from &quot;metadata&quot;. Flags reflect properties of the</span>
<span class="sd">        pandas object (the Series or DataFrame). Metadata refer to properties</span>
<span class="sd">        of the dataset, and should be stored in :attr:`DataFrame.attrs`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2]})</span>
<span class="sd">        &gt;&gt;&gt; df.flags</span>
<span class="sd">        &lt;Flags(allows_duplicate_labels=True)&gt;</span>

<span class="sd">        Flags can be get or set using ``.``</span>

<span class="sd">        &gt;&gt;&gt; df.flags.allows_duplicate_labels</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; df.flags.allows_duplicate_labels = False</span>

<span class="sd">        Or by slicing with a key</span>

<span class="sd">        &gt;&gt;&gt; df.flags[&quot;allows_duplicate_labels&quot;]</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; df.flags[&quot;allows_duplicate_labels&quot;] = True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">set_flags</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allows_duplicate_labels</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new object with updated flags.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            Specify if a copy of the object should be made.</span>
<span class="sd">        allows_duplicate_labels : bool, optional</span>
<span class="sd">            Whether the returned object allows duplicate labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            The same type as the caller.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.attrs : Global metadata applying to this dataset.</span>
<span class="sd">        DataFrame.flags : Global flags applying to this object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method returns a new object that&#39;s a view on the same data</span>
<span class="sd">        as the input. Mutating the input or the output values will be reflected</span>
<span class="sd">        in the other.</span>

<span class="sd">        This method is intended to be used in method chains.</span>

<span class="sd">        &quot;Flags&quot; differ from &quot;metadata&quot;. Flags reflect properties of the</span>
<span class="sd">        pandas object (the Series or DataFrame). Metadata refer to properties</span>
<span class="sd">        of the dataset, and should be stored in :attr:`DataFrame.attrs`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2]})</span>
<span class="sd">        &gt;&gt;&gt; df.flags.allows_duplicate_labels</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; df2 = df.set_flags(allows_duplicate_labels=False)</span>
<span class="sd">        &gt;&gt;&gt; df2.flags.allows_duplicate_labels</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">allows_duplicate_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;allows_duplicate_labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">allows_duplicate_labels</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="nd">@final</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_validate_dtype</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DtypeObj</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;validate the passed dtype&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># a compound dtype</span>
            <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;V&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;compound dtypes are not implemented &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;in the </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> constructor&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">dtype</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Construction</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NDFrameT</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used when a manipulation result has the same dimensions as the</span>
<span class="sd">        original.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Internals</span>

    <span class="nd">@final</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># GH#33054 retained because some downstream packages uses this,</span>
        <span class="c1">#  e.g. fastparquet</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Axis</span>
    <span class="n">_stat_axis_number</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">_stat_axis_name</span> <span class="o">=</span> <span class="s2">&quot;index&quot;</span>
    <span class="n">_AXIS_ORDERS</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">]]</span>
    <span class="n">_AXIS_TO_AXIS_NUMBER</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Axis</span><span class="p">,</span> <span class="n">AxisInt</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;rows&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">_info_axis_number</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">_info_axis_name</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">]</span>
    <span class="n">_AXIS_LEN</span><span class="p">:</span> <span class="nb">int</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_construct_axes_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Axis</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an axes dictionary for myself.&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">axes</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)}</span>
        <span class="c1"># error: Argument 1 to &quot;update&quot; of &quot;MutableMapping&quot; has incompatible type</span>
        <span class="c1"># &quot;Dict[str, Any]&quot;; expected &quot;SupportsKeysAndGetItem[Union[int, str], Any]&quot;</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@final</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_axis_number</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AxisInt</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_TO_AXIS_NUMBER</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No axis named </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> for object type </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_axis_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">]:</span>
        <span class="n">axis_number</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">[</span><span class="n">axis_number</span><span class="p">]</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="n">axis_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">axis_number</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="n">axis_number</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>

    <span class="nd">@final</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_block_manager_axis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AxisInt</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Map the axis to the block_manager axis.&quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># i.e. DataFrame</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span>
        <span class="k">return</span> <span class="n">axis</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_axis_resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">MultiIndex</span><span class="p">]:</span>
        <span class="c1"># index or columns</span>
        <span class="n">axis_index</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axis_index</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">level</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># prefix with &#39;i&#39; or &#39;c&#39; depending on the input axis</span>
                <span class="c1"># e.g., you must do ilevel_0 for the 0th level of an unnamed</span>
                <span class="c1"># multiiindex</span>
                <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">level_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">i</span>

            <span class="n">level_values</span> <span class="o">=</span> <span class="n">axis_index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">level_values</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>
            <span class="n">s</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">axis_index</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="c1"># put the index/columns itself in the dict</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis_index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="n">axis_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="n">axis_index</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>

        <span class="n">d</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">dindex</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_index_resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">MultiIndex</span><span class="p">]:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.computation.parsing</span> <span class="kn">import</span> <span class="n">clean_column_name</span>

        <span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">MultiIndex</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">axis_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_resolvers</span><span class="p">(</span><span class="n">axis_name</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">{</span><span class="n">clean_column_name</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">)}</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_cleaned_column_resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Series</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the special character free column resolvers of a dataframe.</span>

<span class="sd">        Column names with special characters are &#39;cleaned up&#39; so that they can</span>
<span class="sd">        be referred to by backtick quoting.</span>
<span class="sd">        Used in :meth:`DataFrame.eval`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.computation.parsing</span> <span class="kn">import</span> <span class="n">clean_column_name</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">clean_column_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span> <span class="bp">self</span><span class="p">}</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="n">clean_column_name</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_info_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_stat_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of axis dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Index</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index label(s) of the internal NDFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we do it this way because if we have reversed axes, then</span>
        <span class="c1"># the block manager shows then reversed</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an int representing the number of axes / array dimensions.</span>

<span class="sd">        Return 1 if Series. Otherwise return 2 if DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.ndim : Number of array dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})</span>
<span class="sd">        &gt;&gt;&gt; s.ndim</span>
<span class="sd">        1</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df.ndim</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an int representing the number of elements in this object.</span>

<span class="sd">        Return the number of rows if Series. Otherwise return the number of</span>
<span class="sd">        rows times number of columns if DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.size : Number of elements in the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})</span>
<span class="sd">        &gt;&gt;&gt; s.size</span>
<span class="sd">        3</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df.size</span>
<span class="sd">        4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># error: Incompatible return value type (got &quot;signedinteger[_64Bit]&quot;,</span>
        <span class="c1"># expected &quot;int&quot;)  [return-value]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># type: ignore[return-value]</span>

    <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign desired index to given axis.</span>

<span class="sd">        Indexes for%(extended_summary_sub)s row labels can be changed by assigning</span>
<span class="sd">        a list-like or Index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : list-like, Index</span>
<span class="sd">            The values for the new index.</span>

<span class="sd">        axis : %(axes_single_arg)s, default 0</span>
<span class="sd">            The axis to update. The value 0 identifies the rows. For `Series`</span>
<span class="sd">            this parameter is unused and defaults to 0.</span>

<span class="sd">        copy : bool, default True</span>
<span class="sd">            Whether to make a copy of the underlying data.</span>

<span class="sd">            .. versionadded:: 1.5.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s</span>
<span class="sd">            An object of type %(klass)s.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        %(klass)s.rename_axis : Alter the name of the index%(see_also_sub)s.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_axis_nocheck</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_set_axis_nocheck</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">labels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># With copy=False, we create a new object but don&#39;t copy the</span>
            <span class="c1">#  underlying data.</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">())</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">labels</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">AnyArrayLike</span> <span class="o">|</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is called from the cython code when we set the `index` attribute</span>
<span class="sd">        directly, e.g. `series.index = [1, 2, 3]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">axis1</span><span class="p">:</span> <span class="n">Axis</span><span class="p">,</span> <span class="n">axis2</span><span class="p">:</span> <span class="n">Axis</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interchange axes and swap values axes appropriately.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same as input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis1</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">())</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span>

        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)]</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">using_copy_on_write</span><span class="p">()</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">is_single_block</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># This should only get hit in case of having a single block, otherwise a</span>
            <span class="c1"># copy is made, we don&#39;t have to set up references.</span>
            <span class="n">new_mgr</span> <span class="o">=</span> <span class="n">ndarray_to_mgr</span><span class="p">(</span>
                <span class="n">new_values</span><span class="p">,</span>
                <span class="n">new_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">new_axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">typ</span><span class="o">=</span><span class="s2">&quot;block&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_mgr</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">)</span>
            <span class="n">new_mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">refs</span>
            <span class="n">new_mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">add_reference</span><span class="p">(</span>
                <span class="n">new_mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_mgr</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;swapaxes&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">copy</span> <span class="ow">or</span> <span class="n">copy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">is_single_block</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="n">new_values</span><span class="p">,</span>
            <span class="o">*</span><span class="n">new_axes</span><span class="p">,</span>
            <span class="c1"># The no-copy case for CoW is handled above</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;swapaxes&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">droplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return {klass} with requested index / column level(s) removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, or list-like</span>
<span class="sd">            If a string is given, must be the name of a level</span>
<span class="sd">            If list-like, elements must be names or positional indexes</span>
<span class="sd">            of levels.</span>

<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;}}, default 0</span>
<span class="sd">            Axis along which the level(s) is removed:</span>

<span class="sd">            * 0 or &#39;index&#39;: remove level(s) in column.</span>
<span class="sd">            * 1 or &#39;columns&#39;: remove level(s) in row.</span>

<span class="sd">            For `Series` this parameter is unused and defaults to 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass}</span>
<span class="sd">            {klass} with requested index / column level(s) removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([</span>
<span class="sd">        ...     [1, 2, 3, 4],</span>
<span class="sd">        ...     [5, 6, 7, 8],</span>
<span class="sd">        ...     [9, 10, 11, 12]</span>
<span class="sd">        ... ]).set_index([0, 1]).rename_axis([&#39;a&#39;, &#39;b&#39;])</span>

<span class="sd">        &gt;&gt;&gt; df.columns = pd.MultiIndex.from_tuples([</span>
<span class="sd">        ...     (&#39;c&#39;, &#39;e&#39;), (&#39;d&#39;, &#39;f&#39;)</span>
<span class="sd">        ... ], names=[&#39;level_1&#39;, &#39;level_2&#39;])</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">        level_1   c   d</span>
<span class="sd">        level_2   e   f</span>
<span class="sd">        a b</span>
<span class="sd">        1 2      3   4</span>
<span class="sd">        5 6      7   8</span>
<span class="sd">        9 10    11  12</span>

<span class="sd">        &gt;&gt;&gt; df.droplevel(&#39;a&#39;)</span>
<span class="sd">        level_1   c   d</span>
<span class="sd">        level_2   e   f</span>
<span class="sd">        b</span>
<span class="sd">        2        3   4</span>
<span class="sd">        6        7   8</span>
<span class="sd">        10      11  12</span>

<span class="sd">        &gt;&gt;&gt; df.droplevel(&#39;level_2&#39;, axis=1)</span>
<span class="sd">        level_1   c   d</span>
<span class="sd">        a b</span>
<span class="sd">        1 2      3   4</span>
<span class="sd">        5 6      7   8</span>
<span class="sd">        9 10    11  12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">new_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">new_labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">Any</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Squeeze 1 dimensional axis objects into scalars.</span>

<span class="sd">        Series or DataFrames with a single element are squeezed to a scalar.</span>
<span class="sd">        DataFrames with a single column or a single row are squeezed to a</span>
<span class="sd">        Series. Otherwise the object is unchanged.</span>

<span class="sd">        This method is most useful when you don&#39;t know if your</span>
<span class="sd">        object is a Series or DataFrame, but you do know it has just a single</span>
<span class="sd">        column. In that case you can safely call `squeeze` to ensure you have a</span>
<span class="sd">        Series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default None</span>
<span class="sd">            A specific axis to squeeze. By default, all length-1 axes are</span>
<span class="sd">            squeezed. For `Series` this parameter is unused and defaults to `None`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame, Series, or scalar</span>
<span class="sd">            The projection after squeezing `axis` or all the axes.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.iloc : Integer-location based indexing for selecting scalars.</span>
<span class="sd">        DataFrame.iloc : Integer-location based indexing for selecting Series.</span>
<span class="sd">        Series.to_frame : Inverse of DataFrame.squeeze for a</span>
<span class="sd">            single-column DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; primes = pd.Series([2, 3, 5, 7])</span>

<span class="sd">        Slicing might produce a Series with a single value:</span>

<span class="sd">        &gt;&gt;&gt; even_primes = primes[primes % 2 == 0]</span>
<span class="sd">        &gt;&gt;&gt; even_primes</span>
<span class="sd">        0    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; even_primes.squeeze()</span>
<span class="sd">        2</span>

<span class="sd">        Squeezing objects with more than one value in every axis does nothing:</span>

<span class="sd">        &gt;&gt;&gt; odd_primes = primes[primes % 2 == 1]</span>
<span class="sd">        &gt;&gt;&gt; odd_primes</span>
<span class="sd">        1    3</span>
<span class="sd">        2    5</span>
<span class="sd">        3    7</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; odd_primes.squeeze()</span>
<span class="sd">        1    3</span>
<span class="sd">        2    5</span>
<span class="sd">        3    7</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Squeezing is even more effective when used with DataFrames.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], columns=[&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           a  b</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  3  4</span>

<span class="sd">        Slicing a single column will produce a DataFrame with the columns</span>
<span class="sd">        having only one value:</span>

<span class="sd">        &gt;&gt;&gt; df_a = df[[&#39;a&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; df_a</span>
<span class="sd">           a</span>
<span class="sd">        0  1</span>
<span class="sd">        1  3</span>

<span class="sd">        So the columns can be squeezed down, resulting in a Series:</span>

<span class="sd">        &gt;&gt;&gt; df_a.squeeze(&#39;columns&#39;)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    3</span>
<span class="sd">        Name: a, dtype: int64</span>

<span class="sd">        Slicing a single row from a single column will produce a single</span>
<span class="sd">        scalar DataFrame:</span>

<span class="sd">        &gt;&gt;&gt; df_0a = df.loc[df.index &lt; 1, [&#39;a&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; df_0a</span>
<span class="sd">           a</span>
<span class="sd">        0  1</span>

<span class="sd">        Squeezing the rows produces a single scalar Series:</span>

<span class="sd">        &gt;&gt;&gt; df_0a.squeeze(&#39;rows&#39;)</span>
<span class="sd">        a    1</span>
<span class="sd">        Name: 0, dtype: int64</span>

<span class="sd">        Squeezing all axes will project directly into a scalar:</span>

<span class="sd">        &gt;&gt;&gt; df_0a.squeeze()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">),)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
            <span class="nb">tuple</span><span class="p">(</span>
                <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Rename</span>

    <span class="k">def</span> <span class="nf">_rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># called by Series.rename and DataFrame.rename</span>

        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;must pass an index to rename&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify both &#39;axis&#39; and any of &#39;index&#39; or &#39;columns&#39;&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify both &#39;mapper&#39; and any of &#39;index&#39; or &#39;columns&#39;&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use the mapper argument</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">mapper</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">mapper</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inplace_and_allows_duplicate_labels</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">axis_no</span><span class="p">,</span> <span class="n">replacements</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">replacements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis_no</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">get_rename_function</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

            <span class="c1"># GH 13473</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">replacements</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">indexer</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">level</span><span class="p">)</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indexer</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">[</span><span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">missing_labels</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">label</span>
                        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">indexer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="p">]</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">missing_labels</span><span class="si">}</span><span class="s2"> not found in axis&quot;</span><span class="p">)</span>

            <span class="n">new_index</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">_transform_index</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_set_axis_nocheck</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_no</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;rename&quot;</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">rename_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">rename_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">rename_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">rename_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the name of the axis for the index or columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapper : scalar, list-like, optional</span>
<span class="sd">            Value to set the axis name attribute.</span>
<span class="sd">        index, columns : scalar, list-like, dict-like or function, optional</span>
<span class="sd">            A scalar, list-like, dict-like or functions transformations to</span>
<span class="sd">            apply to that axis&#39; values.</span>
<span class="sd">            Note that the ``columns`` parameter is not allowed if the</span>
<span class="sd">            object is a Series. This parameter only apply for DataFrame</span>
<span class="sd">            type objects.</span>

<span class="sd">            Use either ``mapper`` and ``axis`` to</span>
<span class="sd">            specify the axis to target with ``mapper``, or ``index``</span>
<span class="sd">            and/or ``columns``.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to rename. For `Series` this parameter is unused and defaults to 0.</span>
<span class="sd">        copy : bool, default None</span>
<span class="sd">            Also copy underlying data.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Modifies the object directly, instead of creating a new Series</span>
<span class="sd">            or DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series, DataFrame, or None</span>
<span class="sd">            The same type as the caller or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rename : Alter Series index labels or name.</span>
<span class="sd">        DataFrame.rename : Alter DataFrame index labels or name.</span>
<span class="sd">        Index.rename : Set new names on index.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``DataFrame.rename_axis`` supports two calling conventions</span>

<span class="sd">        * ``(index=index_mapper, columns=columns_mapper, ...)``</span>
<span class="sd">        * ``(mapper, axis={&#39;index&#39;, &#39;columns&#39;}, ...)``</span>

<span class="sd">        The first calling convention will only modify the names of</span>
<span class="sd">        the index and/or the names of the Index object that is the columns.</span>
<span class="sd">        In this case, the parameter ``copy`` is ignored.</span>

<span class="sd">        The second calling convention will modify the names of the</span>
<span class="sd">        corresponding index if mapper is a list or a scalar.</span>
<span class="sd">        However, if mapper is dict-like or a function, it will use the</span>
<span class="sd">        deprecated behavior of modifying the axis *labels*.</span>

<span class="sd">        We *highly* recommend using keyword arguments to clarify your</span>
<span class="sd">        intent.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Series**</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&quot;dog&quot;, &quot;cat&quot;, &quot;monkey&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0       dog</span>
<span class="sd">        1       cat</span>
<span class="sd">        2    monkey</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; s.rename_axis(&quot;animal&quot;)</span>
<span class="sd">        animal</span>
<span class="sd">        0    dog</span>
<span class="sd">        1    cat</span>
<span class="sd">        2    monkey</span>
<span class="sd">        dtype: object</span>

<span class="sd">        **DataFrame**</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;num_legs&quot;: [4, 4, 2],</span>
<span class="sd">        ...                    &quot;num_arms&quot;: [0, 0, 2]},</span>
<span class="sd">        ...                   [&quot;dog&quot;, &quot;cat&quot;, &quot;monkey&quot;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs  num_arms</span>
<span class="sd">        dog            4         0</span>
<span class="sd">        cat            4         0</span>
<span class="sd">        monkey         2         2</span>
<span class="sd">        &gt;&gt;&gt; df = df.rename_axis(&quot;animal&quot;)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs  num_arms</span>
<span class="sd">        animal</span>
<span class="sd">        dog            4         0</span>
<span class="sd">        cat            4         0</span>
<span class="sd">        monkey         2         2</span>
<span class="sd">        &gt;&gt;&gt; df = df.rename_axis(&quot;limbs&quot;, axis=&quot;columns&quot;)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">        limbs   num_legs  num_arms</span>
<span class="sd">        animal</span>
<span class="sd">        dog            4         0</span>
<span class="sd">        cat            4         0</span>
<span class="sd">        monkey         2         2</span>

<span class="sd">        **MultiIndex**</span>

<span class="sd">        &gt;&gt;&gt; df.index = pd.MultiIndex.from_product([[&#39;mammal&#39;],</span>
<span class="sd">        ...                                        [&#39;dog&#39;, &#39;cat&#39;, &#39;monkey&#39;]],</span>
<span class="sd">        ...                                       names=[&#39;type&#39;, &#39;name&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">        limbs          num_legs  num_arms</span>
<span class="sd">        type   name</span>
<span class="sd">        mammal dog            4         0</span>
<span class="sd">               cat            4         0</span>
<span class="sd">               monkey         2         2</span>

<span class="sd">        &gt;&gt;&gt; df.rename_axis(index={&#39;type&#39;: &#39;class&#39;})</span>
<span class="sd">        limbs          num_legs  num_arms</span>
<span class="sd">        class  name</span>
<span class="sd">        mammal dog            4         0</span>
<span class="sd">               cat            4         0</span>
<span class="sd">               monkey         2         2</span>

<span class="sd">        &gt;&gt;&gt; df.rename_axis(columns=str.upper)</span>
<span class="sd">        LIMBS          num_legs  num_arms</span>
<span class="sd">        type   name</span>
<span class="sd">        mammal dog            4         0</span>
<span class="sd">               cat            4         0</span>
<span class="sd">               monkey         2         2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">:</span> <span class="n">columns</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="c1"># Use v0.23 behavior if a scalar or list</span>
            <span class="n">non_mapper</span> <span class="o">=</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">is_list_like</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">non_mapper</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_axis_name</span><span class="p">(</span>
                    <span class="n">mapper</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Use `.rename` to alter labels with a mapper.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use new behavior.  Means that index and/or columns</span>
            <span class="c1"># is specified</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">non_mapper</span> <span class="o">=</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">non_mapper</span><span class="p">:</span>
                    <span class="n">newnames</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">get_rename_function</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">curnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
                    <span class="n">newnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">curnames</span><span class="p">]</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_set_axis_name</span><span class="p">(</span><span class="n">newnames</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_set_axis_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the name(s) of the axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str or list of str</span>
<span class="sd">            Name(s) to set.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to set the label. The value 0 or &#39;index&#39; specifies index,</span>
<span class="sd">            and the value 1 or &#39;columns&#39; specifies columns.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If `True`, do operation inplace and return None.</span>
<span class="sd">        copy:</span>
<span class="sd">            Whether to make a copy of the result.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series, DataFrame, or None</span>
<span class="sd">            The same type as the caller or `None` if `inplace` is `True`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.rename : Alter the axis labels of :class:`DataFrame`.</span>
<span class="sd">        Series.rename : Alter the index labels or set the index name</span>
<span class="sd">            of :class:`Series`.</span>
<span class="sd">        Index.rename : Set the name of :class:`Index` or :class:`MultiIndex`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;num_legs&quot;: [4, 4, 2]},</span>
<span class="sd">        ...                   [&quot;dog&quot;, &quot;cat&quot;, &quot;monkey&quot;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs</span>
<span class="sd">        dog            4</span>
<span class="sd">        cat            4</span>
<span class="sd">        monkey         2</span>
<span class="sd">        &gt;&gt;&gt; df._set_axis_name(&quot;animal&quot;)</span>
<span class="sd">                num_legs</span>
<span class="sd">        animal</span>
<span class="sd">        dog            4</span>
<span class="sd">        cat            4</span>
<span class="sd">        monkey         2</span>
<span class="sd">        &gt;&gt;&gt; df.index = pd.MultiIndex.from_product(</span>
<span class="sd">        ...                [[&quot;mammal&quot;], [&#39;dog&#39;, &#39;cat&#39;, &#39;monkey&#39;]])</span>
<span class="sd">        &gt;&gt;&gt; df._set_axis_name([&quot;type&quot;, &quot;name&quot;])</span>
<span class="sd">                       num_legs</span>
<span class="sd">        type   name</span>
<span class="sd">        mammal dog        4</span>
<span class="sd">               cat        4</span>
<span class="sd">               monkey     2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">set_names</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">renamed</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">renamed</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">renamed</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">renamed</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Comparison Methods</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_indexed_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether two objects contain the same elements.</span>

<span class="sd">        This function allows two Series or DataFrames to be compared against</span>
<span class="sd">        each other to see if they have the same shape and elements. NaNs in</span>
<span class="sd">        the same location are considered equal.</span>

<span class="sd">        The row/column index do not need to have the same type, as long</span>
<span class="sd">        as the values are considered equal. Corresponding columns must be of</span>
<span class="sd">        the same dtype.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series or DataFrame</span>
<span class="sd">            The other Series or DataFrame to be compared with the first.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if all elements are the same in both objects, False</span>
<span class="sd">            otherwise.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.eq : Compare two Series objects of the same length</span>
<span class="sd">            and return a Series where each element is True if the element</span>
<span class="sd">            in each Series is equal, False otherwise.</span>
<span class="sd">        DataFrame.eq : Compare two DataFrame objects of the same shape and</span>
<span class="sd">            return a DataFrame where each element is True if the respective</span>
<span class="sd">            element in each DataFrame is equal, False otherwise.</span>
<span class="sd">        testing.assert_series_equal : Raises an AssertionError if left and</span>
<span class="sd">            right are not equal. Provides an easy interface to ignore</span>
<span class="sd">            inequality in dtypes, indexes and precision among others.</span>
<span class="sd">        testing.assert_frame_equal : Like assert_series_equal, but targets</span>
<span class="sd">            DataFrames.</span>
<span class="sd">        numpy.array_equal : Return True if two arrays have the same shape</span>
<span class="sd">            and elements, False otherwise.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({1: [10], 2: [20]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            1   2</span>
<span class="sd">        0  10  20</span>

<span class="sd">        DataFrames df and exactly_equal have the same types and values for</span>
<span class="sd">        their elements and column labels, which will return True.</span>

<span class="sd">        &gt;&gt;&gt; exactly_equal = pd.DataFrame({1: [10], 2: [20]})</span>
<span class="sd">        &gt;&gt;&gt; exactly_equal</span>
<span class="sd">            1   2</span>
<span class="sd">        0  10  20</span>
<span class="sd">        &gt;&gt;&gt; df.equals(exactly_equal)</span>
<span class="sd">        True</span>

<span class="sd">        DataFrames df and different_column_type have the same element</span>
<span class="sd">        types and values, but have different types for the column labels,</span>
<span class="sd">        which will still return True.</span>

<span class="sd">        &gt;&gt;&gt; different_column_type = pd.DataFrame({1.0: [10], 2.0: [20]})</span>
<span class="sd">        &gt;&gt;&gt; different_column_type</span>
<span class="sd">           1.0  2.0</span>
<span class="sd">        0   10   20</span>
<span class="sd">        &gt;&gt;&gt; df.equals(different_column_type)</span>
<span class="sd">        True</span>

<span class="sd">        DataFrames df and different_data_type have different types for the</span>
<span class="sd">        same values for their elements, and will return False even though</span>
<span class="sd">        their column labels are the same values and types.</span>

<span class="sd">        &gt;&gt;&gt; different_data_type = pd.DataFrame({1: [10.0], 2: [20.0]})</span>
<span class="sd">        &gt;&gt;&gt; different_data_type</span>
<span class="sd">              1     2</span>
<span class="sd">        0  10.0  20.0</span>
<span class="sd">        &gt;&gt;&gt; df.equals(different_data_type)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">NDFrame</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_mgr</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Unary Methods</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">blk_func</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># error: Argument 1 to &quot;inv&quot; has incompatible type &quot;Union</span>
                <span class="c1"># [ExtensionArray, ndarray[Any, Any]]&quot;; expected</span>
                <span class="c1"># &quot;_SupportsInversion[ndarray[Any, dtype[bool_]]]&quot;</span>
                <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># error: Argument 1 to &quot;neg&quot; has incompatible type &quot;Union</span>
                <span class="c1"># [ExtensionArray, ndarray[Any, Any]]&quot;; expected</span>
                <span class="c1"># &quot;_SupportsNeg[ndarray[Any, dtype[Any]]]&quot;</span>
                <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">blk_func</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;__neg__&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">blk_func</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># error: Argument 1 to &quot;pos&quot; has incompatible type &quot;Union</span>
                <span class="c1"># [ExtensionArray, ndarray[Any, Any]]&quot;; expected</span>
                <span class="c1"># &quot;_SupportsPos[ndarray[Any, dtype[Any]]]&quot;</span>
                <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">pos</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">blk_func</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;__pos__&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># inv fails with 0 len</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">invert</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;__invert__&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The truth value of a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is ambiguous. &quot;</span>
            <span class="s2">&quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot;</span>
        <span class="p">)</span>

    <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">bool</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the bool of a single element Series or DataFrame.</span>

<span class="sd">        This must be a boolean scalar value, either True or False. It will raise a</span>
<span class="sd">        ValueError if the Series or DataFrame does not have exactly 1 element, or that</span>
<span class="sd">        element is not boolean (integer values 0 and 1 will also raise an exception).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            The value in the Series or DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.astype : Change the data type of a Series, including to boolean.</span>
<span class="sd">        DataFrame.astype : Change the data type of a DataFrame, including to boolean.</span>
<span class="sd">        numpy.bool_ : NumPy boolean data type, used by pandas for boolean values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The method will only work for single element objects with a boolean value:</span>

<span class="sd">        &gt;&gt;&gt; pd.Series([True]).bool()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; pd.Series([False]).bool()</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; pd.DataFrame({&#39;col&#39;: [True]}).bool()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame({&#39;col&#39;: [False]}).bool()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;bool cannot act on a non-boolean single element &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__nonzero__</span><span class="p">()</span>
        <span class="c1"># for mypy (__nonzero__ raises)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Series/DataFrame with absolute numeric value of each element.</span>

<span class="sd">        This function only applies to elements that are all numeric.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        abs</span>
<span class="sd">            Series/DataFrame containing the absolute value of each element.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.absolute : Calculate the absolute value element-wise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For ``complex`` inputs, ``1.2 + 1j``, the absolute value is</span>
<span class="sd">        :math:`\\sqrt{ a^2 + b^2 }`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Absolute numeric values in a Series.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([-1.10, 2, -3.33, 4])</span>
<span class="sd">        &gt;&gt;&gt; s.abs()</span>
<span class="sd">        0    1.10</span>
<span class="sd">        1    2.00</span>
<span class="sd">        2    3.33</span>
<span class="sd">        3    4.00</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Absolute numeric values in a Series with complex numbers.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1.2 + 1j])</span>
<span class="sd">        &gt;&gt;&gt; s.abs()</span>
<span class="sd">        0    1.56205</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Absolute numeric values in a Series with a Timedelta element.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([pd.Timedelta(&#39;1 days&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; s.abs()</span>
<span class="sd">        0   1 days</span>
<span class="sd">        dtype: timedelta64[ns]</span>

<span class="sd">        Select rows with data closest to certain value using argsort (from</span>
<span class="sd">        `StackOverflow &lt;https://stackoverflow.com/a/17758115&gt;`__).</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...     &#39;a&#39;: [4, 5, 6, 7],</span>
<span class="sd">        ...     &#39;b&#39;: [10, 20, 30, 40],</span>
<span class="sd">        ...     &#39;c&#39;: [100, 50, -30, -50]</span>
<span class="sd">        ... })</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             a    b    c</span>
<span class="sd">        0    4   10  100</span>
<span class="sd">        1    5   20   50</span>
<span class="sd">        2    6   30  -30</span>
<span class="sd">        3    7   40  -50</span>
<span class="sd">        &gt;&gt;&gt; df.loc[(df.c - 43).abs().argsort()]</span>
<span class="sd">             a    b    c</span>
<span class="sd">        1    5   20   50</span>
<span class="sd">        0    4   10  100</span>
<span class="sd">        2    6   30  -30</span>
<span class="sd">        3    7   40  -50</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res_mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_mgr</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;abs&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="fm">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">decimals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;__round__&quot;</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Label or Level Combination Helpers</span>
    <span class="c1">#</span>
    <span class="c1"># A collection of helper methods for DataFrame/Series operations that</span>
    <span class="c1"># accept a combination of column/index labels and levels.  All such</span>
    <span class="c1"># operations should utilize/extend these methods when possible so that we</span>
    <span class="c1"># have consistent precedence and validation logic throughout the library.</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_is_level_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Level</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether a key is a level reference for a given axis.</span>

<span class="sd">        To be considered a level reference, `key` must be a string that:</span>
<span class="sd">          - (axis=0): Matches the name of an index level and does NOT match</span>
<span class="sd">            a column label.</span>
<span class="sd">          - (axis=1): Matches the name of a column level and does NOT match</span>
<span class="sd">            an index label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : Hashable</span>
<span class="sd">            Potential level name for the given axis</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis that levels are associated with (0 for index, 1 for columns)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_level : bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span><span class="o">.</span><span class="n">names</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label_reference</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_int</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_is_label_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Level</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether a key is a label reference for a given axis.</span>

<span class="sd">        To be considered a label reference, `key` must be a string that:</span>
<span class="sd">          - (axis=0): Matches a column label</span>
<span class="sd">          - (axis=1): Matches an index label</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : Hashable</span>
<span class="sd">            Potential label name, i.e. Index entry.</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis perpendicular to the axis that labels are associated with</span>
<span class="sd">            (0 means search for column labels, 1 means search for index labels)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_label: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">other_axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="n">axis_int</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">other_axes</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_is_label_or_level_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Level</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether a key is a label or level reference for a given axis.</span>

<span class="sd">        To be considered either a label or a level reference, `key` must be a</span>
<span class="sd">        string that:</span>
<span class="sd">          - (axis=0): Matches a column label or an index level</span>
<span class="sd">          - (axis=1): Matches an index label or a column level</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : Hashable</span>
<span class="sd">            Potential label or level name</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis that levels are associated with (0 for index, 1 for columns)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_level_reference</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label_reference</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_check_label_or_level_ambiguity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Level</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether `key` is ambiguous.</span>

<span class="sd">        By ambiguous, we mean that it matches both a level of the input</span>
<span class="sd">        `axis` and a label of the other axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : Hashable</span>
<span class="sd">            Label or level name.</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis that levels are associated with (0 for index, 1 for columns).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError: `key` is ambiguous</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">axis_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">other_axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="n">axis_int</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span><span class="o">.</span><span class="n">names</span>
            <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">other_axes</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Build an informative and grammatical warning</span>
            <span class="n">level_article</span><span class="p">,</span> <span class="n">level_type</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;an&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">axis_int</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;column&quot;</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">label_article</span><span class="p">,</span> <span class="n">label_type</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;column&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">axis_int</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;an&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is both </span><span class="si">{</span><span class="n">level_article</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">level_type</span><span class="si">}</span><span class="s2"> level and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_article</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">label_type</span><span class="si">}</span><span class="s2"> label, which is ambiguous.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_label_or_level_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Level</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a 1-D array of values associated with `key`, a label or level</span>
<span class="sd">        from the given `axis`.</span>

<span class="sd">        Retrieval logic:</span>
<span class="sd">          - (axis=0): Return column values if `key` matches a column label.</span>
<span class="sd">            Otherwise return index level values if `key` matches an index</span>
<span class="sd">            level.</span>
<span class="sd">          - (axis=1): Return row values if `key` matches an index label.</span>
<span class="sd">            Otherwise return column level values if &#39;key&#39; matches a column</span>
<span class="sd">            level</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : Hashable</span>
<span class="sd">            Label or level name.</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis that levels are associated with (0 for index, 1 for columns)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray or ExtensionArray</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            if `key` matches neither a label nor a level</span>
<span class="sd">        ValueError</span>
<span class="sd">            if `key` matches multiple labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">other_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="n">axis</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label_reference</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_label_or_level_ambiguity</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">other_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_level_reference</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># Check for duplicates</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other_axes</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">other_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">multi_message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;For a multi-index, the label must be a &quot;</span>
                    <span class="s2">&quot;tuple with elements corresponding to each level.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">multi_message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="n">label_axis_name</span> <span class="o">=</span> <span class="s2">&quot;column&quot;</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;index&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">label_axis_name</span><span class="si">}</span><span class="s2"> label &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is not unique.</span><span class="si">{</span><span class="n">multi_message</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">values</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_drop_labels_or_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop labels and/or levels for the given `axis`.</span>

<span class="sd">        For each key in `keys`:</span>
<span class="sd">          - (axis=0): If key matches a column label then drop the column.</span>
<span class="sd">            Otherwise if key matches an index level then drop the level.</span>
<span class="sd">          - (axis=1): If key matches an index label then drop the row.</span>
<span class="sd">            Otherwise if key matches a column level then drop the level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : str or list of str</span>
<span class="sd">            labels or levels to drop</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis that levels are associated with (0 for index, 1 for columns)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped: DataFrame</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if any `keys` match neither a label nor a level</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># Validate keys</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">maybe_make_list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="n">invalid_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label_or_level_reference</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">invalid_keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The following keys are not valid labels or &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;levels for axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">invalid_keys</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Compute levels and labels to drop</span>
        <span class="n">levels_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_level_reference</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)]</span>

        <span class="n">labels_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_level_reference</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)]</span>

        <span class="c1"># Perform copy upfront and then use inplace operations below.</span>
        <span class="c1"># This ensures that we always perform exactly one copy.</span>
        <span class="c1"># ``copy`` and/or ``inplace`` options could be added in the future.</span>
        <span class="n">dropped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Handle dropping index levels</span>
            <span class="k">if</span> <span class="n">levels_to_drop</span><span class="p">:</span>
                <span class="n">dropped</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">levels_to_drop</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Handle dropping columns labels</span>
            <span class="k">if</span> <span class="n">labels_to_drop</span><span class="p">:</span>
                <span class="n">dropped</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels_to_drop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Handle dropping column levels</span>
            <span class="k">if</span> <span class="n">levels_to_drop</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dropped</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="c1"># Drop the specified levels from the MultiIndex</span>
                    <span class="n">dropped</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">dropped</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">levels_to_drop</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Drop the last level of Index by replacing with</span>
                    <span class="c1"># a RangeIndex</span>
                    <span class="n">dropped</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">RangeIndex</span><span class="p">(</span><span class="n">dropped</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

            <span class="c1"># Handle dropping index labels</span>
            <span class="k">if</span> <span class="n">labels_to_drop</span><span class="p">:</span>
                <span class="n">dropped</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels_to_drop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dropped</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Iteration</span>

    <span class="c1"># https://github.com/python/typeshed/issues/2148#issuecomment-520783318</span>
    <span class="c1"># Incompatible types in assignment (expression has type &quot;None&quot;, base class</span>
    <span class="c1"># &quot;object&quot; defined the type as &quot;Callable[[object], int]&quot;)</span>
    <span class="fm">__hash__</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>  <span class="c1"># type: ignore[assignment]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over info axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iterator</span>
<span class="sd">            Info axis as iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">)</span>

    <span class="c1"># can we get a better explanation of this?</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the &#39;info axis&#39; (see Indexing for more).</span>

<span class="sd">        This is index for Series, columns for DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">            Info axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over (label, values) on info axis</span>

<span class="sd">        This is index for Series and columns for DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Generator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns length of info axis&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if the key is in the info axis&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicator whether Series/DataFrame is empty.</span>

<span class="sd">        True if Series/DataFrame is entirely empty (no items), meaning any of the</span>
<span class="sd">        axes are of length 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            If Series/DataFrame is empty, return True, if not return False.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.dropna : Return series without null values.</span>
<span class="sd">        DataFrame.dropna : Return DataFrame with labels on given axis omitted</span>
<span class="sd">            where (all or any) data are missing.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If Series/DataFrame contains only NaNs, it is still not considered empty. See</span>
<span class="sd">        the example below.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        An example of an actual empty DataFrame. Notice the index is empty:</span>

<span class="sd">        &gt;&gt;&gt; df_empty = pd.DataFrame({&#39;A&#39; : []})</span>
<span class="sd">        &gt;&gt;&gt; df_empty</span>
<span class="sd">        Empty DataFrame</span>
<span class="sd">        Columns: [A]</span>
<span class="sd">        Index: []</span>
<span class="sd">        &gt;&gt;&gt; df_empty.empty</span>
<span class="sd">        True</span>

<span class="sd">        If we only have NaNs in our DataFrame, it is not considered empty! We</span>
<span class="sd">        will need to drop the NaNs to make the DataFrame empty:</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39; : [np.nan]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            A</span>
<span class="sd">        0 NaN</span>
<span class="sd">        &gt;&gt;&gt; df.empty</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; df.dropna().empty</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; ser_empty = pd.Series({&#39;A&#39; : []})</span>
<span class="sd">        &gt;&gt;&gt; ser_empty</span>
<span class="sd">        A    []</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; ser_empty.empty</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ser_empty = pd.Series()</span>
<span class="sd">        &gt;&gt;&gt; ser_empty.empty</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Array Interface</span>

    <span class="c1"># This is also set in IndexOpsMixin</span>
    <span class="c1"># GH#23114 Ensure ndarray.__op__(DataFrame) returns NotImplemented</span>
    <span class="n">__array_priority__</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">astype_is_view</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">using_copy_on_write</span><span class="p">()</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">is_single_block</span>
        <span class="p">):</span>
            <span class="c1"># Check if both conversions can be done without a copy</span>
            <span class="k">if</span> <span class="n">astype_is_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">astype_is_view</span><span class="p">(</span>
                <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">):</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
                <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">arraylike</span><span class="o">.</span><span class="n">array_ufunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Picklability</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">}</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;_mgr&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">,</span>
            <span class="s2">&quot;_typ&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_typ</span><span class="p">,</span>
            <span class="s2">&quot;_metadata&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">,</span>
            <span class="s2">&quot;attrs&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
            <span class="s2">&quot;_flags&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">_keys</span><span class="p">},</span>
            <span class="o">**</span><span class="n">meta</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;_data&quot;</span> <span class="ow">in</span> <span class="n">state</span> <span class="ow">and</span> <span class="s2">&quot;_mgr&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
                <span class="c1"># compat for older pickles</span>
                <span class="n">state</span><span class="p">[</span><span class="s2">&quot;_mgr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_data&quot;</span><span class="p">)</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_typ&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_attrs&quot;</span><span class="p">,</span> <span class="p">{})</span>
                <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_attrs&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
                <span class="n">flags</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_flags&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;allows_duplicate_labels&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
                <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_flags&quot;</span><span class="p">,</span> <span class="n">Flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">))</span>

                <span class="c1"># set in the order of internal names</span>
                <span class="c1"># to avoid definitional recursion</span>
                <span class="c1"># e.g. say fill_value needing _mgr to be</span>
                <span class="c1"># defined</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">meta</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">state</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;_flags&quot;</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">:</span>
                        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Pre-0.12 pickles are no longer supported&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Pre-0.12 pickles are no longer supported&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Rendering Methods</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># string representation based upon iterating over self</span>
        <span class="c1"># (since, by definition, `PandasContainers` are iterable)</span>
        <span class="n">prepr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">pprint_thing</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">))</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">prepr</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_repr_latex_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a LaTeX representation for a particular object.</span>
<span class="sd">        Mainly for use with nbconvert (jupyter notebook conversion to pdf).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;styler.render.repr&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;latex&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_latex</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_repr_data_resource_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Not a real Jupyter special repr method, but we use the same</span>
<span class="sd">        naming convention.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.html.table_schema&quot;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">))</span>

            <span class="n">as_json</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;table&quot;</span><span class="p">)</span>
            <span class="n">as_json</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">as_json</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">loads</span><span class="p">(</span><span class="n">as_json</span><span class="p">,</span> <span class="n">object_pairs_hook</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># I/O Methods</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">klass</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;storage_options&quot;</span><span class="p">],</span>
        <span class="n">storage_options_versionadded</span><span class="o">=</span><span class="s2">&quot;1.2.0&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_excel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">excel_writer</span><span class="p">,</span>
        <span class="n">sheet_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Sheet1&quot;</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">index_label</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">startrow</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">startcol</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">merge_cells</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">inf_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;inf&quot;</span><span class="p">,</span>
        <span class="n">freeze_panes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write {klass} to an Excel sheet.</span>

<span class="sd">        To write a single {klass} to an Excel .xlsx file it is only necessary to</span>
<span class="sd">        specify a target file name. To write to multiple sheets it is necessary to</span>
<span class="sd">        create an `ExcelWriter` object with a target file name, and specify a sheet</span>
<span class="sd">        in the file to write to.</span>

<span class="sd">        Multiple sheets may be written to by specifying unique `sheet_name`.</span>
<span class="sd">        With all data written to the file it is necessary to save the changes.</span>
<span class="sd">        Note that creating an `ExcelWriter` object with a file name that already</span>
<span class="sd">        exists will result in the contents of the existing file being erased.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        excel_writer : path-like, file-like, or ExcelWriter object</span>
<span class="sd">            File path or existing ExcelWriter.</span>
<span class="sd">        sheet_name : str, default &#39;Sheet1&#39;</span>
<span class="sd">            Name of sheet which will contain DataFrame.</span>
<span class="sd">        na_rep : str, default &#39;&#39;</span>
<span class="sd">            Missing data representation.</span>
<span class="sd">        float_format : str, optional</span>
<span class="sd">            Format string for floating point numbers. For example</span>
<span class="sd">            ``float_format=&quot;%.2f&quot;`` will format 0.1234 to 0.12.</span>
<span class="sd">        columns : sequence or list of str, optional</span>
<span class="sd">            Columns to write.</span>
<span class="sd">        header : bool or list of str, default True</span>
<span class="sd">            Write out the column names. If a list of string is given it is</span>
<span class="sd">            assumed to be aliases for the column names.</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Write row names (index).</span>
<span class="sd">        index_label : str or sequence, optional</span>
<span class="sd">            Column label for index column(s) if desired. If not specified, and</span>
<span class="sd">            `header` and `index` are True, then the index names are used. A</span>
<span class="sd">            sequence should be given if the DataFrame uses MultiIndex.</span>
<span class="sd">        startrow : int, default 0</span>
<span class="sd">            Upper left cell row to dump data frame.</span>
<span class="sd">        startcol : int, default 0</span>
<span class="sd">            Upper left cell column to dump data frame.</span>
<span class="sd">        engine : str, optional</span>
<span class="sd">            Write engine to use, &#39;openpyxl&#39; or &#39;xlsxwriter&#39;. You can also set this</span>
<span class="sd">            via the options ``io.excel.xlsx.writer`` or</span>
<span class="sd">            ``io.excel.xlsm.writer``.</span>

<span class="sd">        merge_cells : bool, default True</span>
<span class="sd">            Write MultiIndex and Hierarchical Rows as merged cells.</span>
<span class="sd">        inf_rep : str, default &#39;inf&#39;</span>
<span class="sd">            Representation for infinity (there is no native representation for</span>
<span class="sd">            infinity in Excel).</span>
<span class="sd">        freeze_panes : tuple of int (length 2), optional</span>
<span class="sd">            Specifies the one-based bottommost row and rightmost column that</span>
<span class="sd">            is to be frozen.</span>
<span class="sd">        {storage_options}</span>

<span class="sd">            .. versionadded:: {storage_options_versionadded}</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_csv : Write DataFrame to a comma-separated values (csv) file.</span>
<span class="sd">        ExcelWriter : Class for writing DataFrame objects into excel sheets.</span>
<span class="sd">        read_excel : Read an Excel file into a pandas DataFrame.</span>
<span class="sd">        read_csv : Read a comma-separated values (csv) file into DataFrame.</span>
<span class="sd">        io.formats.style.Styler.to_excel : Add styles to Excel sheet.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For compatibility with :meth:`~DataFrame.to_csv`,</span>
<span class="sd">        to_excel serializes lists and dicts to strings before writing.</span>

<span class="sd">        Once a workbook has been saved it is not possible to write further</span>
<span class="sd">        data without rewriting the whole workbook.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create, write to and save a workbook:</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]],</span>
<span class="sd">        ...                    index=[&#39;row 1&#39;, &#39;row 2&#39;],</span>
<span class="sd">        ...                    columns=[&#39;col 1&#39;, &#39;col 2&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df1.to_excel(&quot;output.xlsx&quot;)  # doctest: +SKIP</span>

<span class="sd">        To specify the sheet name:</span>

<span class="sd">        &gt;&gt;&gt; df1.to_excel(&quot;output.xlsx&quot;,</span>
<span class="sd">        ...              sheet_name=&#39;Sheet_name_1&#39;)  # doctest: +SKIP</span>

<span class="sd">        If you wish to write to more than one sheet in the workbook, it is</span>
<span class="sd">        necessary to specify an ExcelWriter object:</span>

<span class="sd">        &gt;&gt;&gt; df2 = df1.copy()</span>
<span class="sd">        &gt;&gt;&gt; with pd.ExcelWriter(&#39;output.xlsx&#39;) as writer:  # doctest: +SKIP</span>
<span class="sd">        ...     df1.to_excel(writer, sheet_name=&#39;Sheet_name_1&#39;)</span>
<span class="sd">        ...     df2.to_excel(writer, sheet_name=&#39;Sheet_name_2&#39;)</span>

<span class="sd">        ExcelWriter can also be used to append to an existing Excel file:</span>

<span class="sd">        &gt;&gt;&gt; with pd.ExcelWriter(&#39;output.xlsx&#39;,</span>
<span class="sd">        ...                     mode=&#39;a&#39;) as writer:  # doctest: +SKIP</span>
<span class="sd">        ...     df.to_excel(writer, sheet_name=&#39;Sheet_name_3&#39;)</span>

<span class="sd">        To set the library that is used to write the Excel file,</span>
<span class="sd">        you can pass the `engine` keyword (the default engine is</span>
<span class="sd">        automatically chosen depending on the file extension):</span>

<span class="sd">        &gt;&gt;&gt; df1.to_excel(&#39;output1.xlsx&#39;, engine=&#39;xlsxwriter&#39;)  # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">pandas.io.formats.excel</span> <span class="kn">import</span> <span class="n">ExcelFormatter</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">ExcelFormatter</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
            <span class="n">cols</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
            <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span>
            <span class="n">merge_cells</span><span class="o">=</span><span class="n">merge_cells</span><span class="p">,</span>
            <span class="n">inf_rep</span><span class="o">=</span><span class="n">inf_rep</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">formatter</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">excel_writer</span><span class="p">,</span>
            <span class="n">sheet_name</span><span class="o">=</span><span class="n">sheet_name</span><span class="p">,</span>
            <span class="n">startrow</span><span class="o">=</span><span class="n">startrow</span><span class="p">,</span>
            <span class="n">startcol</span><span class="o">=</span><span class="n">startcol</span><span class="p">,</span>
            <span class="n">freeze_panes</span><span class="o">=</span><span class="n">freeze_panes</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
            <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">storage_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;storage_options&quot;</span><span class="p">],</span>
        <span class="n">compression_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;compression_options&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="s2">&quot;path_or_buf&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path_or_buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">orient</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">date_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">double_precision</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">force_ascii</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">date_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ms&quot;</span><span class="p">,</span>
        <span class="n">default_handler</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">JSONSerializable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lines</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="n">CompressionOptions</span> <span class="o">=</span> <span class="s2">&quot;infer&quot;</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the object to a JSON string.</span>

<span class="sd">        Note NaN&#39;s and None will be converted to null and datetime objects</span>
<span class="sd">        will be converted to UNIX timestamps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : str, path object, file-like object, or None, default None</span>
<span class="sd">            String, path object (implementing os.PathLike[str]), or file-like</span>
<span class="sd">            object implementing a write() function. If None, the result is</span>
<span class="sd">            returned as a string.</span>
<span class="sd">        orient : str</span>
<span class="sd">            Indication of expected JSON string format.</span>

<span class="sd">            * Series:</span>

<span class="sd">                - default is &#39;index&#39;</span>
<span class="sd">                - allowed values are: {{&#39;split&#39;, &#39;records&#39;, &#39;index&#39;, &#39;table&#39;}}.</span>

<span class="sd">            * DataFrame:</span>

<span class="sd">                - default is &#39;columns&#39;</span>
<span class="sd">                - allowed values are: {{&#39;split&#39;, &#39;records&#39;, &#39;index&#39;, &#39;columns&#39;,</span>
<span class="sd">                  &#39;values&#39;, &#39;table&#39;}}.</span>

<span class="sd">            * The format of the JSON string:</span>

<span class="sd">                - &#39;split&#39; : dict like {{&#39;index&#39; -&gt; [index], &#39;columns&#39; -&gt; [columns],</span>
<span class="sd">                  &#39;data&#39; -&gt; [values]}}</span>
<span class="sd">                - &#39;records&#39; : list like [{{column -&gt; value}}, ... , {{column -&gt; value}}]</span>
<span class="sd">                - &#39;index&#39; : dict like {{index -&gt; {{column -&gt; value}}}}</span>
<span class="sd">                - &#39;columns&#39; : dict like {{column -&gt; {{index -&gt; value}}}}</span>
<span class="sd">                - &#39;values&#39; : just the values array</span>
<span class="sd">                - &#39;table&#39; : dict like {{&#39;schema&#39;: {{schema}}, &#39;data&#39;: {{data}}}}</span>

<span class="sd">                Describing the data, where data component is like ``orient=&#39;records&#39;``.</span>

<span class="sd">        date_format : {{None, &#39;epoch&#39;, &#39;iso&#39;}}</span>
<span class="sd">            Type of date conversion. &#39;epoch&#39; = epoch milliseconds,</span>
<span class="sd">            &#39;iso&#39; = ISO8601. The default depends on the `orient`. For</span>
<span class="sd">            ``orient=&#39;table&#39;``, the default is &#39;iso&#39;. For all other orients,</span>
<span class="sd">            the default is &#39;epoch&#39;.</span>
<span class="sd">        double_precision : int, default 10</span>
<span class="sd">            The number of decimal places to use when encoding</span>
<span class="sd">            floating point values.</span>
<span class="sd">        force_ascii : bool, default True</span>
<span class="sd">            Force encoded string to be ASCII.</span>
<span class="sd">        date_unit : str, default &#39;ms&#39; (milliseconds)</span>
<span class="sd">            The time unit to encode to, governs timestamp and ISO8601</span>
<span class="sd">            precision.  One of &#39;s&#39;, &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39; for second, millisecond,</span>
<span class="sd">            microsecond, and nanosecond respectively.</span>
<span class="sd">        default_handler : callable, default None</span>
<span class="sd">            Handler to call if object cannot otherwise be converted to a</span>
<span class="sd">            suitable format for JSON. Should receive a single argument which is</span>
<span class="sd">            the object to convert and return a serialisable object.</span>
<span class="sd">        lines : bool, default False</span>
<span class="sd">            If &#39;orient&#39; is &#39;records&#39; write out line-delimited json format. Will</span>
<span class="sd">            throw ValueError if incorrect &#39;orient&#39; since others are not</span>
<span class="sd">            list-like.</span>
<span class="sd">        {compression_options}</span>

<span class="sd">            .. versionchanged:: 1.4.0 Zstandard support.</span>

<span class="sd">        index : bool, default True</span>
<span class="sd">            Whether to include the index values in the JSON string. Not</span>
<span class="sd">            including the index (``index=False``) is only supported when</span>
<span class="sd">            orient is &#39;split&#39; or &#39;table&#39;.</span>
<span class="sd">        indent : int, optional</span>
<span class="sd">           Length of whitespace used to indent each record.</span>

<span class="sd">        {storage_options}</span>

<span class="sd">            .. versionadded:: 1.2.0</span>

<span class="sd">        mode : str, default &#39;w&#39; (writing)</span>
<span class="sd">            Specify the IO mode for output when supplying a path_or_buf.</span>
<span class="sd">            Accepted args are &#39;w&#39; (writing) and &#39;a&#39; (append) only.</span>
<span class="sd">            mode=&#39;a&#39; is only supported when lines is True and orient is &#39;records&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or str</span>
<span class="sd">            If path_or_buf is None, returns the resulting json format as a</span>
<span class="sd">            string. Otherwise returns None.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_json : Convert a JSON string to pandas object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The behavior of ``indent=0`` varies from the stdlib, which does not</span>
<span class="sd">        indent the output but does insert newlines. Currently, ``indent=0``</span>
<span class="sd">        and the default ``indent=None`` are equivalent in pandas, though this</span>
<span class="sd">        may change in a future release.</span>

<span class="sd">        ``orient=&#39;table&#39;`` contains a &#39;pandas_version&#39; field under &#39;schema&#39;.</span>
<span class="sd">        This stores the version of `pandas` used in the latest revision of the</span>
<span class="sd">        schema.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from json import loads, dumps</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(</span>
<span class="sd">        ...     [[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]],</span>
<span class="sd">        ...     index=[&quot;row 1&quot;, &quot;row 2&quot;],</span>
<span class="sd">        ...     columns=[&quot;col 1&quot;, &quot;col 2&quot;],</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; result = df.to_json(orient=&quot;split&quot;)</span>
<span class="sd">        &gt;&gt;&gt; parsed = loads(result)</span>
<span class="sd">        &gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP</span>
<span class="sd">        {{</span>
<span class="sd">            &quot;columns&quot;: [</span>
<span class="sd">                &quot;col 1&quot;,</span>
<span class="sd">                &quot;col 2&quot;</span>
<span class="sd">            ],</span>
<span class="sd">            &quot;index&quot;: [</span>
<span class="sd">                &quot;row 1&quot;,</span>
<span class="sd">                &quot;row 2&quot;</span>
<span class="sd">            ],</span>
<span class="sd">            &quot;data&quot;: [</span>
<span class="sd">                [</span>
<span class="sd">                    &quot;a&quot;,</span>
<span class="sd">                    &quot;b&quot;</span>
<span class="sd">                ],</span>
<span class="sd">                [</span>
<span class="sd">                    &quot;c&quot;,</span>
<span class="sd">                    &quot;d&quot;</span>
<span class="sd">                ]</span>
<span class="sd">            ]</span>
<span class="sd">        }}</span>

<span class="sd">        Encoding/decoding a Dataframe using ``&#39;records&#39;`` formatted JSON.</span>
<span class="sd">        Note that index labels are not preserved with this encoding.</span>

<span class="sd">        &gt;&gt;&gt; result = df.to_json(orient=&quot;records&quot;)</span>
<span class="sd">        &gt;&gt;&gt; parsed = loads(result)</span>
<span class="sd">        &gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP</span>
<span class="sd">        [</span>
<span class="sd">            {{</span>
<span class="sd">                &quot;col 1&quot;: &quot;a&quot;,</span>
<span class="sd">                &quot;col 2&quot;: &quot;b&quot;</span>
<span class="sd">            }},</span>
<span class="sd">            {{</span>
<span class="sd">                &quot;col 1&quot;: &quot;c&quot;,</span>
<span class="sd">                &quot;col 2&quot;: &quot;d&quot;</span>
<span class="sd">            }}</span>
<span class="sd">        ]</span>

<span class="sd">        Encoding/decoding a Dataframe using ``&#39;index&#39;`` formatted JSON:</span>

<span class="sd">        &gt;&gt;&gt; result = df.to_json(orient=&quot;index&quot;)</span>
<span class="sd">        &gt;&gt;&gt; parsed = loads(result)</span>
<span class="sd">        &gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP</span>
<span class="sd">        {{</span>
<span class="sd">            &quot;row 1&quot;: {{</span>
<span class="sd">                &quot;col 1&quot;: &quot;a&quot;,</span>
<span class="sd">                &quot;col 2&quot;: &quot;b&quot;</span>
<span class="sd">            }},</span>
<span class="sd">            &quot;row 2&quot;: {{</span>
<span class="sd">                &quot;col 1&quot;: &quot;c&quot;,</span>
<span class="sd">                &quot;col 2&quot;: &quot;d&quot;</span>
<span class="sd">            }}</span>
<span class="sd">        }}</span>

<span class="sd">        Encoding/decoding a Dataframe using ``&#39;columns&#39;`` formatted JSON:</span>

<span class="sd">        &gt;&gt;&gt; result = df.to_json(orient=&quot;columns&quot;)</span>
<span class="sd">        &gt;&gt;&gt; parsed = loads(result)</span>
<span class="sd">        &gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP</span>
<span class="sd">        {{</span>
<span class="sd">            &quot;col 1&quot;: {{</span>
<span class="sd">                &quot;row 1&quot;: &quot;a&quot;,</span>
<span class="sd">                &quot;row 2&quot;: &quot;c&quot;</span>
<span class="sd">            }},</span>
<span class="sd">            &quot;col 2&quot;: {{</span>
<span class="sd">                &quot;row 1&quot;: &quot;b&quot;,</span>
<span class="sd">                &quot;row 2&quot;: &quot;d&quot;</span>
<span class="sd">            }}</span>
<span class="sd">        }}</span>

<span class="sd">        Encoding/decoding a Dataframe using ``&#39;values&#39;`` formatted JSON:</span>

<span class="sd">        &gt;&gt;&gt; result = df.to_json(orient=&quot;values&quot;)</span>
<span class="sd">        &gt;&gt;&gt; parsed = loads(result)</span>
<span class="sd">        &gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP</span>
<span class="sd">        [</span>
<span class="sd">            [</span>
<span class="sd">                &quot;a&quot;,</span>
<span class="sd">                &quot;b&quot;</span>
<span class="sd">            ],</span>
<span class="sd">            [</span>
<span class="sd">                &quot;c&quot;,</span>
<span class="sd">                &quot;d&quot;</span>
<span class="sd">            ]</span>
<span class="sd">        ]</span>

<span class="sd">        Encoding with Table Schema:</span>

<span class="sd">        &gt;&gt;&gt; result = df.to_json(orient=&quot;table&quot;)</span>
<span class="sd">        &gt;&gt;&gt; parsed = loads(result)</span>
<span class="sd">        &gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP</span>
<span class="sd">        {{</span>
<span class="sd">            &quot;schema&quot;: {{</span>
<span class="sd">                &quot;fields&quot;: [</span>
<span class="sd">                    {{</span>
<span class="sd">                        &quot;name&quot;: &quot;index&quot;,</span>
<span class="sd">                        &quot;type&quot;: &quot;string&quot;</span>
<span class="sd">                    }},</span>
<span class="sd">                    {{</span>
<span class="sd">                        &quot;name&quot;: &quot;col 1&quot;,</span>
<span class="sd">                        &quot;type&quot;: &quot;string&quot;</span>
<span class="sd">                    }},</span>
<span class="sd">                    {{</span>
<span class="sd">                        &quot;name&quot;: &quot;col 2&quot;,</span>
<span class="sd">                        &quot;type&quot;: &quot;string&quot;</span>
<span class="sd">                    }}</span>
<span class="sd">                ],</span>
<span class="sd">                &quot;primaryKey&quot;: [</span>
<span class="sd">                    &quot;index&quot;</span>
<span class="sd">                ],</span>
<span class="sd">                &quot;pandas_version&quot;: &quot;1.4.0&quot;</span>
<span class="sd">            }},</span>
<span class="sd">            &quot;data&quot;: [</span>
<span class="sd">                {{</span>
<span class="sd">                    &quot;index&quot;: &quot;row 1&quot;,</span>
<span class="sd">                    &quot;col 1&quot;: &quot;a&quot;,</span>
<span class="sd">                    &quot;col 2&quot;: &quot;b&quot;</span>
<span class="sd">                }},</span>
<span class="sd">                {{</span>
<span class="sd">                    &quot;index&quot;: &quot;row 2&quot;,</span>
<span class="sd">                    &quot;col 1&quot;: &quot;c&quot;,</span>
<span class="sd">                    &quot;col 2&quot;: &quot;d&quot;</span>
<span class="sd">                }}</span>
<span class="sd">            ]</span>
<span class="sd">        }}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">json</span>

        <span class="k">if</span> <span class="n">date_format</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orient</span> <span class="o">==</span> <span class="s2">&quot;table&quot;</span><span class="p">:</span>
            <span class="n">date_format</span> <span class="o">=</span> <span class="s2">&quot;iso&quot;</span>
        <span class="k">elif</span> <span class="n">date_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">date_format</span> <span class="o">=</span> <span class="s2">&quot;epoch&quot;</span>

        <span class="n">config</span><span class="o">.</span><span class="n">is_nonnegative_int</span><span class="p">(</span><span class="n">indent</span><span class="p">)</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="n">indent</span> <span class="ow">or</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span>
            <span class="n">path_or_buf</span><span class="o">=</span><span class="n">path_or_buf</span><span class="p">,</span>
            <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">orient</span><span class="o">=</span><span class="n">orient</span><span class="p">,</span>
            <span class="n">date_format</span><span class="o">=</span><span class="n">date_format</span><span class="p">,</span>
            <span class="n">double_precision</span><span class="o">=</span><span class="n">double_precision</span><span class="p">,</span>
            <span class="n">force_ascii</span><span class="o">=</span><span class="n">force_ascii</span><span class="p">,</span>
            <span class="n">date_unit</span><span class="o">=</span><span class="n">date_unit</span><span class="p">,</span>
            <span class="n">default_handler</span><span class="o">=</span><span class="n">default_handler</span><span class="p">,</span>
            <span class="n">lines</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">,</span>
            <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">to_hdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path_or_buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">HDFStore</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span>
        <span class="n">complevel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">complib</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">append</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">min_itemsize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nan_rep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dropna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data_columns</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;strict&quot;</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;UTF-8&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the contained data to an HDF5 file using HDFStore.</span>

<span class="sd">        Hierarchical Data Format (HDF) is self-describing, allowing an</span>
<span class="sd">        application to interpret the structure and contents of a file with</span>
<span class="sd">        no outside information. One HDF file can hold a mix of related objects</span>
<span class="sd">        which can be accessed as a group or as individual objects.</span>

<span class="sd">        In order to add another DataFrame or Series to an existing HDF file</span>
<span class="sd">        please use append mode and a different a key.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           One can store a subclass of ``DataFrame`` or ``Series`` to HDF5,</span>
<span class="sd">           but the type of the subclass is lost upon storing.</span>

<span class="sd">        For more information see the :ref:`user guide &lt;io.hdf5&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : str or pandas.HDFStore</span>
<span class="sd">            File path or HDFStore object.</span>
<span class="sd">        key : str</span>
<span class="sd">            Identifier for the group in the store.</span>
<span class="sd">        mode : {&#39;a&#39;, &#39;w&#39;, &#39;r+&#39;}, default &#39;a&#39;</span>
<span class="sd">            Mode to open file:</span>

<span class="sd">            - &#39;w&#39;: write, a new file is created (an existing file with</span>
<span class="sd">              the same name would be deleted).</span>
<span class="sd">            - &#39;a&#39;: append, an existing file is opened for reading and</span>
<span class="sd">              writing, and if the file does not exist it is created.</span>
<span class="sd">            - &#39;r+&#39;: similar to &#39;a&#39;, but the file must already exist.</span>
<span class="sd">        complevel : {0-9}, default None</span>
<span class="sd">            Specifies a compression level for data.</span>
<span class="sd">            A value of 0 or None disables compression.</span>
<span class="sd">        complib : {&#39;zlib&#39;, &#39;lzo&#39;, &#39;bzip2&#39;, &#39;blosc&#39;}, default &#39;zlib&#39;</span>
<span class="sd">            Specifies the compression library to be used.</span>
<span class="sd">            As of v0.20.2 these additional compressors for Blosc are supported</span>
<span class="sd">            (default if no compressor specified: &#39;blosc:blosclz&#39;):</span>
<span class="sd">            {&#39;blosc:blosclz&#39;, &#39;blosc:lz4&#39;, &#39;blosc:lz4hc&#39;, &#39;blosc:snappy&#39;,</span>
<span class="sd">            &#39;blosc:zlib&#39;, &#39;blosc:zstd&#39;}.</span>
<span class="sd">            Specifying a compression library which is not available issues</span>
<span class="sd">            a ValueError.</span>
<span class="sd">        append : bool, default False</span>
<span class="sd">            For Table formats, append the input data to the existing.</span>
<span class="sd">        format : {&#39;fixed&#39;, &#39;table&#39;, None}, default &#39;fixed&#39;</span>
<span class="sd">            Possible values:</span>

<span class="sd">            - &#39;fixed&#39;: Fixed format. Fast writing/reading. Not-appendable,</span>
<span class="sd">              nor searchable.</span>
<span class="sd">            - &#39;table&#39;: Table format. Write as a PyTables Table structure</span>
<span class="sd">              which may perform worse but allow more flexible operations</span>
<span class="sd">              like searching / selecting subsets of the data.</span>
<span class="sd">            - If None, pd.get_option(&#39;io.hdf.default_format&#39;) is checked,</span>
<span class="sd">              followed by fallback to &quot;fixed&quot;.</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Write DataFrame index as a column.</span>
<span class="sd">        min_itemsize : dict or int, optional</span>
<span class="sd">            Map column names to minimum string sizes for columns.</span>
<span class="sd">        nan_rep : Any, optional</span>
<span class="sd">            How to represent null values as str.</span>
<span class="sd">            Not allowed with append=True.</span>
<span class="sd">        dropna : bool, default False, optional</span>
<span class="sd">            Remove missing values.</span>
<span class="sd">        data_columns : list of columns or True, optional</span>
<span class="sd">            List of columns to create as indexed data columns for on-disk</span>
<span class="sd">            queries, or True to use all columns. By default only the axes</span>
<span class="sd">            of the object are indexed. See</span>
<span class="sd">            :ref:`Query via data columns&lt;io.hdf5-query-data-columns&gt;`. for</span>
<span class="sd">            more information.</span>
<span class="sd">            Applicable only to format=&#39;table&#39;.</span>
<span class="sd">        errors : str, default &#39;strict&#39;</span>
<span class="sd">            Specifies how encoding and decoding errors are to be handled.</span>
<span class="sd">            See the errors argument for :func:`open` for a full list</span>
<span class="sd">            of options.</span>
<span class="sd">        encoding : str, default &quot;UTF-8&quot;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_hdf : Read from HDF file.</span>
<span class="sd">        DataFrame.to_orc : Write a DataFrame to the binary orc format.</span>
<span class="sd">        DataFrame.to_parquet : Write a DataFrame to the binary parquet format.</span>
<span class="sd">        DataFrame.to_sql : Write to a SQL table.</span>
<span class="sd">        DataFrame.to_feather : Write out feather-format for DataFrames.</span>
<span class="sd">        DataFrame.to_csv : Write out to a csv file.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3], &#39;B&#39;: [4, 5, 6]},</span>
<span class="sd">        ...                   index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; df.to_hdf(&#39;data.h5&#39;, key=&#39;df&#39;, mode=&#39;w&#39;)  # doctest: +SKIP</span>

<span class="sd">        We can add another object to the same file:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; s.to_hdf(&#39;data.h5&#39;, key=&#39;s&#39;)  # doctest: +SKIP</span>

<span class="sd">        Reading from HDF file:</span>

<span class="sd">        &gt;&gt;&gt; pd.read_hdf(&#39;data.h5&#39;, &#39;df&#39;)  # doctest: +SKIP</span>
<span class="sd">        A  B</span>
<span class="sd">        a  1  4</span>
<span class="sd">        b  2  5</span>
<span class="sd">        c  3  6</span>
<span class="sd">        &gt;&gt;&gt; pd.read_hdf(&#39;data.h5&#39;, &#39;s&#39;)  # doctest: +SKIP</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">pytables</span>

        <span class="c1"># Argument 3 to &quot;to_hdf&quot; has incompatible type &quot;NDFrame&quot;; expected</span>
        <span class="c1"># &quot;Union[DataFrame, Series]&quot; [arg-type]</span>
        <span class="n">pytables</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span>
            <span class="n">path_or_buf</span><span class="p">,</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="bp">self</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">complevel</span><span class="o">=</span><span class="n">complevel</span><span class="p">,</span>
            <span class="n">complib</span><span class="o">=</span><span class="n">complib</span><span class="p">,</span>
            <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">,</span>
            <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">min_itemsize</span><span class="o">=</span><span class="n">min_itemsize</span><span class="p">,</span>
            <span class="n">nan_rep</span><span class="o">=</span><span class="n">nan_rep</span><span class="p">,</span>
            <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">,</span>
            <span class="n">data_columns</span><span class="o">=</span><span class="n">data_columns</span><span class="p">,</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">to_sql</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">con</span><span class="p">,</span>
        <span class="n">schema</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">if_exists</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;fail&quot;</span><span class="p">,</span> <span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="s2">&quot;append&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;fail&quot;</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">index_label</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeArg</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write records stored in a DataFrame to a SQL database.</span>

<span class="sd">        Databases supported by SQLAlchemy [1]_ are supported. Tables can be</span>
<span class="sd">        newly created, appended to, or overwritten.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of SQL table.</span>
<span class="sd">        con : sqlalchemy.engine.(Engine or Connection) or sqlite3.Connection</span>
<span class="sd">            Using SQLAlchemy makes it possible to use any DB supported by that</span>
<span class="sd">            library. Legacy support is provided for sqlite3.Connection objects. The user</span>
<span class="sd">            is responsible for engine disposal and connection closure for the SQLAlchemy</span>
<span class="sd">            connectable. See `here \</span>
<span class="sd">                &lt;https://docs.sqlalchemy.org/en/20/core/connections.html&gt;`_.</span>
<span class="sd">            If passing a sqlalchemy.engine.Connection which is already in a transaction,</span>
<span class="sd">            the transaction will not be committed.  If passing a sqlite3.Connection,</span>
<span class="sd">            it will not be possible to roll back the record insertion.</span>

<span class="sd">        schema : str, optional</span>
<span class="sd">            Specify the schema (if database flavor supports this). If None, use</span>
<span class="sd">            default schema.</span>
<span class="sd">        if_exists : {&#39;fail&#39;, &#39;replace&#39;, &#39;append&#39;}, default &#39;fail&#39;</span>
<span class="sd">            How to behave if the table already exists.</span>

<span class="sd">            * fail: Raise a ValueError.</span>
<span class="sd">            * replace: Drop the table before inserting new values.</span>
<span class="sd">            * append: Insert new values to the existing table.</span>

<span class="sd">        index : bool, default True</span>
<span class="sd">            Write DataFrame index as a column. Uses `index_label` as the column</span>
<span class="sd">            name in the table.</span>
<span class="sd">        index_label : str or sequence, default None</span>
<span class="sd">            Column label for index column(s). If None is given (default) and</span>
<span class="sd">            `index` is True, then the index names are used.</span>
<span class="sd">            A sequence should be given if the DataFrame uses MultiIndex.</span>
<span class="sd">        chunksize : int, optional</span>
<span class="sd">            Specify the number of rows in each batch to be written at a time.</span>
<span class="sd">            By default, all rows will be written at once.</span>
<span class="sd">        dtype : dict or scalar, optional</span>
<span class="sd">            Specifying the datatype for columns. If a dictionary is used, the</span>
<span class="sd">            keys should be the column names and the values should be the</span>
<span class="sd">            SQLAlchemy types or strings for the sqlite3 legacy mode. If a</span>
<span class="sd">            scalar is provided, it will be applied to all columns.</span>
<span class="sd">        method : {None, &#39;multi&#39;, callable}, optional</span>
<span class="sd">            Controls the SQL insertion clause used:</span>

<span class="sd">            * None : Uses standard SQL ``INSERT`` clause (one per row).</span>
<span class="sd">            * &#39;multi&#39;: Pass multiple values in a single ``INSERT`` clause.</span>
<span class="sd">            * callable with signature ``(pd_table, conn, keys, data_iter)``.</span>

<span class="sd">            Details and a sample callable implementation can be found in the</span>
<span class="sd">            section :ref:`insert method &lt;io.sql.method&gt;`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or int</span>
<span class="sd">            Number of rows affected by to_sql. None is returned if the callable</span>
<span class="sd">            passed into ``method`` does not return an integer number of rows.</span>

<span class="sd">            The number of returned rows affected is the sum of the ``rowcount``</span>
<span class="sd">            attribute of ``sqlite3.Cursor`` or SQLAlchemy connectable which may not</span>
<span class="sd">            reflect the exact number of written rows as stipulated in the</span>
<span class="sd">            `sqlite3 &lt;https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.rowcount&gt;`__ or</span>
<span class="sd">            `SQLAlchemy &lt;https://docs.sqlalchemy.org/en/20/core/connections.html#sqlalchemy.engine.CursorResult.rowcount&gt;`__.</span>

<span class="sd">            .. versionadded:: 1.4.0</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When the table already exists and `if_exists` is &#39;fail&#39; (the</span>
<span class="sd">            default).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_sql : Read a DataFrame from a table.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Timezone aware datetime columns will be written as</span>
<span class="sd">        ``Timestamp with timezone`` type with SQLAlchemy if supported by the</span>
<span class="sd">        database. Otherwise, the datetimes will be stored as timezone unaware</span>
<span class="sd">        timestamps local to the original timezone.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://docs.sqlalchemy.org</span>
<span class="sd">        .. [2] https://www.python.org/dev/peps/pep-0249/</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create an in-memory SQLite database.</span>

<span class="sd">        &gt;&gt;&gt; from sqlalchemy import create_engine</span>
<span class="sd">        &gt;&gt;&gt; engine = create_engine(&#39;sqlite://&#39;, echo=False)</span>

<span class="sd">        Create a table from scratch with 3 rows.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;name&#39; : [&#39;User 1&#39;, &#39;User 2&#39;, &#39;User 3&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name</span>
<span class="sd">        0  User 1</span>
<span class="sd">        1  User 2</span>
<span class="sd">        2  User 3</span>

<span class="sd">        &gt;&gt;&gt; df.to_sql(&#39;users&#39;, con=engine)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; from sqlalchemy import text</span>
<span class="sd">        &gt;&gt;&gt; with engine.connect() as conn:</span>
<span class="sd">        ...    conn.execute(text(&quot;SELECT * FROM users&quot;)).fetchall()</span>
<span class="sd">        [(0, &#39;User 1&#39;), (1, &#39;User 2&#39;), (2, &#39;User 3&#39;)]</span>

<span class="sd">        An `sqlalchemy.engine.Connection` can also be passed to `con`:</span>

<span class="sd">        &gt;&gt;&gt; with engine.begin() as connection:</span>
<span class="sd">        ...     df1 = pd.DataFrame({&#39;name&#39; : [&#39;User 4&#39;, &#39;User 5&#39;]})</span>
<span class="sd">        ...     df1.to_sql(&#39;users&#39;, con=connection, if_exists=&#39;append&#39;)</span>
<span class="sd">        2</span>

<span class="sd">        This is allowed to support operations that require that the same</span>
<span class="sd">        DBAPI connection is used for the entire operation.</span>

<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;name&#39; : [&#39;User 6&#39;, &#39;User 7&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df2.to_sql(&#39;users&#39;, con=engine, if_exists=&#39;append&#39;)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; with engine.connect() as conn:</span>
<span class="sd">        ...    conn.execute(text(&quot;SELECT * FROM users&quot;)).fetchall()</span>
<span class="sd">        [(0, &#39;User 1&#39;), (1, &#39;User 2&#39;), (2, &#39;User 3&#39;),</span>
<span class="sd">         (0, &#39;User 4&#39;), (1, &#39;User 5&#39;), (0, &#39;User 6&#39;),</span>
<span class="sd">         (1, &#39;User 7&#39;)]</span>

<span class="sd">        Overwrite the table with just ``df2``.</span>

<span class="sd">        &gt;&gt;&gt; df2.to_sql(&#39;users&#39;, con=engine, if_exists=&#39;replace&#39;,</span>
<span class="sd">        ...            index_label=&#39;id&#39;)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; with engine.connect() as conn:</span>
<span class="sd">        ...    conn.execute(text(&quot;SELECT * FROM users&quot;)).fetchall()</span>
<span class="sd">        [(0, &#39;User 6&#39;), (1, &#39;User 7&#39;)]</span>

<span class="sd">        Specify the dtype (especially useful for integers with missing values).</span>
<span class="sd">        Notice that while pandas is forced to store the data as floating point,</span>
<span class="sd">        the database supports nullable integers. When fetching the data with</span>
<span class="sd">        Python, we get back integer scalars.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, None, 2]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             A</span>
<span class="sd">        0  1.0</span>
<span class="sd">        1  NaN</span>
<span class="sd">        2  2.0</span>

<span class="sd">        &gt;&gt;&gt; from sqlalchemy.types import Integer</span>
<span class="sd">        &gt;&gt;&gt; df.to_sql(&#39;integers&#39;, con=engine, index=False,</span>
<span class="sd">        ...           dtype={&quot;A&quot;: Integer()})</span>
<span class="sd">        3</span>

<span class="sd">        &gt;&gt;&gt; with engine.connect() as conn:</span>
<span class="sd">        ...   conn.execute(text(&quot;SELECT * FROM integers&quot;)).fetchall()</span>
<span class="sd">        [(1,), (None,), (2,)]</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa:E501</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">sql</span>

        <span class="k">return</span> <span class="n">sql</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">con</span><span class="p">,</span>
            <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span>
            <span class="n">if_exists</span><span class="o">=</span><span class="n">if_exists</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">storage_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;storage_options&quot;</span><span class="p">],</span>
        <span class="n">compression_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;compression_options&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="s2">&quot;path&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_pickle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span>
        <span class="n">compression</span><span class="p">:</span> <span class="n">CompressionOptions</span> <span class="o">=</span> <span class="s2">&quot;infer&quot;</span><span class="p">,</span>
        <span class="n">protocol</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pickle (serialize) object to file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str, path object, or file-like object</span>
<span class="sd">            String, path object (implementing ``os.PathLike[str]``), or file-like</span>
<span class="sd">            object implementing a binary ``write()`` function. File path where</span>
<span class="sd">            the pickled object will be stored.</span>
<span class="sd">        {compression_options}</span>
<span class="sd">        protocol : int</span>
<span class="sd">            Int which indicates which protocol should be used by the pickler,</span>
<span class="sd">            default HIGHEST_PROTOCOL (see [1]_ paragraph 12.1.2). The possible</span>
<span class="sd">            values are 0, 1, 2, 3, 4, 5. A negative value for the protocol</span>
<span class="sd">            parameter is equivalent to setting its value to HIGHEST_PROTOCOL.</span>

<span class="sd">            .. [1] https://docs.python.org/3/library/pickle.html.</span>

<span class="sd">        {storage_options}</span>

<span class="sd">            .. versionadded:: 1.2.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_pickle : Load pickled pandas object (or any object) from file.</span>
<span class="sd">        DataFrame.to_hdf : Write DataFrame to an HDF5 file.</span>
<span class="sd">        DataFrame.to_sql : Write DataFrame to a SQL database.</span>
<span class="sd">        DataFrame.to_parquet : Write a DataFrame to the binary parquet format.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; original_df = pd.DataFrame({{&quot;foo&quot;: range(5), &quot;bar&quot;: range(5, 10)}})  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; original_df  # doctest: +SKIP</span>
<span class="sd">           foo  bar</span>
<span class="sd">        0    0    5</span>
<span class="sd">        1    1    6</span>
<span class="sd">        2    2    7</span>
<span class="sd">        3    3    8</span>
<span class="sd">        4    4    9</span>
<span class="sd">        &gt;&gt;&gt; original_df.to_pickle(&quot;./dummy.pkl&quot;)  # doctest: +SKIP</span>

<span class="sd">        &gt;&gt;&gt; unpickled_df = pd.read_pickle(&quot;./dummy.pkl&quot;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; unpickled_df  # doctest: +SKIP</span>
<span class="sd">           foo  bar</span>
<span class="sd">        0    0    5</span>
<span class="sd">        1    1    6</span>
<span class="sd">        2    2    7</span>
<span class="sd">        3    3    8</span>
<span class="sd">        4    4    9</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
        <span class="kn">from</span> <span class="nn">pandas.io.pickle</span> <span class="kn">import</span> <span class="n">to_pickle</span>

        <span class="n">to_pickle</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">path</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
            <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">,</span>
            <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">to_clipboard</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">excel</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy object to the system clipboard.</span>

<span class="sd">        Write a text representation of object to the system clipboard.</span>
<span class="sd">        This can be pasted into Excel, for example.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        excel : bool, default True</span>
<span class="sd">            Produce output in a csv format for easy pasting into excel.</span>

<span class="sd">            - True, use the provided separator for csv pasting.</span>
<span class="sd">            - False, write a string representation of the object to the clipboard.</span>

<span class="sd">        sep : str, default ``&#39;\t&#39;``</span>
<span class="sd">            Field delimiter.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            These parameters will be passed to DataFrame.to_csv.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.to_csv : Write a DataFrame to a comma-separated values</span>
<span class="sd">            (csv) file.</span>
<span class="sd">        read_clipboard : Read text from clipboard and pass to read_csv.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Requirements for your platform.</span>

<span class="sd">          - Linux : `xclip`, or `xsel` (with `PyQt4` modules)</span>
<span class="sd">          - Windows : none</span>
<span class="sd">          - macOS : none</span>

<span class="sd">        This method uses the processes developed for the package `pyperclip`. A</span>
<span class="sd">        solution to render any output string format is given in the examples.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Copy the contents of a DataFrame to the clipboard.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span>

<span class="sd">        &gt;&gt;&gt; df.to_clipboard(sep=&#39;,&#39;)  # doctest: +SKIP</span>
<span class="sd">        ... # Wrote the following to the system clipboard:</span>
<span class="sd">        ... # ,A,B,C</span>
<span class="sd">        ... # 0,1,2,3</span>
<span class="sd">        ... # 1,4,5,6</span>

<span class="sd">        We can omit the index by passing the keyword `index` and setting</span>
<span class="sd">        it to false.</span>

<span class="sd">        &gt;&gt;&gt; df.to_clipboard(sep=&#39;,&#39;, index=False)  # doctest: +SKIP</span>
<span class="sd">        ... # Wrote the following to the system clipboard:</span>
<span class="sd">        ... # A,B,C</span>
<span class="sd">        ... # 1,2,3</span>
<span class="sd">        ... # 4,5,6</span>

<span class="sd">        Using the original `pyperclip` package for any string output format.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           import pyperclip</span>
<span class="sd">           html = df.style.to_html()</span>
<span class="sd">           pyperclip.copy(html)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">clipboards</span>

        <span class="n">clipboards</span><span class="o">.</span><span class="n">to_clipboard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excel</span><span class="o">=</span><span class="n">excel</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">to_xarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an xarray object from the pandas object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray or xarray.Dataset</span>
<span class="sd">            Data in the pandas structure converted to Dataset if the object is</span>
<span class="sd">            a DataFrame, or a DataArray if the object is a Series.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.to_hdf : Write DataFrame to an HDF5 file.</span>
<span class="sd">        DataFrame.to_parquet : Write a DataFrame to the binary parquet format.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See the `xarray docs &lt;https://xarray.pydata.org/en/stable/&gt;`__</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;falcon&#39;, &#39;bird&#39;, 389.0, 2),</span>
<span class="sd">        ...                    (&#39;parrot&#39;, &#39;bird&#39;, 24.0, 2),</span>
<span class="sd">        ...                    (&#39;lion&#39;, &#39;mammal&#39;, 80.5, 4),</span>
<span class="sd">        ...                    (&#39;monkey&#39;, &#39;mammal&#39;, np.nan, 4)],</span>
<span class="sd">        ...                   columns=[&#39;name&#39;, &#39;class&#39;, &#39;max_speed&#39;,</span>
<span class="sd">        ...                            &#39;num_legs&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name   class  max_speed  num_legs</span>
<span class="sd">        0  falcon    bird      389.0         2</span>
<span class="sd">        1  parrot    bird       24.0         2</span>
<span class="sd">        2    lion  mammal       80.5         4</span>
<span class="sd">        3  monkey  mammal        NaN         4</span>

<span class="sd">        &gt;&gt;&gt; df.to_xarray()</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:    (index: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * index      (index) int64 0 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            name       (index) object &#39;falcon&#39; &#39;parrot&#39; &#39;lion&#39; &#39;monkey&#39;</span>
<span class="sd">            class      (index) object &#39;bird&#39; &#39;bird&#39; &#39;mammal&#39; &#39;mammal&#39;</span>
<span class="sd">            max_speed  (index) float64 389.0 24.0 80.5 nan</span>
<span class="sd">            num_legs   (index) int64 2 2 4 4</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;max_speed&#39;].to_xarray()</span>
<span class="sd">        &lt;xarray.DataArray &#39;max_speed&#39; (index: 4)&gt;</span>
<span class="sd">        array([389. ,  24. ,  80.5,   nan])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * index    (index) int64 0 1 2 3</span>

<span class="sd">        &gt;&gt;&gt; dates = pd.to_datetime([&#39;2018-01-01&#39;, &#39;2018-01-01&#39;,</span>
<span class="sd">        ...                         &#39;2018-01-02&#39;, &#39;2018-01-02&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df_multiindex = pd.DataFrame({&#39;date&#39;: dates,</span>
<span class="sd">        ...                               &#39;animal&#39;: [&#39;falcon&#39;, &#39;parrot&#39;,</span>
<span class="sd">        ...                                          &#39;falcon&#39;, &#39;parrot&#39;],</span>
<span class="sd">        ...                               &#39;speed&#39;: [350, 18, 361, 15]})</span>
<span class="sd">        &gt;&gt;&gt; df_multiindex = df_multiindex.set_index([&#39;date&#39;, &#39;animal&#39;])</span>

<span class="sd">        &gt;&gt;&gt; df_multiindex</span>
<span class="sd">                           speed</span>
<span class="sd">        date       animal</span>
<span class="sd">        2018-01-01 falcon    350</span>
<span class="sd">                   parrot     18</span>
<span class="sd">        2018-01-02 falcon    361</span>
<span class="sd">                   parrot     15</span>

<span class="sd">        &gt;&gt;&gt; df_multiindex.to_xarray()</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (date: 2, animal: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * date     (date) datetime64[ns] 2018-01-01 2018-01-02</span>
<span class="sd">          * animal   (animal) object &#39;falcon&#39; &#39;parrot&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            speed    (date, animal) int64 350 18 361 15</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xarray</span> <span class="o">=</span> <span class="n">import_optional_dependency</span><span class="p">(</span><span class="s2">&quot;xarray&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">from_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xarray</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_latex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">formatters</span><span class="p">:</span> <span class="n">FormattersType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="n">FloatFormatType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index_names</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">bold_rows</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">column_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">longtable</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">escape</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">multicolumn</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">multicolumn_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">multirow</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">caption</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_latex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">formatters</span><span class="p">:</span> <span class="n">FormattersType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="n">FloatFormatType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index_names</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">bold_rows</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">column_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">longtable</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">escape</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">multicolumn</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">multicolumn_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">multirow</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">caption</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">to_latex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NaN&quot;</span><span class="p">,</span>
        <span class="n">formatters</span><span class="p">:</span> <span class="n">FormattersType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="n">FloatFormatType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">index_names</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">bold_rows</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">column_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">longtable</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">escape</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="n">multicolumn</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">multicolumn_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">multirow</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">caption</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render object to a LaTeX tabular, longtable, or nested table.</span>

<span class="sd">        Requires ``\usepackage{{booktabs}}``.  The output can be copy/pasted</span>
<span class="sd">        into a main LaTeX document or read from an external file</span>
<span class="sd">        with ``\input{{table.tex}}``.</span>

<span class="sd">        .. versionchanged:: 1.2.0</span>
<span class="sd">           Added position argument, changed meaning of caption argument.</span>

<span class="sd">        .. versionchanged:: 2.0.0</span>
<span class="sd">           Refactored to use the Styler implementation via jinja2 templating.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        buf : str, Path or StringIO-like, optional, default None</span>
<span class="sd">            Buffer to write to. If None, the output is returned as a string.</span>
<span class="sd">        columns : list of label, optional</span>
<span class="sd">            The subset of columns to write. Writes all columns by default.</span>
<span class="sd">        header : bool or list of str, default True</span>
<span class="sd">            Write out the column names. If a list of strings is given,</span>
<span class="sd">            it is assumed to be aliases for the column names.</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Write row names (index).</span>
<span class="sd">        na_rep : str, default &#39;NaN&#39;</span>
<span class="sd">            Missing data representation.</span>
<span class="sd">        formatters : list of functions or dict of {{str: function}}, optional</span>
<span class="sd">            Formatter functions to apply to columns&#39; elements by position or</span>
<span class="sd">            name. The result of each function must be a unicode string.</span>
<span class="sd">            List must be of length equal to the number of columns.</span>
<span class="sd">        float_format : one-parameter function or str, optional, default None</span>
<span class="sd">            Formatter for floating point numbers. For example</span>
<span class="sd">            ``float_format=&quot;%.2f&quot;`` and ``float_format=&quot;{{:0.2f}}&quot;.format`` will</span>
<span class="sd">            both result in 0.1234 being formatted as 0.12.</span>
<span class="sd">        sparsify : bool, optional</span>
<span class="sd">            Set to False for a DataFrame with a hierarchical index to print</span>
<span class="sd">            every multiindex key at each row. By default, the value will be</span>
<span class="sd">            read from the config module.</span>
<span class="sd">        index_names : bool, default True</span>
<span class="sd">            Prints the names of the indexes.</span>
<span class="sd">        bold_rows : bool, default False</span>
<span class="sd">            Make the row labels bold in the output.</span>
<span class="sd">        column_format : str, optional</span>
<span class="sd">            The columns format as specified in `LaTeX table format</span>
<span class="sd">            &lt;https://en.wikibooks.org/wiki/LaTeX/Tables&gt;`__ e.g. &#39;rcl&#39; for 3</span>
<span class="sd">            columns. By default, &#39;l&#39; will be used for all columns except</span>
<span class="sd">            columns of numbers, which default to &#39;r&#39;.</span>
<span class="sd">        longtable : bool, optional</span>
<span class="sd">            Use a longtable environment instead of tabular. Requires</span>
<span class="sd">            adding a \usepackage{{longtable}} to your LaTeX preamble.</span>
<span class="sd">            By default, the value will be read from the pandas config</span>
<span class="sd">            module, and set to `True` if the option ``styler.latex.environment`` is</span>
<span class="sd">            `&quot;longtable&quot;`.</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">               The pandas option affecting this argument has changed.</span>
<span class="sd">        escape : bool, optional</span>
<span class="sd">            By default, the value will be read from the pandas config</span>
<span class="sd">            module and set to `True` if the option ``styler.format.escape`` is</span>
<span class="sd">            `&quot;latex&quot;`. When set to False prevents from escaping latex special</span>
<span class="sd">            characters in column names.</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">               The pandas option affecting this argument has changed, as has the</span>
<span class="sd">               default value to `False`.</span>
<span class="sd">        encoding : str, optional</span>
<span class="sd">            A string representing the encoding to use in the output file,</span>
<span class="sd">            defaults to &#39;utf-8&#39;.</span>
<span class="sd">        decimal : str, default &#39;.&#39;</span>
<span class="sd">            Character recognized as decimal separator, e.g. &#39;,&#39; in Europe.</span>
<span class="sd">        multicolumn : bool, default True</span>
<span class="sd">            Use \multicolumn to enhance MultiIndex columns.</span>
<span class="sd">            The default will be read from the config module, and is set</span>
<span class="sd">            as the option ``styler.sparse.columns``.</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">               The pandas option affecting this argument has changed.</span>
<span class="sd">        multicolumn_format : str, default &#39;r&#39;</span>
<span class="sd">            The alignment for multicolumns, similar to `column_format`</span>
<span class="sd">            The default will be read from the config module, and is set as the option</span>
<span class="sd">            ``styler.latex.multicol_align``.</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">               The pandas option affecting this argument has changed, as has the</span>
<span class="sd">               default value to &quot;r&quot;.</span>
<span class="sd">        multirow : bool, default True</span>
<span class="sd">            Use \multirow to enhance MultiIndex rows. Requires adding a</span>
<span class="sd">            \usepackage{{multirow}} to your LaTeX preamble. Will print</span>
<span class="sd">            centered labels (instead of top-aligned) across the contained</span>
<span class="sd">            rows, separating groups via clines. The default will be read</span>
<span class="sd">            from the pandas config module, and is set as the option</span>
<span class="sd">            ``styler.sparse.index``.</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">               The pandas option affecting this argument has changed, as has the</span>
<span class="sd">               default value to `True`.</span>
<span class="sd">        caption : str or tuple, optional</span>
<span class="sd">            Tuple (full_caption, short_caption),</span>
<span class="sd">            which results in ``\caption[short_caption]{{full_caption}}``;</span>
<span class="sd">            if a single string is passed, no short caption will be set.</span>

<span class="sd">            .. versionchanged:: 1.2.0</span>
<span class="sd">               Optionally allow caption to be a tuple ``(full_caption, short_caption)``.</span>

<span class="sd">        label : str, optional</span>
<span class="sd">            The LaTeX label to be placed inside ``\label{{}}`` in the output.</span>
<span class="sd">            This is used with ``\ref{{}}`` in the main ``.tex`` file.</span>

<span class="sd">        position : str, optional</span>
<span class="sd">            The LaTeX positional argument for tables, to be placed after</span>
<span class="sd">            ``\begin{{}}`` in the output.</span>

<span class="sd">            .. versionadded:: 1.2.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or None</span>
<span class="sd">            If buf is None, returns the result as a string. Otherwise returns None.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        io.formats.style.Styler.to_latex : Render a DataFrame to LaTeX</span>
<span class="sd">            with conditional formatting.</span>
<span class="sd">        DataFrame.to_string : Render a DataFrame to a console-friendly</span>
<span class="sd">            tabular output.</span>
<span class="sd">        DataFrame.to_html : Render a DataFrame as an HTML table.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As of v2.0.0 this method has changed to use the Styler implementation as</span>
<span class="sd">        part of :meth:`.Styler.to_latex` via ``jinja2`` templating. This means</span>
<span class="sd">        that ``jinja2`` is a requirement, and needs to be installed, for this method</span>
<span class="sd">        to function. It is advised that users switch to using Styler, since that</span>
<span class="sd">        implementation is more frequently updated and contains much more</span>
<span class="sd">        flexibility with the output.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a general DataFrame to LaTeX with formatting:</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(dict(name=[&#39;Raphael&#39;, &#39;Donatello&#39;],</span>
<span class="sd">        ...                        age=[26, 45],</span>
<span class="sd">        ...                        height=[181.23, 177.65]))</span>
<span class="sd">        &gt;&gt;&gt; print(df.to_latex(index=False,</span>
<span class="sd">        ...                   formatters={&quot;name&quot;: str.upper},</span>
<span class="sd">        ...                   float_format=&quot;{:.1f}&quot;.format,</span>
<span class="sd">        ... ))  # doctest: +SKIP</span>
<span class="sd">        \begin{tabular}{lrr}</span>
<span class="sd">        \toprule</span>
<span class="sd">        name &amp; age &amp; height \\</span>
<span class="sd">        \midrule</span>
<span class="sd">        RAPHAEL &amp; 26 &amp; 181.2 \\</span>
<span class="sd">        DONATELLO &amp; 45 &amp; 177.7 \\</span>
<span class="sd">        \bottomrule</span>
<span class="sd">        \end{tabular}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get defaults from the pandas config</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">longtable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">longtable</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;styler.latex.environment&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;longtable&quot;</span>
        <span class="k">if</span> <span class="n">escape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">escape</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;styler.format.escape&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;latex&quot;</span>
        <span class="k">if</span> <span class="n">multicolumn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multicolumn</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;styler.sparse.columns&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multicolumn_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multicolumn_format</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;styler.latex.multicol_align&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multirow</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multirow</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;styler.sparse.index&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">column_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_format</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`column_format` must be str or unicode&quot;</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">!=</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Writing </span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s2"> cols but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span><span class="si">}</span><span class="s2"> aliases&quot;</span><span class="p">)</span>

        <span class="c1"># Refactor formatters/float_format/decimal/na_rep/escape to Styler structure</span>
        <span class="n">base_format_</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;na_rep&quot;</span><span class="p">:</span> <span class="n">na_rep</span><span class="p">,</span>
            <span class="s2">&quot;escape&quot;</span><span class="p">:</span> <span class="s2">&quot;latex&quot;</span> <span class="k">if</span> <span class="n">escape</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;decimal&quot;</span><span class="p">:</span> <span class="n">decimal</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">index_format_</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">base_format_</span><span class="p">}</span>
        <span class="n">column_format_</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">base_format_</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">float_format</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">float_format_</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">float_format</span> <span class="o">%</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">float_format_</span> <span class="o">=</span> <span class="n">float_format</span>

        <span class="k">def</span> <span class="nf">_wrap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alt_format_</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">))</span> <span class="ow">and</span> <span class="n">float_format_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">float_format_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">alt_format_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">formatters_</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formatters</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">formatters_</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">c</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">_wrap</span><span class="p">,</span> <span class="n">alt_format_</span><span class="o">=</span><span class="n">formatters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formatters</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">index_formatter</span> <span class="o">=</span> <span class="n">formatters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;__index__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">column_formatter</span> <span class="o">=</span> <span class="n">formatters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;__columns__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index_formatter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index_format_</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;formatter&quot;</span><span class="p">:</span> <span class="n">index_formatter</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">column_formatter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">column_format_</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;formatter&quot;</span><span class="p">:</span> <span class="n">column_formatter</span><span class="p">})</span>

            <span class="n">formatters_</span> <span class="o">=</span> <span class="n">formatters</span>
            <span class="n">float_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">float_columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">formatters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">formatters_</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">col</span><span class="p">:</span> <span class="n">float_format_</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">formatters</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">float_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">formatters_</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_wrap</span><span class="p">,</span> <span class="n">alt_format_</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">format_index_</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_format_</span><span class="p">,</span> <span class="n">column_format_</span><span class="p">]</span>

        <span class="c1"># Deal with hiding indexes and relabelling column names</span>
        <span class="n">hide_</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">relabel_index_</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">hide_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;subset&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">],</span>
                    <span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="s2">&quot;columns&quot;</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">hide_</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="s2">&quot;columns&quot;</span><span class="p">})</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">relabel_index_</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;labels&quot;</span><span class="p">:</span> <span class="n">header</span><span class="p">,</span> <span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="s2">&quot;columns&quot;</span><span class="p">})</span>
            <span class="n">format_index_</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_format_</span><span class="p">]</span>  <span class="c1"># column_format is overwritten</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">hide_</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="s2">&quot;index&quot;</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">index_names</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">hide_</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;names&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="s2">&quot;index&quot;</span><span class="p">})</span>

        <span class="n">render_kwargs_</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;hrules&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;sparse_index&quot;</span><span class="p">:</span> <span class="n">sparsify</span><span class="p">,</span>
            <span class="s2">&quot;sparse_columns&quot;</span><span class="p">:</span> <span class="n">sparsify</span><span class="p">,</span>
            <span class="s2">&quot;environment&quot;</span><span class="p">:</span> <span class="s2">&quot;longtable&quot;</span> <span class="k">if</span> <span class="n">longtable</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;multicol_align&quot;</span><span class="p">:</span> <span class="n">multicolumn_format</span>
            <span class="k">if</span> <span class="n">multicolumn</span>
            <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;naive-</span><span class="si">{</span><span class="n">multicolumn_format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;multirow_align&quot;</span><span class="p">:</span> <span class="s2">&quot;t&quot;</span> <span class="k">if</span> <span class="n">multirow</span> <span class="k">else</span> <span class="s2">&quot;naive&quot;</span><span class="p">,</span>
            <span class="s2">&quot;encoding&quot;</span><span class="p">:</span> <span class="n">encoding</span><span class="p">,</span>
            <span class="s2">&quot;caption&quot;</span><span class="p">:</span> <span class="n">caption</span><span class="p">,</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">label</span><span class="p">,</span>
            <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="n">position</span><span class="p">,</span>
            <span class="s2">&quot;column_format&quot;</span><span class="p">:</span> <span class="n">column_format</span><span class="p">,</span>
            <span class="s2">&quot;clines&quot;</span><span class="p">:</span> <span class="s2">&quot;skip-last;data&quot;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">multirow</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">))</span>
            <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;bold_rows&quot;</span><span class="p">:</span> <span class="n">bold_rows</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_latex_via_styler</span><span class="p">(</span>
            <span class="n">buf</span><span class="p">,</span>
            <span class="n">hide</span><span class="o">=</span><span class="n">hide_</span><span class="p">,</span>
            <span class="n">relabel_index</span><span class="o">=</span><span class="n">relabel_index_</span><span class="p">,</span>
            <span class="nb">format</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;formatter&quot;</span><span class="p">:</span> <span class="n">formatters_</span><span class="p">,</span> <span class="o">**</span><span class="n">base_format_</span><span class="p">},</span>
            <span class="n">format_index</span><span class="o">=</span><span class="n">format_index_</span><span class="p">,</span>
            <span class="n">render_kwargs</span><span class="o">=</span><span class="n">render_kwargs_</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_latex_via_styler</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">hide</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">relabel_index</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">format_index</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">render_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render object to a LaTeX tabular, longtable, or nested table.</span>

<span class="sd">        Uses the ``Styler`` implementation with the following, ordered, method chaining:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">           styler = Styler(DataFrame)</span>
<span class="sd">           styler.hide(**hide)</span>
<span class="sd">           styler.relabel_index(**relabel_index)</span>
<span class="sd">           styler.format(**format)</span>
<span class="sd">           styler.format_index(**format_index)</span>
<span class="sd">           styler.to_latex(buf=buf, **render_kwargs)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        buf : str, Path or StringIO-like, optional, default None</span>
<span class="sd">            Buffer to write to. If None, the output is returned as a string.</span>
<span class="sd">        hide : dict, list of dict</span>
<span class="sd">            Keyword args to pass to the method call of ``Styler.hide``. If a list will</span>
<span class="sd">            call the method numerous times.</span>
<span class="sd">        relabel_index : dict, list of dict</span>
<span class="sd">            Keyword args to pass to the method of ``Styler.relabel_index``. If a list</span>
<span class="sd">            will call the method numerous times.</span>
<span class="sd">        format : dict, list of dict</span>
<span class="sd">            Keyword args to pass to the method call of ``Styler.format``. If a list will</span>
<span class="sd">            call the method numerous times.</span>
<span class="sd">        format_index : dict, list of dict</span>
<span class="sd">            Keyword args to pass to the method call of ``Styler.format_index``. If a</span>
<span class="sd">            list will call the method numerous times.</span>
<span class="sd">        render_kwargs : dict</span>
<span class="sd">            Keyword args to pass to the method call of ``Styler.to_latex``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or None</span>
<span class="sd">            If buf is None, returns the result as a string. Otherwise returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.style</span> <span class="kn">import</span> <span class="n">Styler</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">styler</span> <span class="o">=</span> <span class="n">Styler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uuid</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">kw_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;hide&quot;</span><span class="p">,</span> <span class="s2">&quot;relabel_index&quot;</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;format_index&quot;</span><span class="p">]:</span>
            <span class="n">kw</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">()[</span><span class="n">kw_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">styler</span><span class="p">,</span> <span class="n">kw_name</span><span class="p">)(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">sub_kw</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">styler</span><span class="p">,</span> <span class="n">kw_name</span><span class="p">)(</span><span class="o">**</span><span class="n">sub_kw</span><span class="p">)</span>

        <span class="c1"># bold_rows is not a direct kwarg of Styler.to_latex</span>
        <span class="n">render_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">render_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">render_kwargs</span>
        <span class="k">if</span> <span class="n">render_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bold_rows&quot;</span><span class="p">):</span>
            <span class="n">styler</span><span class="o">.</span><span class="n">applymap_index</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;textbf:--rwrap;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">styler</span><span class="o">.</span><span class="n">to_latex</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span> <span class="o">**</span><span class="n">render_kwargs</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path_or_buf</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index_label</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="n">CompressionOptions</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">quoting</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">quotechar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">lineterminator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">date_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">doublequote</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">escapechar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path_or_buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index_label</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="n">CompressionOptions</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">quoting</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">quotechar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">lineterminator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">date_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">doublequote</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">escapechar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">storage_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;storage_options&quot;</span><span class="p">],</span>
        <span class="n">compression_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;compression_options&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="s2">&quot;path_or_buf&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path_or_buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">index_label</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="n">CompressionOptions</span> <span class="o">=</span> <span class="s2">&quot;infer&quot;</span><span class="p">,</span>
        <span class="n">quoting</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">quotechar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">lineterminator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">date_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">doublequote</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">escapechar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;strict&quot;</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write object to a comma-separated values (csv) file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : str, path object, file-like object, or None, default None</span>
<span class="sd">            String, path object (implementing os.PathLike[str]), or file-like</span>
<span class="sd">            object implementing a write() function. If None, the result is</span>
<span class="sd">            returned as a string. If a non-binary file object is passed, it should</span>
<span class="sd">            be opened with `newline=&#39;&#39;`, disabling universal newlines. If a binary</span>
<span class="sd">            file object is passed, `mode` might need to contain a `&#39;b&#39;`.</span>

<span class="sd">            .. versionchanged:: 1.2.0</span>

<span class="sd">               Support for binary file objects was introduced.</span>

<span class="sd">        sep : str, default &#39;,&#39;</span>
<span class="sd">            String of length 1. Field delimiter for the output file.</span>
<span class="sd">        na_rep : str, default &#39;&#39;</span>
<span class="sd">            Missing data representation.</span>
<span class="sd">        float_format : str, Callable, default None</span>
<span class="sd">            Format string for floating point numbers. If a Callable is given, it takes</span>
<span class="sd">            precedence over other numeric formatting parameters, like decimal.</span>
<span class="sd">        columns : sequence, optional</span>
<span class="sd">            Columns to write.</span>
<span class="sd">        header : bool or list of str, default True</span>
<span class="sd">            Write out the column names. If a list of strings is given it is</span>
<span class="sd">            assumed to be aliases for the column names.</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Write row names (index).</span>
<span class="sd">        index_label : str or sequence, or False, default None</span>
<span class="sd">            Column label for index column(s) if desired. If None is given, and</span>
<span class="sd">            `header` and `index` are True, then the index names are used. A</span>
<span class="sd">            sequence should be given if the object uses MultiIndex. If</span>
<span class="sd">            False do not print fields for index names. Use index_label=False</span>
<span class="sd">            for easier importing in R.</span>
<span class="sd">        mode : str, default &#39;w&#39;</span>
<span class="sd">            Python write mode. The available write modes are the same as</span>
<span class="sd">            :py:func:`open`.</span>
<span class="sd">        encoding : str, optional</span>
<span class="sd">            A string representing the encoding to use in the output file,</span>
<span class="sd">            defaults to &#39;utf-8&#39;. `encoding` is not supported if `path_or_buf`</span>
<span class="sd">            is a non-binary file object.</span>
<span class="sd">        {compression_options}</span>

<span class="sd">            .. versionchanged:: 1.0.0</span>

<span class="sd">               May now be a dict with key &#39;method&#39; as compression mode</span>
<span class="sd">               and other entries as additional compression options if</span>
<span class="sd">               compression mode is &#39;zip&#39;.</span>

<span class="sd">            .. versionchanged:: 1.1.0</span>

<span class="sd">               Passing compression options as keys in dict is</span>
<span class="sd">               supported for compression modes &#39;gzip&#39;, &#39;bz2&#39;, &#39;zstd&#39;, and &#39;zip&#39;.</span>

<span class="sd">            .. versionchanged:: 1.2.0</span>

<span class="sd">                Compression is supported for binary file objects.</span>

<span class="sd">            .. versionchanged:: 1.2.0</span>

<span class="sd">                Previous versions forwarded dict entries for &#39;gzip&#39; to</span>
<span class="sd">                `gzip.open` instead of `gzip.GzipFile` which prevented</span>
<span class="sd">                setting `mtime`.</span>

<span class="sd">        quoting : optional constant from csv module</span>
<span class="sd">            Defaults to csv.QUOTE_MINIMAL. If you have set a `float_format`</span>
<span class="sd">            then floats are converted to strings and thus csv.QUOTE_NONNUMERIC</span>
<span class="sd">            will treat them as non-numeric.</span>
<span class="sd">        quotechar : str, default &#39;\&quot;&#39;</span>
<span class="sd">            String of length 1. Character used to quote fields.</span>
<span class="sd">        lineterminator : str, optional</span>
<span class="sd">            The newline character or character sequence to use in the output</span>
<span class="sd">            file. Defaults to `os.linesep`, which depends on the OS in which</span>
<span class="sd">            this method is called (&#39;\\n&#39; for linux, &#39;\\r\\n&#39; for Windows, i.e.).</span>

<span class="sd">            .. versionchanged:: 1.5.0</span>

<span class="sd">                Previously was line_terminator, changed for consistency with</span>
<span class="sd">                read_csv and the standard library &#39;csv&#39; module.</span>

<span class="sd">        chunksize : int or None</span>
<span class="sd">            Rows to write at a time.</span>
<span class="sd">        date_format : str, default None</span>
<span class="sd">            Format string for datetime objects.</span>
<span class="sd">        doublequote : bool, default True</span>
<span class="sd">            Control quoting of `quotechar` inside a field.</span>
<span class="sd">        escapechar : str, default None</span>
<span class="sd">            String of length 1. Character used to escape `sep` and `quotechar`</span>
<span class="sd">            when appropriate.</span>
<span class="sd">        decimal : str, default &#39;.&#39;</span>
<span class="sd">            Character recognized as decimal separator. E.g. use &#39;,&#39; for</span>
<span class="sd">            European data.</span>
<span class="sd">        errors : str, default &#39;strict&#39;</span>
<span class="sd">            Specifies how encoding and decoding errors are to be handled.</span>
<span class="sd">            See the errors argument for :func:`open` for a full list</span>
<span class="sd">            of options.</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">        {storage_options}</span>

<span class="sd">            .. versionadded:: 1.2.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or str</span>
<span class="sd">            If path_or_buf is None, returns the resulting csv format as a</span>
<span class="sd">            string. Otherwise returns None.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_csv : Load a CSV file into a DataFrame.</span>
<span class="sd">        to_excel : Write DataFrame to an Excel file.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({{&#39;name&#39;: [&#39;Raphael&#39;, &#39;Donatello&#39;],</span>
<span class="sd">        ...                    &#39;mask&#39;: [&#39;red&#39;, &#39;purple&#39;],</span>
<span class="sd">        ...                    &#39;weapon&#39;: [&#39;sai&#39;, &#39;bo staff&#39;]}})</span>
<span class="sd">        &gt;&gt;&gt; df.to_csv(index=False)</span>
<span class="sd">        &#39;name,mask,weapon\nRaphael,red,sai\nDonatello,purple,bo staff\n&#39;</span>

<span class="sd">        Create &#39;out.zip&#39; containing &#39;out.csv&#39;</span>

<span class="sd">        &gt;&gt;&gt; compression_opts = dict(method=&#39;zip&#39;,</span>
<span class="sd">        ...                         archive_name=&#39;out.csv&#39;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; df.to_csv(&#39;out.zip&#39;, index=False,</span>
<span class="sd">        ...           compression=compression_opts)  # doctest: +SKIP</span>

<span class="sd">        To write a csv file to a new folder or nested folder you will first</span>
<span class="sd">        need to create it using either Pathlib or os:</span>

<span class="sd">        &gt;&gt;&gt; from pathlib import Path  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; filepath = Path(&#39;folder/subfolder/out.csv&#39;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; filepath.parent.mkdir(parents=True, exist_ok=True)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; df.to_csv(filepath)  # doctest: +SKIP</span>

<span class="sd">        &gt;&gt;&gt; import os  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; os.makedirs(&#39;folder/subfolder&#39;, exist_ok=True)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; df.to_csv(&#39;folder/subfolder/out.csv&#39;)  # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">DataFrameFormatter</span><span class="p">(</span>
            <span class="n">frame</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
            <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
            <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrameRenderer</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
            <span class="n">path_or_buf</span><span class="p">,</span>
            <span class="n">lineterminator</span><span class="o">=</span><span class="n">lineterminator</span><span class="p">,</span>
            <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
            <span class="n">quoting</span><span class="o">=</span><span class="n">quoting</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">quotechar</span><span class="o">=</span><span class="n">quotechar</span><span class="p">,</span>
            <span class="n">date_format</span><span class="o">=</span><span class="n">date_format</span><span class="p">,</span>
            <span class="n">doublequote</span><span class="o">=</span><span class="n">doublequote</span><span class="p">,</span>
            <span class="n">escapechar</span><span class="o">=</span><span class="n">escapechar</span><span class="p">,</span>
            <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Lookup Caching</span>

    <span class="k">def</span> <span class="nf">_reset_cacher</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the cacher.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maybe_update_cacher</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">clear</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verify_is_copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See if we need to update our parent cacher if clear, then clear our</span>
<span class="sd">        cache.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clear : bool, default False</span>
<span class="sd">            Clear the item cache.</span>
<span class="sd">        verify_is_copy : bool, default True</span>
<span class="sd">            Provide is_copy checks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">verify_is_copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="s2">&quot;referent&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_clear_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Indexing Methods</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the elements in the given *positional* indices along an axis.</span>

<span class="sd">        This means that we are not indexing according to actual values in</span>
<span class="sd">        the index attribute of the object. We are indexing according to the</span>
<span class="sd">        actual position of the element in the object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : array-like</span>
<span class="sd">            An array of ints indicating which positions to take.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default 0</span>
<span class="sd">            The axis on which to select elements. ``0`` means that we are</span>
<span class="sd">            selecting rows, ``1`` means that we are selecting columns.</span>
<span class="sd">            For `Series` this parameter is unused and defaults to 0.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            For compatibility with :meth:`numpy.take`. Has no effect on the</span>
<span class="sd">            output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as caller</span>
<span class="sd">            An array-like containing the elements taken from the object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.loc : Select a subset of a DataFrame by labels.</span>
<span class="sd">        DataFrame.iloc : Select a subset of a DataFrame by positions.</span>
<span class="sd">        numpy.take : Take elements from an array along an axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;falcon&#39;, &#39;bird&#39;, 389.0),</span>
<span class="sd">        ...                    (&#39;parrot&#39;, &#39;bird&#39;, 24.0),</span>
<span class="sd">        ...                    (&#39;lion&#39;, &#39;mammal&#39;, 80.5),</span>
<span class="sd">        ...                    (&#39;monkey&#39;, &#39;mammal&#39;, np.nan)],</span>
<span class="sd">        ...                   columns=[&#39;name&#39;, &#39;class&#39;, &#39;max_speed&#39;],</span>
<span class="sd">        ...                   index=[0, 2, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        0  falcon    bird      389.0</span>
<span class="sd">        2  parrot    bird       24.0</span>
<span class="sd">        3    lion  mammal       80.5</span>
<span class="sd">        1  monkey  mammal        NaN</span>

<span class="sd">        Take elements at positions 0 and 3 along the axis 0 (default).</span>

<span class="sd">        Note how the actual indices selected (0 and 1) do not correspond to</span>
<span class="sd">        our selected indices 0 and 3. That&#39;s because we are selecting the 0th</span>
<span class="sd">        and 3rd rows, not rows whose indices equal 0 and 3.</span>

<span class="sd">        &gt;&gt;&gt; df.take([0, 3])</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        0  falcon    bird      389.0</span>
<span class="sd">        1  monkey  mammal        NaN</span>

<span class="sd">        Take elements at indices 1 and 2 along the axis 1 (column selection).</span>

<span class="sd">        &gt;&gt;&gt; df.take([1, 2], axis=1)</span>
<span class="sd">            class  max_speed</span>
<span class="sd">        0    bird      389.0</span>
<span class="sd">        2    bird       24.0</span>
<span class="sd">        3  mammal       80.5</span>
<span class="sd">        1  mammal        NaN</span>

<span class="sd">        We may take elements using negative integers for positive indices,</span>
<span class="sd">        starting from the end of the object, just like with Python lists.</span>

<span class="sd">        &gt;&gt;&gt; df.take([-1, -2])</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        1  monkey  mammal        NaN</span>
<span class="sd">        3    lion  mammal       80.5</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nv</span><span class="o">.</span><span class="n">validate_take</span><span class="p">((),</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">convert_indices</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal version of the `take` allowing specification of additional args.</span>

<span class="sd">        See the docstring of `take` for full explanation of the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="n">using_copy_on_write</span><span class="p">()</span>
                <span class="ow">and</span> <span class="n">is_range_indexer</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span>
            <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">convert_indices</span><span class="o">=</span><span class="n">convert_indices</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;take&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_take_with_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal version of the `take` method that sets the `_is_copy`</span>
<span class="sd">        attribute to keep track of the parent dataframe (using in indexing</span>
<span class="sd">        for the SettingWithCopyWarning).</span>

<span class="sd">        See the docstring of `take` for full explanation of the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="c1"># Maybe set copy if we didn&#39;t actually change the index.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">xs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">IndexLabel</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop_level</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return cross-section from the Series/DataFrame.</span>

<span class="sd">        This method takes a `key` argument to select data at a particular</span>
<span class="sd">        level of a MultiIndex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : label or tuple of label</span>
<span class="sd">            Label contained in the index, or partially in a MultiIndex.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Axis to retrieve cross-section on.</span>
<span class="sd">        level : object, defaults to first n levels (n=1 or len(key))</span>
<span class="sd">            In case of a key partially contained in a MultiIndex, indicate</span>
<span class="sd">            which levels are used. Levels can be referred by label or position.</span>
<span class="sd">        drop_level : bool, default True</span>
<span class="sd">            If False, returns object with same levels as self.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Cross-section from the original Series or DataFrame</span>
<span class="sd">            corresponding to the selected index levels.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.loc : Access a group of rows and columns</span>
<span class="sd">            by label(s) or a boolean array.</span>
<span class="sd">        DataFrame.iloc : Purely integer-location based indexing</span>
<span class="sd">            for selection by position.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        `xs` can not be used to set values.</span>

<span class="sd">        MultiIndex Slicers is a generic way to get/set values on</span>
<span class="sd">        any level or levels.</span>
<span class="sd">        It is a superset of `xs` functionality, see</span>
<span class="sd">        :ref:`MultiIndex Slicers &lt;advanced.mi_slicers&gt;`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;num_legs&#39;: [4, 4, 2, 2],</span>
<span class="sd">        ...      &#39;num_wings&#39;: [0, 0, 2, 2],</span>
<span class="sd">        ...      &#39;class&#39;: [&#39;mammal&#39;, &#39;mammal&#39;, &#39;mammal&#39;, &#39;bird&#39;],</span>
<span class="sd">        ...      &#39;animal&#39;: [&#39;cat&#39;, &#39;dog&#39;, &#39;bat&#39;, &#39;penguin&#39;],</span>
<span class="sd">        ...      &#39;locomotion&#39;: [&#39;walks&#39;, &#39;walks&#39;, &#39;flies&#39;, &#39;walks&#39;]}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data=d)</span>
<span class="sd">        &gt;&gt;&gt; df = df.set_index([&#39;class&#39;, &#39;animal&#39;, &#39;locomotion&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                                   num_legs  num_wings</span>
<span class="sd">        class  animal  locomotion</span>
<span class="sd">        mammal cat     walks              4          0</span>
<span class="sd">               dog     walks              4          0</span>
<span class="sd">               bat     flies              2          2</span>
<span class="sd">        bird   penguin walks              2          2</span>

<span class="sd">        Get values at specified index</span>

<span class="sd">        &gt;&gt;&gt; df.xs(&#39;mammal&#39;)</span>
<span class="sd">                           num_legs  num_wings</span>
<span class="sd">        animal locomotion</span>
<span class="sd">        cat    walks              4          0</span>
<span class="sd">        dog    walks              4          0</span>
<span class="sd">        bat    flies              2          2</span>

<span class="sd">        Get values at several indexes</span>

<span class="sd">        &gt;&gt;&gt; df.xs((&#39;mammal&#39;, &#39;dog&#39;, &#39;walks&#39;))</span>
<span class="sd">        num_legs     4</span>
<span class="sd">        num_wings    0</span>
<span class="sd">        Name: (mammal, dog, walks), dtype: int64</span>

<span class="sd">        Get values at specified index and level</span>

<span class="sd">        &gt;&gt;&gt; df.xs(&#39;cat&#39;, level=1)</span>
<span class="sd">                           num_legs  num_wings</span>
<span class="sd">        class  locomotion</span>
<span class="sd">        mammal walks              4          0</span>

<span class="sd">        Get values at several indexes and levels</span>

<span class="sd">        &gt;&gt;&gt; df.xs((&#39;bird&#39;, &#39;walks&#39;),</span>
<span class="sd">        ...       level=[0, &#39;locomotion&#39;])</span>
<span class="sd">                 num_legs  num_wings</span>
<span class="sd">        animal</span>
<span class="sd">        penguin         2          2</span>

<span class="sd">        Get values at specified column and axis</span>

<span class="sd">        &gt;&gt;&gt; df.xs(&#39;num_wings&#39;, axis=1)</span>
<span class="sd">        class   animal   locomotion</span>
<span class="sd">        mammal  cat      walks         0</span>
<span class="sd">                dog      walks         0</span>
<span class="sd">                bat      flies         2</span>
<span class="sd">        bird    penguin  walks         2</span>
<span class="sd">        Name: num_wings, dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;list keys are not supported in xs, pass a tuple instead&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index must be a MultiIndex&quot;</span><span class="p">)</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">new_ax</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">get_loc_level</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="n">drop_level</span><span class="p">)</span>

            <span class="c1"># create the tuple of the indexer</span>
            <span class="n">_indexer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">_indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_indexer</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">new_ax</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_level</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">_get_loc_level</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">drop_level</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lib</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
                    <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">loc</span> <span class="p">:</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">loc</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">inds</span><span class="p">,)</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_with_is_copy</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_with_is_copy</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># In this case loc should be an integer</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if we encounter an array-like and we only have 1 dim</span>
                <span class="c1"># that means that their are list/ndarrays inside the Series!</span>
                <span class="c1"># so just return them (GH 6394)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

            <span class="n">new_mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">fast_xs</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                <span class="n">new_mgr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="nb">slice</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">loc</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">new_index</span>

        <span class="c1"># this could be a view</span>
        <span class="c1"># but only in a single-dtyped view sliceable case</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">_is_view</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">slobj</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a slice of this container.</span>

<span class="sd">        Slicing with this method is *always* positional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slobj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">slobj</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">slobj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># this could be a view</span>
        <span class="c1"># but only in a single-dtyped view sliceable case</span>
        <span class="n">is_copy</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">result</span><span class="o">.</span><span class="n">_is_view</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">is_copy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">:</span> <span class="n">NDFrame</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_is_chained_assignment_possible</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if we are a view, have a cacher, and are of mixed type.</span>
<span class="sd">        If so, then force a setitem_copy check.</span>

<span class="sd">        Should be called just near setting a value</span>

<span class="sd">        Will return a boolean if it we are a view and are cached, but a</span>
<span class="sd">        single-dtype meaning that the cacher should be updated following</span>
<span class="sd">        setting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="s2">&quot;referent&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_check_setitem_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;setting&quot;</span><span class="p">,</span> <span class="n">force</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : str, the type of setting error</span>
<span class="sd">        force : bool, default False</span>
<span class="sd">           If True, then force showing an error.</span>

<span class="sd">        validate if we are doing a setitem on a chained copy.</span>

<span class="sd">        It is technically possible to figure out that we are setting on</span>
<span class="sd">        a copy even WITH a multi-dtyped pandas object. In other words, some</span>
<span class="sd">        blocks may be views while other are not. Currently _is_view will ALWAYS</span>
<span class="sd">        return False for multi-blocks to avoid having to handle this case.</span>

<span class="sd">        df = DataFrame(np.arange(0,9), columns=[&#39;count&#39;])</span>
<span class="sd">        df[&#39;group&#39;] = &#39;b&#39;</span>

<span class="sd">        # This technically need not raise SettingWithCopy if both are view</span>
<span class="sd">        # (which is not generally guaranteed but is usually True.  However,</span>
<span class="sd">        # this is in general not a good practice and we recommend using .loc.</span>
<span class="sd">        df.iloc[0:5][&#39;group&#39;] = &#39;a&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="c1"># return early if the check is not needed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">force</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;mode.chained_assignment&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># see if the copy is not actually referred; if so, then dissolve</span>
        <span class="c1"># the copy weakref</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_referents</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">return</span>

        <span class="c1"># a custom message</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;referent&quot;</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;A value is trying to be set on a copy of a slice from a &quot;</span>
                <span class="s2">&quot;DataFrame</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;See the caveats in the documentation: &quot;</span>
                <span class="s2">&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/&quot;</span>
                <span class="s2">&quot;indexing.html#returning-a-view-versus-a-copy&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;A value is trying to be set on a copy of a slice from a &quot;</span>
                <span class="s2">&quot;DataFrame.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Try using .loc[row_indexer,col_indexer] = value &quot;</span>
                <span class="s2">&quot;instead</span><span class="se">\n\n</span><span class="s2">See the caveats in the documentation: &quot;</span>
                <span class="s2">&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/&quot;</span>
                <span class="s2">&quot;indexing.html#returning-a-view-versus-a-copy&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SettingWithCopyError</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;warn&quot;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">SettingWithCopyWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete item</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deleted</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">maybe_shortcut</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># By using engine&#39;s __contains__ we effectively</span>
                <span class="c1"># restrict to same-length tuples</span>
                <span class="n">maybe_shortcut</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_engine</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">maybe_shortcut</span><span class="p">:</span>
            <span class="c1"># Allow shorthand to delete all columns whose first len(key)</span>
            <span class="c1"># elements match key:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">col</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="n">deleted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deleted</span><span class="p">:</span>
            <span class="c1"># If the above loop ran and didn&#39;t delete anything because</span>
            <span class="c1"># there was no match, this call should raise the appropriate</span>
            <span class="c1"># exception:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">idelete</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>

        <span class="c1"># delete from the caches</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Unsorted</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_check_inplace_and_allows_duplicate_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inplace</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">allows_duplicate_labels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify &#39;inplace=True&#39; when &quot;</span>
                <span class="s2">&quot;&#39;self.flags.allows_duplicate_labels&#39; is False.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get item from object for given key (ex: DataFrame column).</span>

<span class="sd">        Returns default value if not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as items contained in object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         [24.3, 75.7, &quot;high&quot;],</span>
<span class="sd">        ...         [31, 87.8, &quot;high&quot;],</span>
<span class="sd">        ...         [22, 71.6, &quot;medium&quot;],</span>
<span class="sd">        ...         [35, 95, &quot;medium&quot;],</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     columns=[&quot;temp_celsius&quot;, &quot;temp_fahrenheit&quot;, &quot;windspeed&quot;],</span>
<span class="sd">        ...     index=pd.date_range(start=&quot;2014-02-12&quot;, end=&quot;2014-02-15&quot;, freq=&quot;D&quot;),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                    temp_celsius  temp_fahrenheit windspeed</span>
<span class="sd">        2014-02-12          24.3             75.7      high</span>
<span class="sd">        2014-02-13          31.0             87.8      high</span>
<span class="sd">        2014-02-14          22.0             71.6    medium</span>
<span class="sd">        2014-02-15          35.0             95.0    medium</span>

<span class="sd">        &gt;&gt;&gt; df.get([&quot;temp_celsius&quot;, &quot;windspeed&quot;])</span>
<span class="sd">                    temp_celsius windspeed</span>
<span class="sd">        2014-02-12          24.3      high</span>
<span class="sd">        2014-02-13          31.0      high</span>
<span class="sd">        2014-02-14          22.0    medium</span>
<span class="sd">        2014-02-15          35.0    medium</span>

<span class="sd">        &gt;&gt;&gt; ser = df[&#39;windspeed&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ser.get(&#39;2014-02-13&#39;)</span>
<span class="sd">        &#39;high&#39;</span>

<span class="sd">        If the key isn&#39;t found, the default value will be used.</span>

<span class="sd">        &gt;&gt;&gt; df.get([&quot;temp_celsius&quot;, &quot;temp_kelvin&quot;], default=&quot;default_value&quot;)</span>
<span class="sd">        &#39;default_value&#39;</span>

<span class="sd">        &gt;&gt;&gt; ser.get(&#39;2014-02-10&#39;, &#39;[unknown]&#39;)</span>
<span class="sd">        &#39;[unknown]&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">default</span>

    <span class="nd">@final</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_view</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return boolean indicating if self is view of another array&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">is_view</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">reindex_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;backfill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an object with matching indices as other object.</span>

<span class="sd">        Conform the object to the same index on all axes. Optional</span>
<span class="sd">        filling logic, placing NaN in locations having no value</span>
<span class="sd">        in the previous index. A new object is produced unless the</span>
<span class="sd">        new index is equivalent to the current one and copy=False.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Object of the same data type</span>
<span class="sd">            Its row and column indices are used to define the new indices</span>
<span class="sd">            of this object.</span>
<span class="sd">        method : {None, &#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Method to use for filling holes in reindexed DataFrame.</span>
<span class="sd">            Please note: this is only applicable to DataFrames/Series with a</span>
<span class="sd">            monotonically increasing/decreasing index.</span>

<span class="sd">            * None (default): don&#39;t fill gaps</span>
<span class="sd">            * pad / ffill: propagate last valid observation forward to next</span>
<span class="sd">              valid</span>
<span class="sd">            * backfill / bfill: use next valid observation to fill gap</span>
<span class="sd">            * nearest: use nearest valid observations to fill gap.</span>

<span class="sd">        copy : bool, default True</span>
<span class="sd">            Return a new object, even if the passed indexes are the same.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum number of consecutive labels to fill for inexact matches.</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations must</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>

<span class="sd">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="sd">            to all values, or list-like, which applies variable tolerance per</span>
<span class="sd">            element. List-like includes list, tuple, array, Series, and must be</span>
<span class="sd">            the same size as the index and its dtype must exactly match the</span>
<span class="sd">            index&#39;s type.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Same type as caller, but with changed indices on each axis.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.set_index : Set row labels.</span>
<span class="sd">        DataFrame.reset_index : Remove row labels or move them to new columns.</span>
<span class="sd">        DataFrame.reindex : Change to new indices or expand indices.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Same as calling</span>
<span class="sd">        ``.reindex(index=other.index, columns=other.columns,...)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame([[24.3, 75.7, &#39;high&#39;],</span>
<span class="sd">        ...                     [31, 87.8, &#39;high&#39;],</span>
<span class="sd">        ...                     [22, 71.6, &#39;medium&#39;],</span>
<span class="sd">        ...                     [35, 95, &#39;medium&#39;]],</span>
<span class="sd">        ...                    columns=[&#39;temp_celsius&#39;, &#39;temp_fahrenheit&#39;,</span>
<span class="sd">        ...                             &#39;windspeed&#39;],</span>
<span class="sd">        ...                    index=pd.date_range(start=&#39;2014-02-12&#39;,</span>
<span class="sd">        ...                                        end=&#39;2014-02-15&#39;, freq=&#39;D&#39;))</span>

<span class="sd">        &gt;&gt;&gt; df1</span>
<span class="sd">                    temp_celsius  temp_fahrenheit windspeed</span>
<span class="sd">        2014-02-12          24.3             75.7      high</span>
<span class="sd">        2014-02-13          31.0             87.8      high</span>
<span class="sd">        2014-02-14          22.0             71.6    medium</span>
<span class="sd">        2014-02-15          35.0             95.0    medium</span>

<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame([[28, &#39;low&#39;],</span>
<span class="sd">        ...                     [30, &#39;low&#39;],</span>
<span class="sd">        ...                     [35.1, &#39;medium&#39;]],</span>
<span class="sd">        ...                    columns=[&#39;temp_celsius&#39;, &#39;windspeed&#39;],</span>
<span class="sd">        ...                    index=pd.DatetimeIndex([&#39;2014-02-12&#39;, &#39;2014-02-13&#39;,</span>
<span class="sd">        ...                                            &#39;2014-02-15&#39;]))</span>

<span class="sd">        &gt;&gt;&gt; df2</span>
<span class="sd">                    temp_celsius windspeed</span>
<span class="sd">        2014-02-12          28.0       low</span>
<span class="sd">        2014-02-13          30.0       low</span>
<span class="sd">        2014-02-15          35.1    medium</span>

<span class="sd">        &gt;&gt;&gt; df2.reindex_like(df1)</span>
<span class="sd">                    temp_celsius  temp_fahrenheit windspeed</span>
<span class="sd">        2014-02-12          28.0              NaN       low</span>
<span class="sd">        2014-02-13          30.0              NaN       low</span>
<span class="sd">        2014-02-14           NaN              NaN       NaN</span>
<span class="sd">        2014-02-15          35.1              NaN    medium</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(</span>
            <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both &#39;labels&#39; and &#39;index&#39;/&#39;columns&#39;&quot;</span><span class="p">)</span>
            <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">labels</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">index</span><span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">axes</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Need to specify at least one of &#39;labels&#39;, &#39;index&#39; or &#39;columns&#39;&quot;</span>
            <span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_drop_axis</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_drop_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">only_slice</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop labels from specified axis. Used in the ``drop`` method</span>
<span class="sd">        internally.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : single label or list-like</span>
<span class="sd">        axis : int or axis name</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            For MultiIndex</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span>
<span class="sd">            If &#39;ignore&#39;, suppress error and existing labels are dropped.</span>
<span class="sd">        only_slice : bool, default False</span>
<span class="sd">            Whether indexing along columns should be view-only.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;axis must be a MultiIndex&quot;</span><span class="p">)</span>
                <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">new_axis</span><span class="p">)</span>

        <span class="c1"># Case for non-unique axis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_tuple_labels</span> <span class="o">=</span> <span class="n">is_nested_list_like</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">ensure_object</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">index_labels_to_array</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;axis must be a MultiIndex&quot;</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">axis</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">level</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

                <span class="c1"># GH 18561 MultiIndex.drop should raise if label is absent</span>
                <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">labels</span><span class="si">}</span><span class="s2"> not found in axis&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">labels</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;object&quot;</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_tuple_labels</span>
            <span class="p">):</span>
                <span class="c1"># Set level to zero in case of MultiIndex and label is string,</span>
                <span class="c1">#  because isin can&#39;t handle strings for MultiIndexes GH#36293</span>
                <span class="c1"># In case of tuples we get dtype object but have to use isin GH#42771</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">axis</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">axis</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
                <span class="c1"># Check if label doesn&#39;t exist along axis</span>
                <span class="n">labels_missing</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span> <span class="ow">and</span> <span class="n">labels_missing</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">labels</span><span class="si">}</span><span class="s2"> not found in axis&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># GH#45860</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

        <span class="n">bm_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">axis_num</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">new_mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span>
            <span class="n">new_axis</span><span class="p">,</span>
            <span class="n">indexer</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">bm_axis</span><span class="p">,</span>
            <span class="n">allow_dups</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">only_slice</span><span class="o">=</span><span class="n">only_slice</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_mgr</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_update_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">verify_is_copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace self internals with result.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        result : same type as self</span>
<span class="sd">        verify_is_copy : bool, default True</span>
<span class="sd">            Provide is_copy checks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: This does *not* call __finalize__ and that&#39;s an explicit</span>
        <span class="c1"># decision that we may revisit in the future.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_mgr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_cacher</span><span class="p">(</span><span class="n">verify_is_copy</span><span class="o">=</span><span class="n">verify_is_copy</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">add_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prefix labels with string `prefix`.</span>

<span class="sd">        For Series, the row labels are prefixed.</span>
<span class="sd">        For DataFrame, the column labels are prefixed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prefix : str</span>
<span class="sd">            The string to add before each label.</span>
<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}}, default None</span>
<span class="sd">            Axis to add prefix on</span>

<span class="sd">            .. versionadded:: 2.0.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            New Series or DataFrame with updated labels.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.add_suffix: Suffix row labels with string `suffix`.</span>
<span class="sd">        DataFrame.add_suffix: Suffix column labels with string `suffix`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.add_prefix(&#39;item_&#39;)</span>
<span class="sd">        item_0    1</span>
<span class="sd">        item_1    2</span>
<span class="sd">        item_2    3</span>
<span class="sd">        item_3    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4], &#39;B&#39;: [3, 4, 5, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  3</span>
<span class="sd">        1  2  4</span>
<span class="sd">        2  3  5</span>
<span class="sd">        3  4  6</span>

<span class="sd">        &gt;&gt;&gt; df.add_prefix(&#39;col_&#39;)</span>
<span class="sd">             col_A  col_B</span>
<span class="sd">        0       1       3</span>
<span class="sd">        1       2       4</span>
<span class="sd">        2       3       5</span>
<span class="sd">        3       4       6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">f</span><span class="p">}</span>

        <span class="c1"># error: Incompatible return value type (got &quot;Optional[NDFrameT]&quot;,</span>
        <span class="c1"># expected &quot;NDFrameT&quot;)</span>
        <span class="c1"># error: Argument 1 to &quot;rename&quot; of &quot;NDFrame&quot; has incompatible type</span>
        <span class="c1"># &quot;**Dict[str, partial[str]]&quot;; expected &quot;Union[str, int, None]&quot;</span>
        <span class="c1"># error: Keywords must be strings</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span><span class="o">**</span><span class="n">mapper</span><span class="p">)</span>  <span class="c1"># type: ignore[return-value, arg-type, misc]</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">add_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Suffix labels with string `suffix`.</span>

<span class="sd">        For Series, the row labels are suffixed.</span>
<span class="sd">        For DataFrame, the column labels are suffixed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        suffix : str</span>
<span class="sd">            The string to add after each label.</span>
<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}}, default None</span>
<span class="sd">            Axis to add suffix on</span>

<span class="sd">            .. versionadded:: 2.0.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            New Series or DataFrame with updated labels.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.add_prefix: Prefix row labels with string `prefix`.</span>
<span class="sd">        DataFrame.add_prefix: Prefix column labels with string `prefix`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.add_suffix(&#39;_item&#39;)</span>
<span class="sd">        0_item    1</span>
<span class="sd">        1_item    2</span>
<span class="sd">        2_item    3</span>
<span class="sd">        3_item    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4], &#39;B&#39;: [3, 4, 5, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  3</span>
<span class="sd">        1  2  4</span>
<span class="sd">        2  3  5</span>
<span class="sd">        3  4  6</span>

<span class="sd">        &gt;&gt;&gt; df.add_suffix(&#39;_col&#39;)</span>
<span class="sd">             A_col  B_col</span>
<span class="sd">        0       1       3</span>
<span class="sd">        1       2       4</span>
<span class="sd">        2       3       5</span>
<span class="sd">        3       4       6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">f</span><span class="p">}</span>
        <span class="c1"># error: Incompatible return value type (got &quot;Optional[NDFrameT]&quot;,</span>
        <span class="c1"># expected &quot;NDFrameT&quot;)</span>
        <span class="c1"># error: Argument 1 to &quot;rename&quot; of &quot;NDFrame&quot; has incompatible type</span>
        <span class="c1"># &quot;**Dict[str, partial[str]]&quot;; expected &quot;Union[str, int, None]&quot;</span>
        <span class="c1"># error: Keywords must be strings</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span><span class="o">**</span><span class="n">mapper</span><span class="p">)</span>  <span class="c1"># type: ignore[return-value, arg-type, misc]</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">bool_t</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">ValueKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">bool_t</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">ValueKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">bool_t</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">ValueKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">bool_t</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;quicksort&quot;</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">ValueKeyFunc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort by the values along either axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------%(optional_by)s</span>
<span class="sd">        axis : %(axes_single_arg)s, default 0</span>
<span class="sd">             Axis to be sorted.</span>
<span class="sd">        ascending : bool or list of bool, default True</span>
<span class="sd">             Sort ascending vs. descending. Specify list for multiple sort</span>
<span class="sd">             orders.  If this is a list of bools, must match the length of</span>
<span class="sd">             the by.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">             If True, perform operation in-place.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, default &#39;quicksort&#39;</span>
<span class="sd">             Choice of sorting algorithm. See also :func:`numpy.sort` for more</span>
<span class="sd">             information. `mergesort` and `stable` are the only stable algorithms. For</span>
<span class="sd">             DataFrames, this option is only applied when sorting on a single</span>
<span class="sd">             column or label.</span>
<span class="sd">        na_position : {&#39;first&#39;, &#39;last&#39;}, default &#39;last&#39;</span>
<span class="sd">             Puts NaNs at the beginning if `first`; `last` puts NaNs at the</span>
<span class="sd">             end.</span>
<span class="sd">        ignore_index : bool, default False</span>
<span class="sd">             If True, the resulting axis will be labeled 0, 1, , n - 1.</span>
<span class="sd">        key : callable, optional</span>
<span class="sd">            Apply the key function to the values</span>
<span class="sd">            before sorting. This is similar to the `key` argument in the</span>
<span class="sd">            builtin :meth:`sorted` function, with the notable difference that</span>
<span class="sd">            this `key` function should be *vectorized*. It should expect a</span>
<span class="sd">            ``Series`` and return a Series with the same shape as the input.</span>
<span class="sd">            It will be applied to each column in `by` independently.</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">            DataFrame with sorted values or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.sort_index : Sort a DataFrame by the index.</span>
<span class="sd">        Series.sort_values : Similar method for a Series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...     &#39;col1&#39;: [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, np.nan, &#39;D&#39;, &#39;C&#39;],</span>
<span class="sd">        ...     &#39;col2&#39;: [2, 1, 9, 8, 7, 4],</span>
<span class="sd">        ...     &#39;col3&#39;: [0, 1, 9, 4, 2, 3],</span>
<span class="sd">        ...     &#39;col4&#39;: [&#39;a&#39;, &#39;B&#39;, &#39;c&#39;, &#39;D&#39;, &#39;e&#39;, &#39;F&#39;]</span>
<span class="sd">        ... })</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">          col1  col2  col3 col4</span>
<span class="sd">        0    A     2     0    a</span>
<span class="sd">        1    A     1     1    B</span>
<span class="sd">        2    B     9     9    c</span>
<span class="sd">        3  NaN     8     4    D</span>
<span class="sd">        4    D     7     2    e</span>
<span class="sd">        5    C     4     3    F</span>

<span class="sd">        Sort by col1</span>

<span class="sd">        &gt;&gt;&gt; df.sort_values(by=[&#39;col1&#39;])</span>
<span class="sd">          col1  col2  col3 col4</span>
<span class="sd">        0    A     2     0    a</span>
<span class="sd">        1    A     1     1    B</span>
<span class="sd">        2    B     9     9    c</span>
<span class="sd">        5    C     4     3    F</span>
<span class="sd">        4    D     7     2    e</span>
<span class="sd">        3  NaN     8     4    D</span>

<span class="sd">        Sort by multiple columns</span>

<span class="sd">        &gt;&gt;&gt; df.sort_values(by=[&#39;col1&#39;, &#39;col2&#39;])</span>
<span class="sd">          col1  col2  col3 col4</span>
<span class="sd">        1    A     1     1    B</span>
<span class="sd">        0    A     2     0    a</span>
<span class="sd">        2    B     9     9    c</span>
<span class="sd">        5    C     4     3    F</span>
<span class="sd">        4    D     7     2    e</span>
<span class="sd">        3  NaN     8     4    D</span>

<span class="sd">        Sort Descending</span>

<span class="sd">        &gt;&gt;&gt; df.sort_values(by=&#39;col1&#39;, ascending=False)</span>
<span class="sd">          col1  col2  col3 col4</span>
<span class="sd">        4    D     7     2    e</span>
<span class="sd">        5    C     4     3    F</span>
<span class="sd">        2    B     9     9    c</span>
<span class="sd">        0    A     2     0    a</span>
<span class="sd">        1    A     1     1    B</span>
<span class="sd">        3  NaN     8     4    D</span>

<span class="sd">        Putting NAs first</span>

<span class="sd">        &gt;&gt;&gt; df.sort_values(by=&#39;col1&#39;, ascending=False, na_position=&#39;first&#39;)</span>
<span class="sd">          col1  col2  col3 col4</span>
<span class="sd">        3  NaN     8     4    D</span>
<span class="sd">        4    D     7     2    e</span>
<span class="sd">        5    C     4     3    F</span>
<span class="sd">        2    B     9     9    c</span>
<span class="sd">        0    A     2     0    a</span>
<span class="sd">        1    A     1     1    B</span>

<span class="sd">        Sorting with a key function</span>

<span class="sd">        &gt;&gt;&gt; df.sort_values(by=&#39;col4&#39;, key=lambda col: col.str.lower())</span>
<span class="sd">           col1  col2  col3 col4</span>
<span class="sd">        0    A     2     0    a</span>
<span class="sd">        1    A     1     1    B</span>
<span class="sd">        2    B     9     9    c</span>
<span class="sd">        3  NaN     8     4    D</span>
<span class="sd">        4    D     7     2    e</span>
<span class="sd">        5    C     4     3    F</span>

<span class="sd">        Natural sort with the key argument,</span>
<span class="sd">        using the `natsort &lt;https://github.com/SethMMorton/natsort&gt;` package.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...    &quot;time&quot;: [&#39;0hr&#39;, &#39;128hr&#39;, &#39;72hr&#39;, &#39;48hr&#39;, &#39;96hr&#39;],</span>
<span class="sd">        ...    &quot;value&quot;: [10, 20, 30, 40, 50]</span>
<span class="sd">        ... })</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            time  value</span>
<span class="sd">        0    0hr     10</span>
<span class="sd">        1  128hr     20</span>
<span class="sd">        2   72hr     30</span>
<span class="sd">        3   48hr     40</span>
<span class="sd">        4   96hr     50</span>
<span class="sd">        &gt;&gt;&gt; from natsort import index_natsorted</span>
<span class="sd">        &gt;&gt;&gt; df.sort_values(</span>
<span class="sd">        ...     by=&quot;time&quot;,</span>
<span class="sd">        ...     key=lambda x: np.argsort(index_natsorted(df[&quot;time&quot;]))</span>
<span class="sd">        ... )</span>
<span class="sd">            time  value</span>
<span class="sd">        0    0hr     10</span>
<span class="sd">        3   48hr     40</span>
<span class="sd">        2   72hr     30</span>
<span class="sd">        4   96hr     50</span>
<span class="sd">        1  128hr     20</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">bool_t</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SortKind</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="n">NaPosition</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sort_remaining</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">IndexKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">bool_t</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SortKind</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="n">NaPosition</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sort_remaining</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">IndexKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">bool_t</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SortKind</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="n">NaPosition</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sort_remaining</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">IndexKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">bool_t</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SortKind</span> <span class="o">=</span> <span class="s2">&quot;quicksort&quot;</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="n">NaPosition</span> <span class="o">=</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span>
        <span class="n">sort_remaining</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">IndexKeyFunc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ascending</span> <span class="o">=</span> <span class="n">validate_ascending</span><span class="p">(</span><span class="n">ascending</span><span class="p">)</span>

        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">indexer</span> <span class="o">=</span> <span class="n">get_indexer_indexer</span><span class="p">(</span>
            <span class="n">target</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">ascending</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">na_position</span><span class="p">,</span> <span class="n">sort_remaining</span><span class="p">,</span> <span class="n">key</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">indexer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>

        <span class="n">baxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">baxis</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># reconstruct axis if needed</span>
        <span class="n">new_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">baxis</span><span class="p">,</span> <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">baxis</span><span class="p">]</span><span class="o">.</span><span class="n">_sort_levels_monotonic</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">)))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;sort_index&quot;</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">],</span>
        <span class="n">optional_reindex</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Scalar</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conform {klass} to new index with optional filling logic.</span>

<span class="sd">        Places NA/NaN in locations having no value in the previous index. A new object</span>
<span class="sd">        is produced unless the new index is equivalent to the current one and</span>
<span class="sd">        ``copy=False``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {optional_reindex}</span>
<span class="sd">        method : {{None, &#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;, &#39;nearest&#39;}}</span>
<span class="sd">            Method to use for filling holes in reindexed DataFrame.</span>
<span class="sd">            Please note: this is only applicable to DataFrames/Series with a</span>
<span class="sd">            monotonically increasing/decreasing index.</span>

<span class="sd">            * None (default): don&#39;t fill gaps</span>
<span class="sd">            * pad / ffill: Propagate last valid observation forward to next</span>
<span class="sd">              valid.</span>
<span class="sd">            * backfill / bfill: Use next valid observation to fill gap.</span>
<span class="sd">            * nearest: Use nearest valid observations to fill gap.</span>

<span class="sd">        copy : bool, default True</span>
<span class="sd">            Return a new object, even if the passed indexes are the same.</span>
<span class="sd">        level : int or name</span>
<span class="sd">            Broadcast across a level, matching Index values on the</span>
<span class="sd">            passed MultiIndex level.</span>
<span class="sd">        fill_value : scalar, default np.NaN</span>
<span class="sd">            Value to use for missing values. Defaults to NaN, but can be any</span>
<span class="sd">            &quot;compatible&quot; value.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum number of consecutive elements to forward or backward fill.</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations most</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>

<span class="sd">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="sd">            to all values, or list-like, which applies variable tolerance per</span>
<span class="sd">            element. List-like includes list, tuple, array, Series, and must be</span>
<span class="sd">            the same size as the index and its dtype must exactly match the</span>
<span class="sd">            index&#39;s type.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass} with changed index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.set_index : Set row labels.</span>
<span class="sd">        DataFrame.reset_index : Remove row labels or move them to new columns.</span>
<span class="sd">        DataFrame.reindex_like : Change to same indices as other DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ``DataFrame.reindex`` supports two calling conventions</span>

<span class="sd">        * ``(index=index_labels, columns=column_labels, ...)``</span>
<span class="sd">        * ``(labels, axis={{&#39;index&#39;, &#39;columns&#39;}}, ...)``</span>

<span class="sd">        We *highly* recommend using keyword arguments to clarify your</span>
<span class="sd">        intent.</span>

<span class="sd">        Create a dataframe with some fictional data.</span>

<span class="sd">        &gt;&gt;&gt; index = [&#39;Firefox&#39;, &#39;Chrome&#39;, &#39;Safari&#39;, &#39;IE10&#39;, &#39;Konqueror&#39;]</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({{&#39;http_status&#39;: [200, 200, 404, 404, 301],</span>
<span class="sd">        ...                   &#39;response_time&#39;: [0.04, 0.02, 0.07, 0.08, 1.0]}},</span>
<span class="sd">        ...                   index=index)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                   http_status  response_time</span>
<span class="sd">        Firefox            200           0.04</span>
<span class="sd">        Chrome             200           0.02</span>
<span class="sd">        Safari             404           0.07</span>
<span class="sd">        IE10               404           0.08</span>
<span class="sd">        Konqueror          301           1.00</span>

<span class="sd">        Create a new index and reindex the dataframe. By default</span>
<span class="sd">        values in the new index that do not have corresponding</span>
<span class="sd">        records in the dataframe are assigned ``NaN``.</span>

<span class="sd">        &gt;&gt;&gt; new_index = [&#39;Safari&#39;, &#39;Iceweasel&#39;, &#39;Comodo Dragon&#39;, &#39;IE10&#39;,</span>
<span class="sd">        ...              &#39;Chrome&#39;]</span>
<span class="sd">        &gt;&gt;&gt; df.reindex(new_index)</span>
<span class="sd">                       http_status  response_time</span>
<span class="sd">        Safari               404.0           0.07</span>
<span class="sd">        Iceweasel              NaN            NaN</span>
<span class="sd">        Comodo Dragon          NaN            NaN</span>
<span class="sd">        IE10                 404.0           0.08</span>
<span class="sd">        Chrome               200.0           0.02</span>

<span class="sd">        We can fill in the missing values by passing a value to</span>
<span class="sd">        the keyword ``fill_value``. Because the index is not monotonically</span>
<span class="sd">        increasing or decreasing, we cannot use arguments to the keyword</span>
<span class="sd">        ``method`` to fill the ``NaN`` values.</span>

<span class="sd">        &gt;&gt;&gt; df.reindex(new_index, fill_value=0)</span>
<span class="sd">                       http_status  response_time</span>
<span class="sd">        Safari                 404           0.07</span>
<span class="sd">        Iceweasel                0           0.00</span>
<span class="sd">        Comodo Dragon            0           0.00</span>
<span class="sd">        IE10                   404           0.08</span>
<span class="sd">        Chrome                 200           0.02</span>

<span class="sd">        &gt;&gt;&gt; df.reindex(new_index, fill_value=&#39;missing&#39;)</span>
<span class="sd">                      http_status response_time</span>
<span class="sd">        Safari                404          0.07</span>
<span class="sd">        Iceweasel         missing       missing</span>
<span class="sd">        Comodo Dragon     missing       missing</span>
<span class="sd">        IE10                  404          0.08</span>
<span class="sd">        Chrome                200          0.02</span>

<span class="sd">        We can also reindex the columns.</span>

<span class="sd">        &gt;&gt;&gt; df.reindex(columns=[&#39;http_status&#39;, &#39;user_agent&#39;])</span>
<span class="sd">                   http_status  user_agent</span>
<span class="sd">        Firefox            200         NaN</span>
<span class="sd">        Chrome             200         NaN</span>
<span class="sd">        Safari             404         NaN</span>
<span class="sd">        IE10               404         NaN</span>
<span class="sd">        Konqueror          301         NaN</span>

<span class="sd">        Or we can use &quot;axis-style&quot; keyword arguments</span>

<span class="sd">        &gt;&gt;&gt; df.reindex([&#39;http_status&#39;, &#39;user_agent&#39;], axis=&quot;columns&quot;)</span>
<span class="sd">                   http_status  user_agent</span>
<span class="sd">        Firefox            200         NaN</span>
<span class="sd">        Chrome             200         NaN</span>
<span class="sd">        Safari             404         NaN</span>
<span class="sd">        IE10               404         NaN</span>
<span class="sd">        Konqueror          301         NaN</span>

<span class="sd">        To further illustrate the filling functionality in</span>
<span class="sd">        ``reindex``, we will create a dataframe with a</span>
<span class="sd">        monotonically increasing index (for example, a sequence</span>
<span class="sd">        of dates).</span>

<span class="sd">        &gt;&gt;&gt; date_index = pd.date_range(&#39;1/1/2010&#39;, periods=6, freq=&#39;D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({{&quot;prices&quot;: [100, 101, np.nan, 100, 89, 88]}},</span>
<span class="sd">        ...                    index=date_index)</span>
<span class="sd">        &gt;&gt;&gt; df2</span>
<span class="sd">                    prices</span>
<span class="sd">        2010-01-01   100.0</span>
<span class="sd">        2010-01-02   101.0</span>
<span class="sd">        2010-01-03     NaN</span>
<span class="sd">        2010-01-04   100.0</span>
<span class="sd">        2010-01-05    89.0</span>
<span class="sd">        2010-01-06    88.0</span>

<span class="sd">        Suppose we decide to expand the dataframe to cover a wider</span>
<span class="sd">        date range.</span>

<span class="sd">        &gt;&gt;&gt; date_index2 = pd.date_range(&#39;12/29/2009&#39;, periods=10, freq=&#39;D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df2.reindex(date_index2)</span>
<span class="sd">                    prices</span>
<span class="sd">        2009-12-29     NaN</span>
<span class="sd">        2009-12-30     NaN</span>
<span class="sd">        2009-12-31     NaN</span>
<span class="sd">        2010-01-01   100.0</span>
<span class="sd">        2010-01-02   101.0</span>
<span class="sd">        2010-01-03     NaN</span>
<span class="sd">        2010-01-04   100.0</span>
<span class="sd">        2010-01-05    89.0</span>
<span class="sd">        2010-01-06    88.0</span>
<span class="sd">        2010-01-07     NaN</span>

<span class="sd">        The index entries that did not have a value in the original data frame</span>
<span class="sd">        (for example, &#39;2009-12-29&#39;) are by default filled with ``NaN``.</span>
<span class="sd">        If desired, we can fill in the missing values using one of several</span>
<span class="sd">        options.</span>

<span class="sd">        For example, to back-propagate the last valid value to fill the ``NaN``</span>
<span class="sd">        values, pass ``bfill`` as an argument to the ``method`` keyword.</span>

<span class="sd">        &gt;&gt;&gt; df2.reindex(date_index2, method=&#39;bfill&#39;)</span>
<span class="sd">                    prices</span>
<span class="sd">        2009-12-29   100.0</span>
<span class="sd">        2009-12-30   100.0</span>
<span class="sd">        2009-12-31   100.0</span>
<span class="sd">        2010-01-01   100.0</span>
<span class="sd">        2010-01-02   101.0</span>
<span class="sd">        2010-01-03     NaN</span>
<span class="sd">        2010-01-04   100.0</span>
<span class="sd">        2010-01-05    89.0</span>
<span class="sd">        2010-01-06    88.0</span>
<span class="sd">        2010-01-07     NaN</span>

<span class="sd">        Please note that the ``NaN`` value present in the original dataframe</span>
<span class="sd">        (at index value 2010-01-03) will not be filled by any of the</span>
<span class="sd">        value propagation schemes. This is because filling while reindexing</span>
<span class="sd">        does not look at dataframe values, but only compares the original and</span>
<span class="sd">        desired indexes. If you do want to fill in the ``NaN`` values present</span>
<span class="sd">        in the original dataframe, use the ``fillna()`` method.</span>

<span class="sd">        See the :ref:`user guide &lt;basics.reindexing&gt;` for more.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Decide if we care about having different examples for different</span>
        <span class="c1"># kinds</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify all of &#39;labels&#39;, &#39;index&#39;, &#39;columns&#39;.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify both &#39;axis&#39; and any of &#39;index&#39; or &#39;columns&#39;&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">columns</span> <span class="o">=</span> <span class="n">labels</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">labels</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="n">axes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span>
            <span class="s2">&quot;columns&quot;</span><span class="p">:</span> <span class="n">columns</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">clean_reindex_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="c1"># if all axes that are requested to reindex are equal, then only copy</span>
        <span class="c1"># if indicated must have index names equal here as well as values</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)</span><span class="o">.</span><span class="n">identical</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="c1"># check if we are a multi reindex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_reindex_multi</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_multi</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

        <span class="c1"># perform the reindex on the axes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_axes</span><span class="p">(</span>
            <span class="n">axes</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span>
        <span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;reindex&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_axes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform the reindex for all the axes.&quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="n">labels</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span>
            <span class="p">)</span>

            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
                <span class="p">{</span><span class="n">axis</span><span class="p">:</span> <span class="p">[</span><span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">]},</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">allow_dups</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># If we&#39;ve made a copy once, no need to make another one</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_needs_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if we do need a multi reindex.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">count_not_none</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_reindex_with_indexers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">reindexers</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_dups</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;allow_dups indicates an internal call here&quot;&quot;&quot;</span>
        <span class="c1"># reindex doing multiple operations on different axes if indicated</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">reindexers</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">reindexers</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">baxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">index</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

            <span class="c1"># TODO: speed up on homogeneous DataFrame objects (see _reindex_multi)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span>
                <span class="n">index</span><span class="p">,</span>
                <span class="n">indexer</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">baxis</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">allow_dups</span><span class="o">=</span><span class="n">allow_dups</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># If we&#39;ve made a copy once, no need to make another one</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">copy</span> <span class="ow">or</span> <span class="n">copy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">new_data</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">using_copy_on_write</span><span class="p">()</span> <span class="ow">and</span> <span class="n">new_data</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">items</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">like</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subset the dataframe rows or columns according to the specified index labels.</span>

<span class="sd">        Note that this routine does not filter a dataframe on its</span>
<span class="sd">        contents. The filter is applied to the labels of the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        items : list-like</span>
<span class="sd">            Keep labels from axis which are in items.</span>
<span class="sd">        like : str</span>
<span class="sd">            Keep labels from axis for which &quot;like in label == True&quot;.</span>
<span class="sd">        regex : str (regular expression)</span>
<span class="sd">            Keep labels from axis for which re.search(regex, label) == True.</span>
<span class="sd">        axis : {0 or index, 1 or columns, None}, default None</span>
<span class="sd">            The axis to filter on, expressed either as an index (int)</span>
<span class="sd">            or axis name (str). By default this is the info axis, &#39;columns&#39; for</span>
<span class="sd">            DataFrame. For `Series` this parameter is unused and defaults to `None`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as input object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.loc : Access a group of rows and columns</span>
<span class="sd">            by label(s) or a boolean array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The ``items``, ``like``, and ``regex`` parameters are</span>
<span class="sd">        enforced to be mutually exclusive.</span>

<span class="sd">        ``axis`` defaults to the info axis that is used when indexing</span>
<span class="sd">        with ``[]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.array(([1, 2, 3], [4, 5, 6])),</span>
<span class="sd">        ...                   index=[&#39;mouse&#39;, &#39;rabbit&#39;],</span>
<span class="sd">        ...                   columns=[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                one  two  three</span>
<span class="sd">        mouse     1    2      3</span>
<span class="sd">        rabbit    4    5      6</span>

<span class="sd">        &gt;&gt;&gt; # select columns by name</span>
<span class="sd">        &gt;&gt;&gt; df.filter(items=[&#39;one&#39;, &#39;three&#39;])</span>
<span class="sd">                 one  three</span>
<span class="sd">        mouse     1      3</span>
<span class="sd">        rabbit    4      6</span>

<span class="sd">        &gt;&gt;&gt; # select columns by regular expression</span>
<span class="sd">        &gt;&gt;&gt; df.filter(regex=&#39;e$&#39;, axis=1)</span>
<span class="sd">                 one  three</span>
<span class="sd">        mouse     1      3</span>
<span class="sd">        rabbit    4      6</span>

<span class="sd">        &gt;&gt;&gt; # select rows containing &#39;bbi&#39;</span>
<span class="sd">        &gt;&gt;&gt; df.filter(like=&#39;bbi&#39;, axis=0)</span>
<span class="sd">                 one  two  three</span>
<span class="sd">        rabbit    4    5      6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nkw</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">count_not_none</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">like</span><span class="p">,</span> <span class="n">regex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nkw</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Keyword arguments `items`, `like`, or `regex` &quot;</span>
                <span class="s2">&quot;are mutually exclusive&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">items</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="c1"># error: Keywords must be strings</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>  <span class="c1"># type: ignore[misc]</span>
                <span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">items</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]}</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">like</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">like</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># needed for mypy</span>
                <span class="k">return</span> <span class="n">like</span> <span class="ow">in</span> <span class="n">ensure_str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">values</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">values</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">regex</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">matcher</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">ensure_str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="n">matcher</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">values</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must pass either `items`, `like`, or `regex`&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first `n` rows.</span>

<span class="sd">        This function returns the first `n` rows for the object based</span>
<span class="sd">        on position. It is useful for quickly testing if your object</span>
<span class="sd">        has the right type of data in it.</span>

<span class="sd">        For negative values of `n`, this function returns all rows except</span>
<span class="sd">        the last `|n|` rows, equivalent to ``df[:n]``.</span>

<span class="sd">        If n is larger than the number of rows, this function returns all rows.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, default 5</span>
<span class="sd">            Number of rows to select.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as caller</span>
<span class="sd">            The first `n` rows of the caller object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.tail: Returns the last `n` rows.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;animal&#39;: [&#39;alligator&#39;, &#39;bee&#39;, &#39;falcon&#39;, &#39;lion&#39;,</span>
<span class="sd">        ...                    &#39;monkey&#39;, &#39;parrot&#39;, &#39;shark&#39;, &#39;whale&#39;, &#39;zebra&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">              animal</span>
<span class="sd">        0  alligator</span>
<span class="sd">        1        bee</span>
<span class="sd">        2     falcon</span>
<span class="sd">        3       lion</span>
<span class="sd">        4     monkey</span>
<span class="sd">        5     parrot</span>
<span class="sd">        6      shark</span>
<span class="sd">        7      whale</span>
<span class="sd">        8      zebra</span>

<span class="sd">        Viewing the first 5 lines</span>

<span class="sd">        &gt;&gt;&gt; df.head()</span>
<span class="sd">              animal</span>
<span class="sd">        0  alligator</span>
<span class="sd">        1        bee</span>
<span class="sd">        2     falcon</span>
<span class="sd">        3       lion</span>
<span class="sd">        4     monkey</span>

<span class="sd">        Viewing the first `n` lines (three in this case)</span>

<span class="sd">        &gt;&gt;&gt; df.head(3)</span>
<span class="sd">              animal</span>
<span class="sd">        0  alligator</span>
<span class="sd">        1        bee</span>
<span class="sd">        2     falcon</span>

<span class="sd">        For negative values of `n`</span>

<span class="sd">        &gt;&gt;&gt; df.head(-3)</span>
<span class="sd">              animal</span>
<span class="sd">        0  alligator</span>
<span class="sd">        1        bee</span>
<span class="sd">        2     falcon</span>
<span class="sd">        3       lion</span>
<span class="sd">        4     monkey</span>
<span class="sd">        5     parrot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last `n` rows.</span>

<span class="sd">        This function returns last `n` rows from the object based on</span>
<span class="sd">        position. It is useful for quickly verifying data, for example,</span>
<span class="sd">        after sorting or appending rows.</span>

<span class="sd">        For negative values of `n`, this function returns all rows except</span>
<span class="sd">        the first `|n|` rows, equivalent to ``df[|n|:]``.</span>

<span class="sd">        If n is larger than the number of rows, this function returns all rows.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, default 5</span>
<span class="sd">            Number of rows to select.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type of caller</span>
<span class="sd">            The last `n` rows of the caller object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.head : The first `n` rows of the caller object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;animal&#39;: [&#39;alligator&#39;, &#39;bee&#39;, &#39;falcon&#39;, &#39;lion&#39;,</span>
<span class="sd">        ...                    &#39;monkey&#39;, &#39;parrot&#39;, &#39;shark&#39;, &#39;whale&#39;, &#39;zebra&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">              animal</span>
<span class="sd">        0  alligator</span>
<span class="sd">        1        bee</span>
<span class="sd">        2     falcon</span>
<span class="sd">        3       lion</span>
<span class="sd">        4     monkey</span>
<span class="sd">        5     parrot</span>
<span class="sd">        6      shark</span>
<span class="sd">        7      whale</span>
<span class="sd">        8      zebra</span>

<span class="sd">        Viewing the last 5 lines</span>

<span class="sd">        &gt;&gt;&gt; df.tail()</span>
<span class="sd">           animal</span>
<span class="sd">        4  monkey</span>
<span class="sd">        5  parrot</span>
<span class="sd">        6   shark</span>
<span class="sd">        7   whale</span>
<span class="sd">        8   zebra</span>

<span class="sd">        Viewing the last `n` lines (three in this case)</span>

<span class="sd">        &gt;&gt;&gt; df.tail(3)</span>
<span class="sd">          animal</span>
<span class="sd">        6  shark</span>
<span class="sd">        7  whale</span>
<span class="sd">        8  zebra</span>

<span class="sd">        For negative values of `n`</span>

<span class="sd">        &gt;&gt;&gt; df.tail(-3)</span>
<span class="sd">           animal</span>
<span class="sd">        3    lion</span>
<span class="sd">        4  monkey</span>
<span class="sd">        5  parrot</span>
<span class="sd">        6   shark</span>
<span class="sd">        7   whale</span>
<span class="sd">        8   zebra</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">frac</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="n">RandomState</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random sample of items from an axis of object.</span>

<span class="sd">        You can use `random_state` for reproducibility.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, optional</span>
<span class="sd">            Number of items from axis to return. Cannot be used with `frac`.</span>
<span class="sd">            Default = 1 if `frac` = None.</span>
<span class="sd">        frac : float, optional</span>
<span class="sd">            Fraction of axis items to return. Cannot be used with `n`.</span>
<span class="sd">        replace : bool, default False</span>
<span class="sd">            Allow or disallow sampling of the same row more than once.</span>
<span class="sd">        weights : str or ndarray-like, optional</span>
<span class="sd">            Default &#39;None&#39; results in equal probability weighting.</span>
<span class="sd">            If passed a Series, will align with target object on index. Index</span>
<span class="sd">            values in weights not found in sampled object will be ignored and</span>
<span class="sd">            index values in sampled object not in weights will be assigned</span>
<span class="sd">            weights of zero.</span>
<span class="sd">            If called on a DataFrame, will accept the name of a column</span>
<span class="sd">            when axis = 0.</span>
<span class="sd">            Unless weights are a Series, weights must be same length as axis</span>
<span class="sd">            being sampled.</span>
<span class="sd">            If weights do not sum to 1, they will be normalized to sum to 1.</span>
<span class="sd">            Missing values in the weights column will be treated as zero.</span>
<span class="sd">            Infinite values not allowed.</span>
<span class="sd">        random_state : int, array-like, BitGenerator, np.random.RandomState, np.random.Generator, optional</span>
<span class="sd">            If int, array-like, or BitGenerator, seed for random number generator.</span>
<span class="sd">            If np.random.RandomState or np.random.Generator, use as given.</span>

<span class="sd">            .. versionchanged:: 1.1.0</span>

<span class="sd">                array-like and BitGenerator object now passed to np.random.RandomState()</span>
<span class="sd">                as seed</span>

<span class="sd">            .. versionchanged:: 1.4.0</span>

<span class="sd">                np.random.Generator objects now accepted</span>

<span class="sd">        axis : {0 or index, 1 or columns, None}, default None</span>
<span class="sd">            Axis to sample. Accepts axis number or name. Default is stat axis</span>
<span class="sd">            for given data type. For `Series` this parameter is unused and defaults to `None`.</span>
<span class="sd">        ignore_index : bool, default False</span>
<span class="sd">            If True, the resulting index will be labeled 0, 1, , n - 1.</span>

<span class="sd">            .. versionadded:: 1.3.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            A new object of same type as caller containing `n` items randomly</span>
<span class="sd">            sampled from the caller object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrameGroupBy.sample: Generates random samples from each group of a</span>
<span class="sd">            DataFrame object.</span>
<span class="sd">        SeriesGroupBy.sample: Generates random samples from each group of a</span>
<span class="sd">            Series object.</span>
<span class="sd">        numpy.random.choice: Generates a random sample from a given 1-D numpy</span>
<span class="sd">            array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `frac` &gt; 1, `replacement` should be set to `True`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;num_legs&#39;: [2, 4, 8, 0],</span>
<span class="sd">        ...                    &#39;num_wings&#39;: [2, 0, 0, 0],</span>
<span class="sd">        ...                    &#39;num_specimen_seen&#39;: [10, 2, 1, 8]},</span>
<span class="sd">        ...                   index=[&#39;falcon&#39;, &#39;dog&#39;, &#39;spider&#39;, &#39;fish&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs  num_wings  num_specimen_seen</span>
<span class="sd">        falcon         2          2                 10</span>
<span class="sd">        dog            4          0                  2</span>
<span class="sd">        spider         8          0                  1</span>
<span class="sd">        fish           0          0                  8</span>

<span class="sd">        Extract 3 random elements from the ``Series`` ``df[&#39;num_legs&#39;]``:</span>
<span class="sd">        Note that we use `random_state` to ensure the reproducibility of</span>
<span class="sd">        the examples.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;num_legs&#39;].sample(n=3, random_state=1)</span>
<span class="sd">        fish      0</span>
<span class="sd">        spider    8</span>
<span class="sd">        falcon    2</span>
<span class="sd">        Name: num_legs, dtype: int64</span>

<span class="sd">        A random 50% sample of the ``DataFrame`` with replacement:</span>

<span class="sd">        &gt;&gt;&gt; df.sample(frac=0.5, replace=True, random_state=1)</span>
<span class="sd">              num_legs  num_wings  num_specimen_seen</span>
<span class="sd">        dog          4          0                  2</span>
<span class="sd">        fish         0          0                  8</span>

<span class="sd">        An upsample sample of the ``DataFrame`` with replacement:</span>
<span class="sd">        Note that `replace` parameter has to be `True` for `frac` parameter &gt; 1.</span>

<span class="sd">        &gt;&gt;&gt; df.sample(frac=2, replace=True, random_state=1)</span>
<span class="sd">                num_legs  num_wings  num_specimen_seen</span>
<span class="sd">        dog            4          0                  2</span>
<span class="sd">        fish           0          0                  8</span>
<span class="sd">        falcon         2          2                 10</span>
<span class="sd">        falcon         2          2                 10</span>
<span class="sd">        fish           0          0                  8</span>
<span class="sd">        dog            4          0                  2</span>
<span class="sd">        fish           0          0                  8</span>
<span class="sd">        dog            4          0                  2</span>

<span class="sd">        Using a DataFrame column as weights. Rows with larger value in the</span>
<span class="sd">        `num_specimen_seen` column are more likely to be sampled.</span>

<span class="sd">        &gt;&gt;&gt; df.sample(n=2, weights=&#39;num_specimen_seen&#39;, random_state=1)</span>
<span class="sd">                num_legs  num_wings  num_specimen_seen</span>
<span class="sd">        falcon         2          2                 10</span>
<span class="sd">        fish           0          0                  8</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa:E501</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">obj_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

        <span class="c1"># Process random_state argument</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="n">size</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">process_sampling_size</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">frac</span> <span class="o">*</span> <span class="n">obj_len</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">preprocess_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">sampled_indices</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">obj_len</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">replace</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">rs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">sampled_indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">T</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">T</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply chainable functions that expect Series or DataFrames.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Function to apply to the {klass}.</span>
<span class="sd">            ``args``, and ``kwargs`` are passed into ``func``.</span>
<span class="sd">            Alternatively a ``(callable, data_keyword)`` tuple where</span>
<span class="sd">            ``data_keyword`` is a string indicating the keyword of</span>
<span class="sd">            ``callable`` that expects the {klass}.</span>
<span class="sd">        args : iterable, optional</span>
<span class="sd">            Positional arguments passed into ``func``.</span>
<span class="sd">        kwargs : mapping, optional</span>
<span class="sd">            A dictionary of keyword arguments passed into ``func``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the return type of ``func``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.apply : Apply a function along input axis of DataFrame.</span>
<span class="sd">        DataFrame.applymap : Apply a function elementwise on a whole DataFrame.</span>
<span class="sd">        Series.map : Apply a mapping correspondence on a</span>
<span class="sd">            :class:`~pandas.Series`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Use ``.pipe`` when chaining together functions that expect</span>
<span class="sd">        Series, DataFrames or GroupBy objects. Instead of writing</span>

<span class="sd">        &gt;&gt;&gt; func(g(h(df), arg1=a), arg2=b, arg3=c)  # doctest: +SKIP</span>

<span class="sd">        You can write</span>

<span class="sd">        &gt;&gt;&gt; (df.pipe(h)</span>
<span class="sd">        ...    .pipe(g, arg1=a)</span>
<span class="sd">        ...    .pipe(func, arg2=b, arg3=c)</span>
<span class="sd">        ... )  # doctest: +SKIP</span>

<span class="sd">        If you have a function that takes the data as (say) the second</span>
<span class="sd">        argument, pass a tuple indicating which keyword expects the</span>
<span class="sd">        data. For example, suppose ``func`` takes its data as ``arg2``:</span>

<span class="sd">        &gt;&gt;&gt; (df.pipe(h)</span>
<span class="sd">        ...    .pipe(g, arg1=a)</span>
<span class="sd">        ...    .pipe((func, &#39;arg2&#39;), arg1=a, arg3=c)</span>
<span class="sd">        ...  )  # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">common</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">common</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Attribute access</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">__finalize__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Propagate metadata from other to self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : the object from which to get the attributes that we are going</span>
<span class="sd">            to propagate</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            A passed method name providing context on where ``__finalize__``</span>
<span class="sd">            was called.</span>

<span class="sd">            .. warning::</span>

<span class="sd">               The value passed as `method` are not currently considered</span>
<span class="sd">               stable across pandas releases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDFrame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">allows_duplicate_labels</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">allows_duplicate_labels</span>
            <span class="c1"># For subclasses using _metadata.</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_metadata</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;concat&quot;</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span>
            <span class="n">check_attrs</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">objs</span><span class="o">.</span><span class="n">attrs</span> <span class="o">==</span> <span class="n">attrs</span> <span class="k">for</span> <span class="n">objs</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">objs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">if</span> <span class="n">check_attrs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

            <span class="n">allows_duplicate_labels</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">allows_duplicate_labels</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">objs</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">allows_duplicate_labels</span> <span class="o">=</span> <span class="n">allows_duplicate_labels</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        After regular attribute access, try looking up the name</span>
<span class="sd">        This allows simpler access to columns for interactive use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: obj.x will always call obj.__getattribute__(&#39;x&#39;) prior to</span>
        <span class="c1"># calling obj.__getattr__(&#39;x&#39;).</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_names_set</span>
            <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span>
            <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accessors</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="o">.</span><span class="n">_can_hold_identifiers_and_holds_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        After regular attribute access, try setting the name</span>
<span class="sd">        This allows simpler access to columns for interactive use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first try regular attribute access via __getattribute__, so that</span>
        <span class="c1"># e.g. ``obj.x`` and ``obj.x = 4`` will always reference/modify</span>
        <span class="c1"># the same attribute.</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># if this fails, go on to more involved attribute setting</span>
        <span class="c1"># (note that this matches __getattr__, above).</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_names_set</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">existing</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                    <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Pandas doesn&#39;t allow columns to be &quot;</span>
                        <span class="s2">&quot;created via a new attribute name - see &quot;</span>
                        <span class="s2">&quot;https://pandas.pydata.org/pandas-docs/&quot;</span>
                        <span class="s2">&quot;stable/indexing.html#attribute-access&quot;</span><span class="p">,</span>
                        <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
                    <span class="p">)</span>
                <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_dir_additions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add the string-like attributes from the info_axis.</span>
<span class="sd">        If info_axis is a MultiIndex, its first level values are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">additions</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_dir_additions</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="o">.</span><span class="n">_can_hold_strings</span><span class="p">:</span>
            <span class="n">additions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="o">.</span><span class="n">_dir_additions_for_owner</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">additions</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Consolidation of internals</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_protect_consolidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Consolidate _mgr -- if the blocks have changed, then clear the</span>
<span class="sd">        cache</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">,</span> <span class="p">(</span><span class="n">ArrayManager</span><span class="p">,</span> <span class="n">SingleArrayManager</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">()</span>
        <span class="n">blocks_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blocks_before</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_consolidate_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Consolidate data in place and return None&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">consolidate</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_consolidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute NDFrame with &quot;consolidated&quot; internals (data of each dtype</span>
<span class="sd">        grouped together in a single ndarray).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        consolidated : same type as caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">consolidate</span><span class="p">()</span>
        <span class="n">cons_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">cons_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">is_single_block</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">any_extension_types</span><span class="p">:</span>
            <span class="c1"># Even if they have the same dtype, we can&#39;t consolidate them,</span>
            <span class="c1">#  so we pretend this is &quot;mixed&#39;&quot;</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_check_inplace_setting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;check whether we allow in-place setting with this type of value&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">is_numeric_mixed_type</span><span class="p">:</span>
            <span class="c1"># allow an actual np.nan through</span>
            <span class="k">if</span> <span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot do inplace boolean setting on &quot;</span>
                <span class="s2">&quot;mixed-types with a non np.nan value&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_numeric_data</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">get_numeric_data</span><span class="p">())</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_bool_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">get_bool_data</span><span class="p">())</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Internal Interface Methods</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;internal implementation&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dtypes in the DataFrame.</span>

<span class="sd">        This returns a Series with the data type of each column.</span>
<span class="sd">        The result&#39;s index is the original DataFrame&#39;s columns. Columns</span>
<span class="sd">        with mixed types are stored with the ``object`` dtype. See</span>
<span class="sd">        :ref:`the User Guide &lt;basics.dtypes&gt;` for more.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            The data type of each column.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;float&#39;: [1.0],</span>
<span class="sd">        ...                    &#39;int&#39;: [1],</span>
<span class="sd">        ...                    &#39;datetime&#39;: [pd.Timestamp(&#39;20180310&#39;)],</span>
<span class="sd">        ...                    &#39;string&#39;: [&#39;foo&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        float              float64</span>
<span class="sd">        int                  int64</span>
<span class="sd">        datetime    datetime64[ns]</span>
<span class="sd">        string              object</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">get_dtypes</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast a pandas object to a specified dtype ``dtype``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str, data type, Series or Mapping of column name -&gt; data type</span>
<span class="sd">            Use a str, numpy.dtype, pandas.ExtensionDtype or Python type to</span>
<span class="sd">            cast entire pandas object to the same type. Alternatively, use a</span>
<span class="sd">            mapping, e.g. {col: dtype, ...}, where col is a column label and dtype is</span>
<span class="sd">            a numpy.dtype or Python type to cast one or more of the DataFrame&#39;s</span>
<span class="sd">            columns to column-specific types.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Return a copy when ``copy=True`` (be very careful setting</span>
<span class="sd">            ``copy=False`` as changes to values then may propagate to other</span>
<span class="sd">            pandas objects).</span>
<span class="sd">        errors : {&#39;raise&#39;, &#39;ignore&#39;}, default &#39;raise&#39;</span>
<span class="sd">            Control raising of exceptions on invalid data for provided dtype.</span>

<span class="sd">            - ``raise`` : allow exceptions to be raised</span>
<span class="sd">            - ``ignore`` : suppress exceptions. On error return original object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as caller</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_datetime : Convert argument to datetime.</span>
<span class="sd">        to_timedelta : Convert argument to timedelta.</span>
<span class="sd">        to_numeric : Convert argument to a numeric type.</span>
<span class="sd">        numpy.ndarray.astype : Cast a numpy array to a specified type.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionchanged:: 2.0.0</span>

<span class="sd">            Using ``astype`` to convert from timezone-naive dtype to</span>
<span class="sd">            timezone-aware dtype will raise an exception.</span>
<span class="sd">            Use :meth:`Series.dt.tz_localize` instead.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a DataFrame:</span>

<span class="sd">        &gt;&gt;&gt; d = {&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data=d)</span>
<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        col1    int64</span>
<span class="sd">        col2    int64</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Cast all columns to int32:</span>

<span class="sd">        &gt;&gt;&gt; df.astype(&#39;int32&#39;).dtypes</span>
<span class="sd">        col1    int32</span>
<span class="sd">        col2    int32</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Cast col1 to int32 using a dictionary:</span>

<span class="sd">        &gt;&gt;&gt; df.astype({&#39;col1&#39;: &#39;int32&#39;}).dtypes</span>
<span class="sd">        col1    int32</span>
<span class="sd">        col2    int64</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Create a series:</span>

<span class="sd">        &gt;&gt;&gt; ser = pd.Series([1, 2], dtype=&#39;int32&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ser</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &gt;&gt;&gt; ser.astype(&#39;int64&#39;)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Convert to categorical type:</span>

<span class="sd">        &gt;&gt;&gt; ser.astype(&#39;category&#39;)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: category</span>
<span class="sd">        Categories (2, int32): [1, 2]</span>

<span class="sd">        Convert to ordered categorical type with custom ordering:</span>

<span class="sd">        &gt;&gt;&gt; from pandas.api.types import CategoricalDtype</span>
<span class="sd">        &gt;&gt;&gt; cat_dtype = CategoricalDtype(</span>
<span class="sd">        ...     categories=[2, 1], ordered=True)</span>
<span class="sd">        &gt;&gt;&gt; ser.astype(cat_dtype)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: category</span>
<span class="sd">        Categories (2, int64): [2 &lt; 1]</span>

<span class="sd">        Create a series of dates:</span>

<span class="sd">        &gt;&gt;&gt; ser_date = pd.Series(pd.date_range(&#39;20200101&#39;, periods=3))</span>
<span class="sd">        &gt;&gt;&gt; ser_date</span>
<span class="sd">        0   2020-01-01</span>
<span class="sd">        1   2020-01-02</span>
<span class="sd">        2   2020-01-03</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># i.e. Series</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dtype</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="s2">&quot;Only the Series name can be used for &quot;</span>
                        <span class="s2">&quot;the key in Series dtype mappings.&quot;</span>
                    <span class="p">)</span>
                <span class="n">new_type</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>

            <span class="c1"># GH#44417 cast to Series so we can use .iat below, which will be</span>
            <span class="c1">#  robust in case we</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

            <span class="n">dtype_ser</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">dtype_ser</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="s2">&quot;Only a column name can be used for the &quot;</span>
                        <span class="s2">&quot;key in a dtype mappings argument. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">col_name</span><span class="si">}</span><span class="s2">&#39; not found in columns.&quot;</span>
                    <span class="p">)</span>

            <span class="n">dtype_ser</span> <span class="o">=</span> <span class="n">dtype_ser</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">cdt</span> <span class="o">=</span> <span class="n">dtype_ser</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">isna</span><span class="p">(</span><span class="n">cdt</span><span class="p">):</span>
                    <span class="n">res_col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">res_col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">cdt</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                        <span class="n">ex</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ex</span><span class="si">}</span><span class="s2">: Error while type casting for column &#39;</span><span class="si">{</span><span class="n">col_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">raise</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_col</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># GH 18099/22869: columnwise conversion to extension dtype</span>
            <span class="c1"># GH 24704: use iloc to handle duplicate column names</span>
            <span class="c1"># TODO(EA2D): special case not needed with 2D EAs</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
            <span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># else, only a single dtype is given</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;astype&quot;</span><span class="p">)</span>

        <span class="c1"># GH 33113: handle empty frame or series</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># GH 19920: retain column metadata after concat</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># GH#40810 retain subclass</span>
        <span class="c1"># error: Incompatible types in assignment</span>
        <span class="c1"># (expression has type &quot;NDFrameT&quot;, variable has type &quot;DataFrame&quot;)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;astype&quot;</span><span class="p">)</span>
        <span class="c1"># https://github.com/python/mypy/issues/8354</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">NDFrameT</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this object&#39;s indices and data.</span>

<span class="sd">        When ``deep=True`` (default), a new object will be created with a</span>
<span class="sd">        copy of the calling object&#39;s data and indices. Modifications to</span>
<span class="sd">        the data or indices of the copy will not be reflected in the</span>
<span class="sd">        original object (see notes below).</span>

<span class="sd">        When ``deep=False``, a new object will be created without copying</span>
<span class="sd">        the calling object&#39;s data or index (only references to the data</span>
<span class="sd">        and index are copied). Any changes to the data of the original</span>
<span class="sd">        will be reflected in the shallow copy (and vice versa).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, default True</span>
<span class="sd">            Make a deep copy, including a copy of the data and the indices.</span>
<span class="sd">            With ``deep=False`` neither the indices nor the data are copied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Object type matches caller.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When ``deep=True``, data is copied but actual Python objects</span>
<span class="sd">        will not be copied recursively, only the reference to the object.</span>
<span class="sd">        This is in contrast to `copy.deepcopy` in the Standard Library,</span>
<span class="sd">        which recursively copies object data (see examples below).</span>

<span class="sd">        While ``Index`` objects are copied when ``deep=True``, the underlying</span>
<span class="sd">        numpy array is not copied for performance reasons. Since ``Index`` is</span>
<span class="sd">        immutable, the underlying data can be safely shared and a copy</span>
<span class="sd">        is not needed.</span>

<span class="sd">        Since pandas is not thread safe, see the</span>
<span class="sd">        :ref:`gotchas &lt;gotchas.thread-safety&gt;` when copying in a threading</span>
<span class="sd">        environment.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2], index=[&quot;a&quot;, &quot;b&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        a    1</span>
<span class="sd">        b    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s_copy = s.copy()</span>
<span class="sd">        &gt;&gt;&gt; s_copy</span>
<span class="sd">        a    1</span>
<span class="sd">        b    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        **Shallow copy versus default (deep) copy:**</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2], index=[&quot;a&quot;, &quot;b&quot;])</span>
<span class="sd">        &gt;&gt;&gt; deep = s.copy()</span>
<span class="sd">        &gt;&gt;&gt; shallow = s.copy(deep=False)</span>

<span class="sd">        Shallow copy shares data and index with original.</span>

<span class="sd">        &gt;&gt;&gt; s is shallow</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; s.values is shallow.values and s.index is shallow.index</span>
<span class="sd">        True</span>

<span class="sd">        Deep copy has own copy of data and index.</span>

<span class="sd">        &gt;&gt;&gt; s is deep</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; s.values is deep.values or s.index is deep.index</span>
<span class="sd">        False</span>

<span class="sd">        Updates to the data shared by shallow copy and original is reflected</span>
<span class="sd">        in both; deep copy remains unchanged.</span>

<span class="sd">        &gt;&gt;&gt; s[0] = 3</span>
<span class="sd">        &gt;&gt;&gt; shallow[1] = 4</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        a    3</span>
<span class="sd">        b    4</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; shallow</span>
<span class="sd">        a    3</span>
<span class="sd">        b    4</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; deep</span>
<span class="sd">        a    1</span>
<span class="sd">        b    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Note that when copying an object containing Python objects, a deep copy</span>
<span class="sd">        will copy the data, but will not do so recursively. Updating a nested</span>
<span class="sd">        data object will be reflected in the deep copy.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; deep = s.copy()</span>
<span class="sd">        &gt;&gt;&gt; s[0][0] = 10</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    [10, 2]</span>
<span class="sd">        1     [3, 4]</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; deep</span>
<span class="sd">        0    [10, 2]</span>
<span class="sd">        1     [3, 4]</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;copy&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        memo, default None</span>
<span class="sd">            Standard signature. Unused</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">infer_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to infer better dtypes for object columns.</span>

<span class="sd">        Attempts soft conversion of object-dtyped</span>
<span class="sd">        columns, leaving non-object and unconvertible</span>
<span class="sd">        columns unchanged. The inference rules are the</span>
<span class="sd">        same as during normal Series/DataFrame construction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Whether to make a copy for non-object or non-inferrable columns</span>
<span class="sd">            or Series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as input object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_datetime : Convert argument to datetime.</span>
<span class="sd">        to_timedelta : Convert argument to timedelta.</span>
<span class="sd">        to_numeric : Convert argument to numeric type.</span>
<span class="sd">        convert_dtypes : Convert argument to best possible dtype.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [&quot;a&quot;, 1, 2, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df = df.iloc[1:]</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A</span>
<span class="sd">        1  1</span>
<span class="sd">        2  2</span>
<span class="sd">        3  3</span>

<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        A    object</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; df.infer_objects().dtypes</span>
<span class="sd">        A    int64</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_mgr</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;infer_objects&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">convert_dtypes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">infer_objects</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">convert_string</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">convert_integer</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">convert_boolean</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">convert_floating</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dtype_backend</span><span class="p">:</span> <span class="n">DtypeBackend</span> <span class="o">=</span> <span class="s2">&quot;numpy_nullable&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert columns to the best possible dtypes using dtypes supporting ``pd.NA``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        infer_objects : bool, default True</span>
<span class="sd">            Whether object dtypes should be converted to the best possible types.</span>
<span class="sd">        convert_string : bool, default True</span>
<span class="sd">            Whether object dtypes should be converted to ``StringDtype()``.</span>
<span class="sd">        convert_integer : bool, default True</span>
<span class="sd">            Whether, if possible, conversion can be done to integer extension types.</span>
<span class="sd">        convert_boolean : bool, defaults True</span>
<span class="sd">            Whether object dtypes should be converted to ``BooleanDtypes()``.</span>
<span class="sd">        convert_floating : bool, defaults True</span>
<span class="sd">            Whether, if possible, conversion can be done to floating extension types.</span>
<span class="sd">            If `convert_integer` is also True, preference will be give to integer</span>
<span class="sd">            dtypes if the floats can be faithfully casted to integers.</span>

<span class="sd">            .. versionadded:: 1.2.0</span>
<span class="sd">        dtype_backend : {&quot;numpy_nullable&quot;, &quot;pyarrow&quot;}, default &quot;numpy_nullable&quot;</span>
<span class="sd">            Which dtype_backend to use, e.g. whether a DataFrame should use nullable</span>
<span class="sd">            dtypes for all dtypes that have a nullable</span>
<span class="sd">            implementation when &quot;numpy_nullable&quot; is set, pyarrow is used for all</span>
<span class="sd">            dtypes if &quot;pyarrow&quot; is set.</span>

<span class="sd">            The dtype_backends are still experimential.</span>

<span class="sd">            .. versionadded:: 2.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Copy of input object with new dtype.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        infer_objects : Infer dtypes of objects.</span>
<span class="sd">        to_datetime : Convert argument to datetime.</span>
<span class="sd">        to_timedelta : Convert argument to timedelta.</span>
<span class="sd">        to_numeric : Convert argument to a numeric type.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        By default, ``convert_dtypes`` will attempt to convert a Series (or each</span>
<span class="sd">        Series in a DataFrame) to dtypes that support ``pd.NA``. By using the options</span>
<span class="sd">        ``convert_string``, ``convert_integer``, ``convert_boolean`` and</span>
<span class="sd">        ``convert_floating``, it is possible to turn off individual conversions</span>
<span class="sd">        to ``StringDtype``, the integer extension types, ``BooleanDtype``</span>
<span class="sd">        or floating extension types, respectively.</span>

<span class="sd">        For object-dtyped columns, if ``infer_objects`` is ``True``, use the inference</span>
<span class="sd">        rules as during normal Series/DataFrame construction.  Then, if possible,</span>
<span class="sd">        convert to ``StringDtype``, ``BooleanDtype`` or an appropriate integer</span>
<span class="sd">        or floating extension type, otherwise leave as ``object``.</span>

<span class="sd">        If the dtype is integer, convert to an appropriate integer extension type.</span>

<span class="sd">        If the dtype is numeric, and consists of all integers, convert to an</span>
<span class="sd">        appropriate integer extension type. Otherwise, convert to an</span>
<span class="sd">        appropriate floating extension type.</span>

<span class="sd">        .. versionchanged:: 1.2</span>
<span class="sd">            Starting with pandas 1.2, this method also converts float columns</span>
<span class="sd">            to the nullable floating extension type.</span>

<span class="sd">        In the future, as new dtypes are added that support ``pd.NA``, the results</span>
<span class="sd">        of this method will change to support those new dtypes.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;a&quot;: pd.Series([1, 2, 3], dtype=np.dtype(&quot;int32&quot;)),</span>
<span class="sd">        ...         &quot;b&quot;: pd.Series([&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], dtype=np.dtype(&quot;O&quot;)),</span>
<span class="sd">        ...         &quot;c&quot;: pd.Series([True, False, np.nan], dtype=np.dtype(&quot;O&quot;)),</span>
<span class="sd">        ...         &quot;d&quot;: pd.Series([&quot;h&quot;, &quot;i&quot;, np.nan], dtype=np.dtype(&quot;O&quot;)),</span>
<span class="sd">        ...         &quot;e&quot;: pd.Series([10, np.nan, 20], dtype=np.dtype(&quot;float&quot;)),</span>
<span class="sd">        ...         &quot;f&quot;: pd.Series([np.nan, 100.5, 200], dtype=np.dtype(&quot;float&quot;)),</span>
<span class="sd">        ...     }</span>
<span class="sd">        ... )</span>

<span class="sd">        Start with a DataFrame with default dtypes.</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           a  b      c    d     e      f</span>
<span class="sd">        0  1  x   True    h  10.0    NaN</span>
<span class="sd">        1  2  y  False    i   NaN  100.5</span>
<span class="sd">        2  3  z    NaN  NaN  20.0  200.0</span>

<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        a      int32</span>
<span class="sd">        b     object</span>
<span class="sd">        c     object</span>
<span class="sd">        d     object</span>
<span class="sd">        e    float64</span>
<span class="sd">        f    float64</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Convert the DataFrame to use best possible dtypes.</span>

<span class="sd">        &gt;&gt;&gt; dfn = df.convert_dtypes()</span>
<span class="sd">        &gt;&gt;&gt; dfn</span>
<span class="sd">           a  b      c     d     e      f</span>
<span class="sd">        0  1  x   True     h    10   &lt;NA&gt;</span>
<span class="sd">        1  2  y  False     i  &lt;NA&gt;  100.5</span>
<span class="sd">        2  3  z   &lt;NA&gt;  &lt;NA&gt;    20  200.0</span>

<span class="sd">        &gt;&gt;&gt; dfn.dtypes</span>
<span class="sd">        a             Int32</span>
<span class="sd">        b    string[python]</span>
<span class="sd">        c           boolean</span>
<span class="sd">        d    string[python]</span>
<span class="sd">        e             Int64</span>
<span class="sd">        f           Float64</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Start with a Series of strings and missing data represented by ``np.nan``.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&quot;a&quot;, &quot;b&quot;, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0      a</span>
<span class="sd">        1      b</span>
<span class="sd">        2    NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Obtain a Series with dtype ``StringDtype``.</span>

<span class="sd">        &gt;&gt;&gt; s.convert_dtypes()</span>
<span class="sd">        0       a</span>
<span class="sd">        1       b</span>
<span class="sd">        2    &lt;NA&gt;</span>
<span class="sd">        dtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_dtype_backend</span><span class="p">(</span><span class="n">dtype_backend</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dtypes</span><span class="p">(</span>
                <span class="n">infer_objects</span><span class="p">,</span>
                <span class="n">convert_string</span><span class="p">,</span>
                <span class="n">convert_integer</span><span class="p">,</span>
                <span class="n">convert_boolean</span><span class="p">,</span>
                <span class="n">convert_floating</span><span class="p">,</span>
                <span class="n">dtype_backend</span><span class="o">=</span><span class="n">dtype_backend</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">col</span><span class="o">.</span><span class="n">_convert_dtypes</span><span class="p">(</span>
                    <span class="n">infer_objects</span><span class="p">,</span>
                    <span class="n">convert_string</span><span class="p">,</span>
                    <span class="n">convert_integer</span><span class="p">,</span>
                    <span class="n">convert_boolean</span><span class="p">,</span>
                    <span class="n">convert_floating</span><span class="p">,</span>
                    <span class="n">dtype_backend</span><span class="o">=</span><span class="n">dtype_backend</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="n">cons</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Type</span><span class="p">[</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;convert_dtypes&quot;</span><span class="p">)</span>
                <span class="c1"># https://github.com/python/mypy/issues/8354</span>
                <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">NDFrameT</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Filling NA&#39;s</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NA/NaN values using the specified method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, dict, Series, or DataFrame</span>
<span class="sd">            Value to use to fill holes (e.g. 0), alternately a</span>
<span class="sd">            dict/Series/DataFrame of values specifying which value to use for</span>
<span class="sd">            each index (for a Series) or column (for a DataFrame).  Values not</span>
<span class="sd">            in the dict/Series/DataFrame will not be filled. This value cannot</span>
<span class="sd">            be a list.</span>
<span class="sd">        method : {{&#39;backfill&#39;, &#39;bfill&#39;, &#39;ffill&#39;, None}}, default None</span>
<span class="sd">            Method to use for filling holes in reindexed Series:</span>

<span class="sd">            * ffill: propagate last valid observation forward to next valid.</span>
<span class="sd">            * backfill / bfill: use next valid observation to fill gap.</span>

<span class="sd">        axis : {axes_single_arg}</span>
<span class="sd">            Axis along which to fill missing values. For `Series`</span>
<span class="sd">            this parameter is unused and defaults to 0.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, fill in-place. Note: this will modify any</span>
<span class="sd">            other views on this object (e.g., a no-copy slice for a column in a</span>
<span class="sd">            DataFrame).</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            If method is specified, this is the maximum number of consecutive</span>
<span class="sd">            NaN values to forward/backward fill. In other words, if there is</span>
<span class="sd">            a gap with more than this number of consecutive NaNs, it will only</span>
<span class="sd">            be partially filled. If method is not specified, this is the</span>
<span class="sd">            maximum number of entries along the entire axis where NaNs will be</span>
<span class="sd">            filled. Must be greater than 0 if not None.</span>
<span class="sd">        downcast : dict, default is None</span>
<span class="sd">            A dict of item-&gt;dtype of what to downcast if possible,</span>
<span class="sd">            or the string &#39;infer&#39; which will try to downcast to an appropriate</span>
<span class="sd">            equal type (e.g. float64 to int64 if possible).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass} or None</span>
<span class="sd">            Object with missing values filled or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        interpolate : Fill NaN values using interpolation.</span>
<span class="sd">        reindex : Conform object to new index.</span>
<span class="sd">        asfreq : Convert TimeSeries to specified frequency.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[np.nan, 2, np.nan, 0],</span>
<span class="sd">        ...                    [3, 4, np.nan, 1],</span>
<span class="sd">        ...                    [np.nan, np.nan, np.nan, np.nan],</span>
<span class="sd">        ...                    [np.nan, 3, np.nan, 4]],</span>
<span class="sd">        ...                   columns=list(&quot;ABCD&quot;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             A    B   C    D</span>
<span class="sd">        0  NaN  2.0 NaN  0.0</span>
<span class="sd">        1  3.0  4.0 NaN  1.0</span>
<span class="sd">        2  NaN  NaN NaN  NaN</span>
<span class="sd">        3  NaN  3.0 NaN  4.0</span>

<span class="sd">        Replace all NaN elements with 0s.</span>

<span class="sd">        &gt;&gt;&gt; df.fillna(0)</span>
<span class="sd">             A    B    C    D</span>
<span class="sd">        0  0.0  2.0  0.0  0.0</span>
<span class="sd">        1  3.0  4.0  0.0  1.0</span>
<span class="sd">        2  0.0  0.0  0.0  0.0</span>
<span class="sd">        3  0.0  3.0  0.0  4.0</span>

<span class="sd">        We can also propagate non-null values forward or backward.</span>

<span class="sd">        &gt;&gt;&gt; df.fillna(method=&quot;ffill&quot;)</span>
<span class="sd">             A    B   C    D</span>
<span class="sd">        0  NaN  2.0 NaN  0.0</span>
<span class="sd">        1  3.0  4.0 NaN  1.0</span>
<span class="sd">        2  3.0  4.0 NaN  1.0</span>
<span class="sd">        3  3.0  3.0 NaN  4.0</span>

<span class="sd">        Replace all NaN elements in column &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, and &#39;D&#39;, with 0, 1,</span>
<span class="sd">        2, and 3 respectively.</span>

<span class="sd">        &gt;&gt;&gt; values = {{&quot;A&quot;: 0, &quot;B&quot;: 1, &quot;C&quot;: 2, &quot;D&quot;: 3}}</span>
<span class="sd">        &gt;&gt;&gt; df.fillna(value=values)</span>
<span class="sd">             A    B    C    D</span>
<span class="sd">        0  0.0  2.0  2.0  0.0</span>
<span class="sd">        1  3.0  4.0  2.0  1.0</span>
<span class="sd">        2  0.0  1.0  2.0  3.0</span>
<span class="sd">        3  0.0  3.0  2.0  4.0</span>

<span class="sd">        Only replace the first NaN element.</span>

<span class="sd">        &gt;&gt;&gt; df.fillna(value=values, limit=1)</span>
<span class="sd">             A    B    C    D</span>
<span class="sd">        0  0.0  2.0  2.0  0.0</span>
<span class="sd">        1  3.0  4.0  NaN  1.0</span>
<span class="sd">        2  NaN  1.0  NaN  3.0</span>
<span class="sd">        3  NaN  3.0  NaN  4.0</span>

<span class="sd">        When filling using a DataFrame, replacement happens along</span>
<span class="sd">        the same column names and same indices</span>

<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame(np.zeros((4, 4)), columns=list(&quot;ABCE&quot;))</span>
<span class="sd">        &gt;&gt;&gt; df.fillna(df2)</span>
<span class="sd">             A    B    C    D</span>
<span class="sd">        0  0.0  2.0  0.0  0.0</span>
<span class="sd">        1  3.0  4.0  0.0  1.0</span>
<span class="sd">        2  0.0  0.0  0.0  NaN</span>
<span class="sd">        3  0.0  3.0  0.0  4.0</span>

<span class="sd">        Note that column D is not affected since it is not present in df2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">validate_fillna_kwargs</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

        <span class="c1"># set the default here, so functions examining the signaure</span>
        <span class="c1"># can detect if something was set (e.g. in groupby) (GH9221)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">is_single_block</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                <span class="k">return</span> <span class="n">result</span>

            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="c1"># test_fillna_nonscalar</span>
                        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">None</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

                    <span class="n">value</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_values</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;&quot;value&quot; parameter must be a scalar, dict &#39;</span>
                        <span class="s2">&quot;or Series, but you passed a &quot;</span>
                        <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
                    <span class="p">)</span>

                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;Currently only can fill &quot;</span>
                        <span class="s2">&quot;with dict/Series column &quot;</span>
                        <span class="s2">&quot;by column&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">is_dict</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">downcast</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># error: Item &quot;None&quot; of &quot;Optional[Dict[Any, Any]]&quot; has no</span>
                    <span class="c1"># attribute &quot;get&quot;</span>
                    <span class="n">downcast_k</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">downcast</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict</span>
                        <span class="k">else</span> <span class="n">downcast</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
                    <span class="p">)</span>

                    <span class="n">res_k</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast_k</span><span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_k</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># We can write into our existing column(s) iff dtype</span>
                        <span class="c1">#  was preserved.</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res_k</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
                            <span class="c1"># i.e. &#39;k&#39; only shows up once in self.columns</span>
                            <span class="k">if</span> <span class="n">res_k</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                                <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_k</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Different dtype -&gt; no way to do inplace.</span>
                                <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_k</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># see test_fillna_dict_inplace_nonunique_columns</span>
                            <span class="n">locs</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                                <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="n">locs</span><span class="p">]</span>
                            <span class="k">elif</span> <span class="p">(</span>
                                <span class="nb">isinstance</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">locs</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span>
                            <span class="p">):</span>
                                <span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span>
                                <span class="nb">isinstance</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">locs</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span>
                            <span class="p">):</span>
                                <span class="c1"># Should never be reached, but let&#39;s cover our bases</span>
                                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                                    <span class="s2">&quot;Unexpected get_loc result, please report a bug at &quot;</span>
                                    <span class="s2">&quot;https://github.com/pandas-dev/pandas&quot;</span>
                                <span class="p">)</span>

                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">locs</span><span class="p">):</span>
                                <span class="n">res_loc</span> <span class="o">=</span> <span class="n">res_k</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                                <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">loc</span><span class="p">]</span>

                                <span class="k">if</span> <span class="n">res_loc</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                                    <span class="n">result</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_loc</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">result</span><span class="o">.</span><span class="n">isetitem</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">res_loc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                    <span class="n">new_data</span> <span class="o">=</span> <span class="n">result</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notna</span><span class="p">(),</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">_mgr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid fill value with a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fillna&quot;</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synonym for :meth:`DataFrame.fillna` with ``method=&#39;ffill&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass} or None</span>
<span class="sd">            Object with missing values filled or None if ``inplace=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span>
        <span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synonym for :meth:`DataFrame.fillna` with ``method=&#39;ffill&#39;``.</span>

<span class="sd">        .. deprecated:: 2.0</span>

<span class="sd">            {klass}.pad is deprecated. Use {klass}.ffill instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass} or None</span>
<span class="sd">            Object with missing values filled or None if ``inplace=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;DataFrame.pad/Series.pad is deprecated. Use &quot;</span>
            <span class="s2">&quot;DataFrame.ffill/Series.ffill instead&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synonym for :meth:`DataFrame.fillna` with ``method=&#39;bfill&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass} or None</span>
<span class="sd">            Object with missing values filled or None if ``inplace=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bfill&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span>
        <span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">backfill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synonym for :meth:`DataFrame.fillna` with ``method=&#39;bfill&#39;``.</span>

<span class="sd">        .. deprecated:: 2.0</span>

<span class="sd">            {klass}.backfill is deprecated. Use {klass}.bfill instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass} or None</span>
<span class="sd">            Object with missing values filled or None if ``inplace=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;DataFrame.backfill/Series.backfill is deprecated. Use &quot;</span>
            <span class="s2">&quot;DataFrame.bfill/Series.bfill instead&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">to_replace</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">to_replace</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">to_replace</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;replace&quot;</span><span class="p">],</span>
        <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">],</span>
        <span class="n">inplace</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;inplace&quot;</span><span class="p">],</span>
        <span class="n">replace_iloc</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;replace_iloc&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">to_replace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">is_scalar</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_re_compilable</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Expecting &#39;to_replace&#39; to be either a scalar, array-like, &quot;</span>
                <span class="s2">&quot;dict or None, got invalid type &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">to_replace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;to_replace&#39; must be &#39;None&#39; if &#39;regex&#39; is not a bool&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span> <span class="ow">or</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="c1"># GH#36984 if the user explicitly passes value=None we want to</span>
            <span class="c1">#  respect that. We have the corner case where the user explicitly</span>
            <span class="c1">#  passes value=None *and* a method, which we interpret as meaning</span>
            <span class="c1">#  they want the (documented) default behavior.</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
                <span class="c1"># TODO: get this to show up as the default in the docs?</span>
                <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;pad&quot;</span>

            <span class="c1"># passing a single value that is scalar like</span>
            <span class="c1"># when value is None (GH5319), for compat</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">regex</span><span class="p">):</span>
                <span class="n">to_replace</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_replace</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="c1"># TODO: Consider copy-on-write for non-replaced columns&#39;s here</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                        <span class="n">Series</span><span class="o">.</span><span class="n">_replace_single</span><span class="p">,</span>
                        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="k">return</span> <span class="n">result</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_single</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">regex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;If &quot;to_replace&quot; and &quot;value&quot; are both None &#39;</span>
                        <span class="s1">&#39;and &quot;to_replace&quot; is not a list, then &#39;</span>
                        <span class="s2">&quot;regex must be a mapping&quot;</span>
                    <span class="p">)</span>
                <span class="n">to_replace</span> <span class="o">=</span> <span class="n">regex</span>
                <span class="n">regex</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_replace</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">items</span><span class="p">:</span>
                <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>

            <span class="n">are_mappings</span> <span class="o">=</span> <span class="p">[</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">are_mappings</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">are_mappings</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;If a nested mapping is passed, all values &quot;</span>
                        <span class="s2">&quot;of the top level mapping must be mappings&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># passed a nested dict/Series</span>
                <span class="n">to_rep_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">value_dict</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="ow">or</span> <span class="p">([],</span> <span class="p">[])</span>

                    <span class="n">to_rep_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
                    <span class="n">value_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

                <span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">to_rep_dict</span><span class="p">,</span> <span class="n">value_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need a non-zero len on all axes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># {&#39;A&#39; : NA} -&gt; {&#39;A&#39; : 0}</span>
                    <span class="c1"># Note: Checking below for `in foo.keys()` instead of</span>
                    <span class="c1">#  `in foo` is needed for when we have a Series and not dict</span>
                    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">to_replace</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">to_replace</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span>
                    <span class="p">}</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_columnwise</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">regex</span><span class="p">)</span>

                <span class="c1"># {&#39;A&#39;: NA} -&gt; 0</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="c1"># Operate column-wise</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Series.replace cannot use dict-like to_replace &quot;</span>
                            <span class="s2">&quot;and non-None value&quot;</span>
                        <span class="p">)</span>
                    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">to_rep</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">to_rep</span> <span class="ow">in</span> <span class="n">to_replace</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="p">}</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_columnwise</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">regex</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;value argument must be scalar, dict, or Series&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="c1"># e.g. to_replace = [NA, &#39;&#39;] and value is 0,</span>
                    <span class="c1">#  so we replace NA with 0 and then replace &#39;&#39; with 0</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span>

                <span class="c1"># e.g. we have to_replace = [NA, &#39;&#39;] and value = [0, &#39;missing&#39;]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Replacement lists must match in length. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Expecting </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span><span class="si">}</span><span class="s2"> got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="p">)</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">replace_list</span><span class="p">(</span>
                    <span class="n">src_list</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                    <span class="n">dest_list</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                    <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">to_replace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">is_re_compilable</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;&#39;regex&#39; must be a string or a compiled regular expression &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;or a list or dict of strings or regular expressions, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;you passed a </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="n">regex</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># dest iterable dict-like</span>
                <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># NA -&gt; {&#39;A&#39; : 0, &#39;B&#39; : -1}</span>
                    <span class="c1"># Operate column-wise</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Series.replace cannot use dict-value and &quot;</span>
                            <span class="s2">&quot;non-None to_replace&quot;</span>
                        <span class="p">)</span>
                    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_columnwise</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">regex</span><span class="p">)</span>

                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># NA -&gt; 0</span>
                    <span class="n">regex</span> <span class="o">=</span> <span class="n">should_use_regex</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">regex</span><span class="p">:</span>
                        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">replace_regex</span><span class="p">(</span>
                            <span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Invalid &quot;to_replace&quot; type: </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;replace&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit_direction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit_area</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NaN values using an interpolation method.</span>

<span class="sd">        Please note that only ``method=&#39;linear&#39;`` is supported for</span>
<span class="sd">        DataFrame/Series with a MultiIndex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, default &#39;linear&#39;</span>
<span class="sd">            Interpolation technique to use. One of:</span>

<span class="sd">            * &#39;linear&#39;: Ignore the index and treat the values as equally</span>
<span class="sd">              spaced. This is the only method supported on MultiIndexes.</span>
<span class="sd">            * &#39;time&#39;: Works on daily and higher resolution data to interpolate</span>
<span class="sd">              given length of interval.</span>
<span class="sd">            * &#39;index&#39;, &#39;values&#39;: use the actual numerical values of the index.</span>
<span class="sd">            * &#39;pad&#39;: Fill in NaNs using existing values.</span>
<span class="sd">            * &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;,</span>
<span class="sd">              &#39;barycentric&#39;, &#39;polynomial&#39;: Passed to</span>
<span class="sd">              `scipy.interpolate.interp1d`, whereas &#39;spline&#39; is passed to</span>
<span class="sd">              `scipy.interpolate.UnivariateSpline`. These methods use the numerical</span>
<span class="sd">              values of the index.  Both &#39;polynomial&#39; and &#39;spline&#39; require that</span>
<span class="sd">              you also specify an `order` (int), e.g.</span>
<span class="sd">              ``df.interpolate(method=&#39;polynomial&#39;, order=5)``. Note that,</span>
<span class="sd">              `slinear` method in Pandas refers to the Scipy first order `spline`</span>
<span class="sd">              instead of Pandas first order `spline`.</span>
<span class="sd">            * &#39;krogh&#39;, &#39;piecewise_polynomial&#39;, &#39;spline&#39;, &#39;pchip&#39;, &#39;akima&#39;,</span>
<span class="sd">              &#39;cubicspline&#39;: Wrappers around the SciPy interpolation methods of</span>
<span class="sd">              similar names. See `Notes`.</span>
<span class="sd">            * &#39;from_derivatives&#39;: Refers to</span>
<span class="sd">              `scipy.interpolate.BPoly.from_derivatives` which</span>
<span class="sd">              replaces &#39;piecewise_polynomial&#39; interpolation method in</span>
<span class="sd">              scipy 0.18.</span>

<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}}, default None</span>
<span class="sd">            Axis to interpolate along. For `Series` this parameter is unused</span>
<span class="sd">            and defaults to 0.</span>
<span class="sd">        limit : int, optional</span>
<span class="sd">            Maximum number of consecutive NaNs to fill. Must be greater than</span>
<span class="sd">            0.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Update the data in place if possible.</span>
<span class="sd">        limit_direction : {{&#39;forward&#39;, &#39;backward&#39;, &#39;both&#39;}}, Optional</span>
<span class="sd">            Consecutive NaNs will be filled in this direction.</span>

<span class="sd">            If limit is specified:</span>
<span class="sd">                * If &#39;method&#39; is &#39;pad&#39; or &#39;ffill&#39;, &#39;limit_direction&#39; must be &#39;forward&#39;.</span>
<span class="sd">                * If &#39;method&#39; is &#39;backfill&#39; or &#39;bfill&#39;, &#39;limit_direction&#39; must be</span>
<span class="sd">                  &#39;backwards&#39;.</span>

<span class="sd">            If &#39;limit&#39; is not specified:</span>
<span class="sd">                * If &#39;method&#39; is &#39;backfill&#39; or &#39;bfill&#39;, the default is &#39;backward&#39;</span>
<span class="sd">                * else the default is &#39;forward&#39;</span>

<span class="sd">            .. versionchanged:: 1.1.0</span>
<span class="sd">                raises ValueError if `limit_direction` is &#39;forward&#39; or &#39;both&#39; and</span>
<span class="sd">                    method is &#39;backfill&#39; or &#39;bfill&#39;.</span>
<span class="sd">                raises ValueError if `limit_direction` is &#39;backward&#39; or &#39;both&#39; and</span>
<span class="sd">                    method is &#39;pad&#39; or &#39;ffill&#39;.</span>

<span class="sd">        limit_area : {{`None`, &#39;inside&#39;, &#39;outside&#39;}}, default None</span>
<span class="sd">            If limit is specified, consecutive NaNs will be filled with this</span>
<span class="sd">            restriction.</span>

<span class="sd">            * ``None``: No fill restriction.</span>
<span class="sd">            * &#39;inside&#39;: Only fill NaNs surrounded by valid values</span>
<span class="sd">              (interpolate).</span>
<span class="sd">            * &#39;outside&#39;: Only fill NaNs outside valid values (extrapolate).</span>

<span class="sd">        downcast : optional, &#39;infer&#39; or None, defaults to None</span>
<span class="sd">            Downcast dtypes if possible.</span>
<span class="sd">        ``**kwargs`` : optional</span>
<span class="sd">            Keyword arguments to pass on to the interpolating function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame or None</span>
<span class="sd">            Returns the same object type as the caller, interpolated at</span>
<span class="sd">            some or all ``NaN`` values or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fillna : Fill missing values using different methods.</span>
<span class="sd">        scipy.interpolate.Akima1DInterpolator : Piecewise cubic polynomials</span>
<span class="sd">            (Akima interpolator).</span>
<span class="sd">        scipy.interpolate.BPoly.from_derivatives : Piecewise polynomial in the</span>
<span class="sd">            Bernstein basis.</span>
<span class="sd">        scipy.interpolate.interp1d : Interpolate a 1-D function.</span>
<span class="sd">        scipy.interpolate.KroghInterpolator : Interpolate polynomial (Krogh</span>
<span class="sd">            interpolator).</span>
<span class="sd">        scipy.interpolate.PchipInterpolator : PCHIP 1-d monotonic cubic</span>
<span class="sd">            interpolation.</span>
<span class="sd">        scipy.interpolate.CubicSpline : Cubic spline data interpolator.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The &#39;krogh&#39;, &#39;piecewise_polynomial&#39;, &#39;spline&#39;, &#39;pchip&#39; and &#39;akima&#39;</span>
<span class="sd">        methods are wrappers around the respective SciPy implementations of</span>
<span class="sd">        similar names. These use the actual numerical values of the index.</span>
<span class="sd">        For more information on their behavior, see the</span>
<span class="sd">        `SciPy documentation</span>
<span class="sd">        &lt;https://docs.scipy.org/doc/scipy/reference/interpolate.html#univariate-interpolation&gt;`__.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Filling in ``NaN`` in a :class:`~pandas.Series` via linear</span>
<span class="sd">        interpolation.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([0, 1, np.nan, 3])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1    1.0</span>
<span class="sd">        2    NaN</span>
<span class="sd">        3    3.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; s.interpolate()</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1    1.0</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    3.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Filling in ``NaN`` in a Series by padding, but filling at most two</span>
<span class="sd">        consecutive ``NaN`` at a time.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([np.nan, &quot;single_one&quot;, np.nan,</span>
<span class="sd">        ...                &quot;fill_two_more&quot;, np.nan, np.nan, np.nan,</span>
<span class="sd">        ...                4.71, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0              NaN</span>
<span class="sd">        1       single_one</span>
<span class="sd">        2              NaN</span>
<span class="sd">        3    fill_two_more</span>
<span class="sd">        4              NaN</span>
<span class="sd">        5              NaN</span>
<span class="sd">        6              NaN</span>
<span class="sd">        7             4.71</span>
<span class="sd">        8              NaN</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; s.interpolate(method=&#39;pad&#39;, limit=2)</span>
<span class="sd">        0              NaN</span>
<span class="sd">        1       single_one</span>
<span class="sd">        2       single_one</span>
<span class="sd">        3    fill_two_more</span>
<span class="sd">        4    fill_two_more</span>
<span class="sd">        5    fill_two_more</span>
<span class="sd">        6              NaN</span>
<span class="sd">        7             4.71</span>
<span class="sd">        8             4.71</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Filling in ``NaN`` in a Series via polynomial interpolation or splines:</span>
<span class="sd">        Both &#39;polynomial&#39; and &#39;spline&#39; methods require that you also specify</span>
<span class="sd">        an ``order`` (int).</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([0, 2, np.nan, 8])</span>
<span class="sd">        &gt;&gt;&gt; s.interpolate(method=&#39;polynomial&#39;, order=2)</span>
<span class="sd">        0    0.000000</span>
<span class="sd">        1    2.000000</span>
<span class="sd">        2    4.666667</span>
<span class="sd">        3    8.000000</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Fill the DataFrame forward (that is, going down) along each column</span>
<span class="sd">        using linear interpolation.</span>

<span class="sd">        Note how the last entry in column &#39;a&#39; is interpolated differently,</span>
<span class="sd">        because there is no entry after it to use for interpolation.</span>
<span class="sd">        Note how the first entry in column &#39;b&#39; remains ``NaN``, because there</span>
<span class="sd">        is no entry before it to use for interpolation.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(0.0, np.nan, -1.0, 1.0),</span>
<span class="sd">        ...                    (np.nan, 2.0, np.nan, np.nan),</span>
<span class="sd">        ...                    (2.0, 3.0, np.nan, 9.0),</span>
<span class="sd">        ...                    (np.nan, 4.0, -4.0, 16.0)],</span>
<span class="sd">        ...                   columns=list(&#39;abcd&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             a    b    c     d</span>
<span class="sd">        0  0.0  NaN -1.0   1.0</span>
<span class="sd">        1  NaN  2.0  NaN   NaN</span>
<span class="sd">        2  2.0  3.0  NaN   9.0</span>
<span class="sd">        3  NaN  4.0 -4.0  16.0</span>
<span class="sd">        &gt;&gt;&gt; df.interpolate(method=&#39;linear&#39;, limit_direction=&#39;forward&#39;, axis=0)</span>
<span class="sd">             a    b    c     d</span>
<span class="sd">        0  0.0  NaN -1.0   1.0</span>
<span class="sd">        1  1.0  2.0 -2.0   5.0</span>
<span class="sd">        2  2.0  3.0 -3.0   9.0</span>
<span class="sd">        3  2.0  4.0 -4.0  16.0</span>

<span class="sd">        Using polynomial interpolation.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;d&#39;].interpolate(method=&#39;polynomial&#39;, order=2)</span>
<span class="sd">        0     1.0</span>
<span class="sd">        1     4.0</span>
<span class="sd">        2     9.0</span>
<span class="sd">        3    16.0</span>
<span class="sd">        Name: d, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">fillna_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;backfill&quot;</span><span class="p">]</span>
        <span class="n">should_transpose</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fillna_methods</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">should_transpose</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fillna_methods</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_number</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Only `method=linear` interpolation is supported on MultiIndexes.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Set `limit_direction` depending on `method`</span>
        <span class="k">if</span> <span class="n">limit_direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limit_direction</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;backward&quot;</span> <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;backfill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;forward&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">limit_direction</span> <span class="o">!=</span> <span class="s2">&quot;forward&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;`limit_direction` must be &#39;forward&#39; for method `</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">`&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;backfill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">limit_direction</span> <span class="o">!=</span> <span class="s2">&quot;backward&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;`limit_direction` must be &#39;backward&#39; for method `</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">`&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot interpolate with all object-dtype columns &quot;</span>
                <span class="s2">&quot;in the DataFrame. Try setting at least one &quot;</span>
                <span class="s2">&quot;column to a numeric dtype.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># create/use the index</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="c1"># prior default</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">index</span>
            <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">}</span>
            <span class="n">is_numeric_or_datetime</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">is_datetime64_any_dtype</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">methods</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_numeric_or_datetime</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Index column must be numeric or datetime type when &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;using </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> method other than linear. &quot;</span>
                    <span class="s2">&quot;Try setting a numeric or datetime index column before &quot;</span>
                    <span class="s2">&quot;interpolating.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">isna</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Interpolation with NaNs in the index &quot;</span>
                <span class="s2">&quot;has not been implemented. Try filling &quot;</span>
                <span class="s2">&quot;those NaNs before interpolating.&quot;</span>
            <span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">limit_direction</span><span class="o">=</span><span class="n">limit_direction</span><span class="p">,</span>
            <span class="n">limit_area</span><span class="o">=</span><span class="n">limit_area</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">should_transpose</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;interpolate&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Timeseries methods Methods</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">asof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last row(s) without any NaNs before `where`.</span>

<span class="sd">        The last row (for each element in `where`, if list) without any</span>
<span class="sd">        NaN is taken.</span>
<span class="sd">        In case of a :class:`~pandas.DataFrame`, the last row without NaN</span>
<span class="sd">        considering only the subset of columns (if not `None`)</span>

<span class="sd">        If there is no good value, NaN is returned for a Series or</span>
<span class="sd">        a Series of NaN values for a DataFrame</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : date or array-like of dates</span>
<span class="sd">            Date(s) before which the last row(s) are returned.</span>
<span class="sd">        subset : str or array-like of str, default `None`</span>
<span class="sd">            For DataFrame, if not `None`, only use these columns to</span>
<span class="sd">            check for NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar, Series, or DataFrame</span>

<span class="sd">            The return can be:</span>

<span class="sd">            * scalar : when `self` is a Series and `where` is a scalar</span>
<span class="sd">            * Series: when `self` is a Series and `where` is an array-like,</span>
<span class="sd">              or when `self` is a DataFrame and `where` is a scalar</span>
<span class="sd">            * DataFrame : when `self` is a DataFrame and `where` is an</span>
<span class="sd">              array-like</span>

<span class="sd">            Return scalar, Series, or DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        merge_asof : Perform an asof merge. Similar to left join.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Dates are assumed to be sorted. Raises if this is not the case.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        A Series and a scalar `where`.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, np.nan, 4], index=[10, 20, 30, 40])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        10    1.0</span>
<span class="sd">        20    2.0</span>
<span class="sd">        30    NaN</span>
<span class="sd">        40    4.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.asof(20)</span>
<span class="sd">        2.0</span>

<span class="sd">        For a sequence `where`, a Series is returned. The first value is</span>
<span class="sd">        NaN, because the first element of `where` is before the first</span>
<span class="sd">        index value.</span>

<span class="sd">        &gt;&gt;&gt; s.asof([5, 20])</span>
<span class="sd">        5     NaN</span>
<span class="sd">        20    2.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Missing values are not considered. The following is ``2.0``, not</span>
<span class="sd">        NaN, even though NaN is at the index location for ``30``.</span>

<span class="sd">        &gt;&gt;&gt; s.asof(30)</span>
<span class="sd">        2.0</span>

<span class="sd">        Take all columns into consideration</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;a&#39;: [10, 20, 30, 40, 50],</span>
<span class="sd">        ...                    &#39;b&#39;: [None, None, None, None, 500]},</span>
<span class="sd">        ...                   index=pd.DatetimeIndex([&#39;2018-02-27 09:01:00&#39;,</span>
<span class="sd">        ...                                           &#39;2018-02-27 09:02:00&#39;,</span>
<span class="sd">        ...                                           &#39;2018-02-27 09:03:00&#39;,</span>
<span class="sd">        ...                                           &#39;2018-02-27 09:04:00&#39;,</span>
<span class="sd">        ...                                           &#39;2018-02-27 09:05:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; df.asof(pd.DatetimeIndex([&#39;2018-02-27 09:03:30&#39;,</span>
<span class="sd">        ...                           &#39;2018-02-27 09:04:30&#39;]))</span>
<span class="sd">                              a   b</span>
<span class="sd">        2018-02-27 09:03:30 NaN NaN</span>
<span class="sd">        2018-02-27 09:04:30 NaN NaN</span>

<span class="sd">        Take a single column into consideration</span>

<span class="sd">        &gt;&gt;&gt; df.asof(pd.DatetimeIndex([&#39;2018-02-27 09:03:30&#39;,</span>
<span class="sd">        ...                           &#39;2018-02-27 09:04:30&#39;]),</span>
<span class="sd">        ...         subset=[&#39;a&#39;])</span>
<span class="sd">                              a   b</span>
<span class="sd">        2018-02-27 09:03:30  30 NaN</span>
<span class="sd">        2018-02-27 09:04:30  40 NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;asof requires a sorted index&quot;</span><span class="p">)</span>

        <span class="n">is_series</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;subset is not valid for Series&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">subset</span><span class="p">):</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset</span><span class="p">]</span>

        <span class="n">is_list</span> <span class="o">=</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
                <span class="n">where</span> <span class="o">=</span> <span class="n">Period</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">where</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_series</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="c1"># It&#39;s always much faster to use a *while* loop here for</span>
            <span class="c1"># Series than pre-computing all the NAs. However a</span>
            <span class="c1"># *while* loop is extremely expensive for DataFrame</span>
            <span class="c1"># so we later pre-compute all the NAs and use the same</span>
            <span class="c1"># code path whether *where* is a scalar or list.</span>
            <span class="c1"># See PR: https://github.com/pandas-dev/pandas/pull/14476</span>
            <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">-=</span> <span class="mi">1</span>

                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
                <span class="k">while</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">isna</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">loc</span><span class="p">]):</span>
                    <span class="n">loc</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">where</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_list</span> <span class="k">else</span> <span class="n">Index</span><span class="p">([</span><span class="n">where</span><span class="p">])</span>

        <span class="n">nulls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span> <span class="k">if</span> <span class="n">is_series</span> <span class="k">else</span> <span class="bp">self</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nulls</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;Series&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_list</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">asof_locs</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">nulls</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span>

        <span class="c1"># mask the missing</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">locs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">where</span>
        <span class="k">if</span> <span class="n">missing</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># GH#16063 only do this setting when necessary, otherwise</span>
            <span class="c1">#  we&#39;d cast e.g. bools to floats</span>
            <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">missing</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">data</span> <span class="k">if</span> <span class="n">is_list</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Action Methods</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect missing values.</span>

<span class="sd">        Return a boolean same-sized object indicating if the values are NA.</span>
<span class="sd">        NA values, such as None or :attr:`numpy.NaN`, gets mapped to True</span>
<span class="sd">        values.</span>
<span class="sd">        Everything else gets mapped to False values. Characters such as empty</span>
<span class="sd">        strings ``&#39;&#39;`` or :attr:`numpy.inf` are not considered NA values</span>
<span class="sd">        (unless you set ``pandas.options.mode.use_inf_as_na = True``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass}</span>
<span class="sd">            Mask of bool values for each element in {klass} that</span>
<span class="sd">            indicates whether an element is an NA value.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        {klass}.isnull : Alias of isna.</span>
<span class="sd">        {klass}.notna : Boolean inverse of isna.</span>
<span class="sd">        {klass}.dropna : Omit axes labels with missing values.</span>
<span class="sd">        isna : Top-level isna.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Show which entries in a DataFrame are NA.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(dict(age=[5, 6, np.NaN],</span>
<span class="sd">        ...                        born=[pd.NaT, pd.Timestamp(&#39;1939-05-27&#39;),</span>
<span class="sd">        ...                              pd.Timestamp(&#39;1940-04-25&#39;)],</span>
<span class="sd">        ...                        name=[&#39;Alfred&#39;, &#39;Batman&#39;, &#39;&#39;],</span>
<span class="sd">        ...                        toy=[None, &#39;Batmobile&#39;, &#39;Joker&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           age       born    name        toy</span>
<span class="sd">        0  5.0        NaT  Alfred       None</span>
<span class="sd">        1  6.0 1939-05-27  Batman  Batmobile</span>
<span class="sd">        2  NaN 1940-04-25              Joker</span>

<span class="sd">        &gt;&gt;&gt; df.isna()</span>
<span class="sd">             age   born   name    toy</span>
<span class="sd">        0  False   True  False   True</span>
<span class="sd">        1  False  False  False  False</span>
<span class="sd">        2   True  False  False  False</span>

<span class="sd">        Show which entries in a Series are NA.</span>

<span class="sd">        &gt;&gt;&gt; ser = pd.Series([5, 6, np.NaN])</span>
<span class="sd">        &gt;&gt;&gt; ser</span>
<span class="sd">        0    5.0</span>
<span class="sd">        1    6.0</span>
<span class="sd">        2    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; ser.isna()</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;isna&quot;</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">isna</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;isnull&quot;</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect existing (non-missing) values.</span>

<span class="sd">        Return a boolean same-sized object indicating if the values are not NA.</span>
<span class="sd">        Non-missing values get mapped to True. Characters such as empty</span>
<span class="sd">        strings ``&#39;&#39;`` or :attr:`numpy.inf` are not considered NA values</span>
<span class="sd">        (unless you set ``pandas.options.mode.use_inf_as_na = True``).</span>
<span class="sd">        NA values, such as None or :attr:`numpy.NaN`, get mapped to False</span>
<span class="sd">        values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass}</span>
<span class="sd">            Mask of bool values for each element in {klass} that</span>
<span class="sd">            indicates whether an element is not an NA value.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        {klass}.notnull : Alias of notna.</span>
<span class="sd">        {klass}.isna : Boolean inverse of notna.</span>
<span class="sd">        {klass}.dropna : Omit axes labels with missing values.</span>
<span class="sd">        notna : Top-level notna.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Show which entries in a DataFrame are not NA.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(dict(age=[5, 6, np.NaN],</span>
<span class="sd">        ...                        born=[pd.NaT, pd.Timestamp(&#39;1939-05-27&#39;),</span>
<span class="sd">        ...                              pd.Timestamp(&#39;1940-04-25&#39;)],</span>
<span class="sd">        ...                        name=[&#39;Alfred&#39;, &#39;Batman&#39;, &#39;&#39;],</span>
<span class="sd">        ...                        toy=[None, &#39;Batmobile&#39;, &#39;Joker&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           age       born    name        toy</span>
<span class="sd">        0  5.0        NaT  Alfred       None</span>
<span class="sd">        1  6.0 1939-05-27  Batman  Batmobile</span>
<span class="sd">        2  NaN 1940-04-25              Joker</span>

<span class="sd">        &gt;&gt;&gt; df.notna()</span>
<span class="sd">             age   born  name    toy</span>
<span class="sd">        0   True  False  True  False</span>
<span class="sd">        1   True   True  True   True</span>
<span class="sd">        2  False   True  True   True</span>

<span class="sd">        Show which entries in a Series are not NA.</span>

<span class="sd">        &gt;&gt;&gt; ser = pd.Series([5, 6, np.NaN])</span>
<span class="sd">        &gt;&gt;&gt; ser</span>
<span class="sd">        0    5.0</span>
<span class="sd">        1    6.0</span>
<span class="sd">        2    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; ser.notna()</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;notna&quot;</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">notna</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">notnull</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;notnull&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_clip_with_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="n">lower</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="n">upper</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use an NA value as a clip threshold&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&lt;=</span> <span class="n">upper</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&gt;=</span> <span class="n">lower</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_clip_with_one_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># method is self.le for upper bound and self.ge for lower bound</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_number</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;le&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_scalar</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_scalar</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

        <span class="c1"># GH #15390</span>
        <span class="c1"># In order for where method to work, the threshold must</span>
        <span class="c1"># be transformed to NDFrame from other array like structure.</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">))</span> <span class="ow">and</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">flex</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># GH 40420</span>
        <span class="c1"># Treat missing thresholds as no bounds, not clipping the values</span>
        <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;le&quot;</span> <span class="k">else</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">threshold_inf</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">threshold_inf</span> <span class="o">=</span> <span class="n">threshold</span>

        <span class="n">subset</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">threshold_inf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">|</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># GH 40420</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim values at input threshold(s).</span>

<span class="sd">        Assigns values outside boundary to boundary values. Thresholds</span>
<span class="sd">        can be singular values or array like, and in the latter case</span>
<span class="sd">        the clipping is performed element-wise in the specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lower : float or array-like, default None</span>
<span class="sd">            Minimum threshold value. All values below this</span>
<span class="sd">            threshold will be set to it. A missing</span>
<span class="sd">            threshold (e.g `NA`) will not clip the value.</span>
<span class="sd">        upper : float or array-like, default None</span>
<span class="sd">            Maximum threshold value. All values above this</span>
<span class="sd">            threshold will be set to it. A missing</span>
<span class="sd">            threshold (e.g `NA`) will not clip the value.</span>
<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}}, default None</span>
<span class="sd">            Align object with lower and upper along the given axis.</span>
<span class="sd">            For `Series` this parameter is unused and defaults to `None`.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to perform the operation in place on the data.</span>
<span class="sd">        *args, **kwargs</span>
<span class="sd">            Additional keywords have no effect but might be accepted</span>
<span class="sd">            for compatibility with numpy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame or None</span>
<span class="sd">            Same type as calling object with the values outside the</span>
<span class="sd">            clip boundaries replaced or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.clip : Trim values at input threshold in series.</span>
<span class="sd">        DataFrame.clip : Trim values at input threshold in dataframe.</span>
<span class="sd">        numpy.clip : Clip (limit) the values in an array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; data = {&#39;col_0&#39;: [9, -3, 0, -1, 5], &#39;col_1&#39;: [-2, -7, 6, 8, -5]}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           col_0  col_1</span>
<span class="sd">        0      9     -2</span>
<span class="sd">        1     -3     -7</span>
<span class="sd">        2      0      6</span>
<span class="sd">        3     -1      8</span>
<span class="sd">        4      5     -5</span>

<span class="sd">        Clips per column using lower and upper thresholds:</span>

<span class="sd">        &gt;&gt;&gt; df.clip(-4, 6)</span>
<span class="sd">           col_0  col_1</span>
<span class="sd">        0      6     -2</span>
<span class="sd">        1     -3     -4</span>
<span class="sd">        2      0      6</span>
<span class="sd">        3     -1      6</span>
<span class="sd">        4      5     -4</span>

<span class="sd">        Clips using specific lower and upper thresholds per column element:</span>

<span class="sd">        &gt;&gt;&gt; t = pd.Series([2, -4, -1, 6, 3])</span>
<span class="sd">        &gt;&gt;&gt; t</span>
<span class="sd">        0    2</span>
<span class="sd">        1   -4</span>
<span class="sd">        2   -1</span>
<span class="sd">        3    6</span>
<span class="sd">        4    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.clip(t, t + 4, axis=0)</span>
<span class="sd">           col_0  col_1</span>
<span class="sd">        0      6      2</span>
<span class="sd">        1     -3     -4</span>
<span class="sd">        2      0      3</span>
<span class="sd">        3      6      8</span>
<span class="sd">        4      5      3</span>

<span class="sd">        Clips using specific lower threshold per column element, with missing values:</span>

<span class="sd">        &gt;&gt;&gt; t = pd.Series([2, -4, np.NaN, 6, 3])</span>
<span class="sd">        &gt;&gt;&gt; t</span>
<span class="sd">        0    2.0</span>
<span class="sd">        1   -4.0</span>
<span class="sd">        2    NaN</span>
<span class="sd">        3    6.0</span>
<span class="sd">        4    3.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; df.clip(t, axis=0)</span>
<span class="sd">        col_0  col_1</span>
<span class="sd">        0      9      2</span>
<span class="sd">        1     -3     -4</span>
<span class="sd">        2      0      6</span>
<span class="sd">        3      6      8</span>
<span class="sd">        4      5      3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_clip_with_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># GH 17276</span>
        <span class="c1"># numpy doesn&#39;t like NaN as a clip value</span>
        <span class="c1"># so ignore</span>
        <span class="c1"># GH 19992</span>
        <span class="c1"># numpy doesn&#39;t drop a list-like bound containing NaN</span>
        <span class="n">isna_lower</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">lower</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isna_lower</span><span class="p">):</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">isna_lower</span><span class="p">):</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">isna_upper</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">upper</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isna_upper</span><span class="p">):</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">isna_upper</span><span class="p">):</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># GH 2747 (arguments were reversed)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>

        <span class="c1"># fast-path for scalars</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_number</span><span class="p">(</span><span class="n">lower</span><span class="p">)))</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_number</span><span class="p">(</span><span class="n">upper</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_scalar</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_clip_with_one_bound</span><span class="p">(</span>
                <span class="n">lower</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_clip_with_one_bound</span><span class="p">(</span>
                <span class="n">upper</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">asfreq</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Frequency</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert time series to specified frequency.</span>

<span class="sd">        Returns the original data conformed to a new index with the specified</span>
<span class="sd">        frequency.</span>

<span class="sd">        If the index of this {klass} is a :class:`~pandas.PeriodIndex`, the new index</span>
<span class="sd">        is the result of transforming the original index with</span>
<span class="sd">        :meth:`PeriodIndex.asfreq &lt;pandas.PeriodIndex.asfreq&gt;` (so the original index</span>
<span class="sd">        will map one-to-one to the new index).</span>

<span class="sd">        Otherwise, the new index will be equivalent to ``pd.date_range(start, end,</span>
<span class="sd">        freq=freq)`` where ``start`` and ``end`` are, respectively, the first and</span>
<span class="sd">        last entries in the original index (see :func:`pandas.date_range`). The</span>
<span class="sd">        values corresponding to any timesteps in the new index which were not present</span>
<span class="sd">        in the original index will be null (``NaN``), unless a method for filling</span>
<span class="sd">        such unknowns is provided (see the ``method`` parameter below).</span>

<span class="sd">        The :meth:`resample` method is more appropriate if an operation on each group of</span>
<span class="sd">        timesteps (such as an aggregate) is necessary to represent the data at the new</span>
<span class="sd">        frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : DateOffset or str</span>
<span class="sd">            Frequency DateOffset or string.</span>
<span class="sd">        method : {{&#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;}}, default None</span>
<span class="sd">            Method to use for filling holes in reindexed Series (note this</span>
<span class="sd">            does not fill NaNs that already were present):</span>

<span class="sd">            * &#39;pad&#39; / &#39;ffill&#39;: propagate last valid observation forward to next</span>
<span class="sd">              valid</span>
<span class="sd">            * &#39;backfill&#39; / &#39;bfill&#39;: use NEXT valid observation to fill.</span>
<span class="sd">        how : {{&#39;start&#39;, &#39;end&#39;}}, default end</span>
<span class="sd">            For PeriodIndex only (see PeriodIndex.asfreq).</span>
<span class="sd">        normalize : bool, default False</span>
<span class="sd">            Whether to reset output index to midnight.</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            Value to use for missing values, applied during upsampling (note</span>
<span class="sd">            this does not fill NaNs that already were present).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass}</span>
<span class="sd">            {klass} object reindexed to the specified frequency.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        reindex : Conform DataFrame to new index with optional filling logic.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To learn more about the frequency strings, please see `this link</span>
<span class="sd">        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Start by creating a series with 4 one minute timestamps.</span>

<span class="sd">        &gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; series = pd.Series([0.0, None, 2.0, 3.0], index=index)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({{&#39;s&#39;: series}})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>

<span class="sd">        Upsample the series into 30 second bins.</span>

<span class="sd">        &gt;&gt;&gt; df.asfreq(freq=&#39;30S&#39;)</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:00:30    NaN</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:01:30    NaN</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:02:30    NaN</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>

<span class="sd">        Upsample again, providing a ``fill value``.</span>

<span class="sd">        &gt;&gt;&gt; df.asfreq(freq=&#39;30S&#39;, fill_value=9.0)</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:00:30    9.0</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:01:30    9.0</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:02:30    9.0</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>

<span class="sd">        Upsample again, providing a ``method``.</span>

<span class="sd">        &gt;&gt;&gt; df.asfreq(freq=&#39;30S&#39;, method=&#39;bfill&#39;)</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:00:30    NaN</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:01:30    2.0</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:02:30    3.0</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.resample</span> <span class="kn">import</span> <span class="n">asfreq</span>

        <span class="k">return</span> <span class="n">asfreq</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">freq</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">at_time</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">asof</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select values at particular time of day (e.g., 9:30AM).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : datetime.time or str</span>
<span class="sd">            The values to select.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            For `Series` this parameter is unused and defaults to 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the index is not  a :class:`DatetimeIndex`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        between_time : Select values between particular times of the day.</span>
<span class="sd">        first : Select initial periods of time series based on a date offset.</span>
<span class="sd">        last : Select final periods of time series based on a date offset.</span>
<span class="sd">        DatetimeIndex.indexer_at_time : Get just the index locations for</span>
<span class="sd">            values at particular time of the day.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; i = pd.date_range(&#39;2018-04-09&#39;, periods=4, freq=&#39;12H&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ts = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4]}, index=i)</span>
<span class="sd">        &gt;&gt;&gt; ts</span>
<span class="sd">                             A</span>
<span class="sd">        2018-04-09 00:00:00  1</span>
<span class="sd">        2018-04-09 12:00:00  2</span>
<span class="sd">        2018-04-10 00:00:00  3</span>
<span class="sd">        2018-04-10 12:00:00  4</span>

<span class="sd">        &gt;&gt;&gt; ts.at_time(&#39;12:00&#39;)</span>
<span class="sd">                             A</span>
<span class="sd">        2018-04-09 12:00:00  2</span>
<span class="sd">        2018-04-10 12:00:00  4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index must be DatetimeIndex&quot;</span><span class="p">)</span>

        <span class="n">indexer</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">indexer_at_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">asof</span><span class="o">=</span><span class="n">asof</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_with_is_copy</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">between_time</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">start_time</span><span class="p">,</span>
        <span class="n">end_time</span><span class="p">,</span>
        <span class="n">inclusive</span><span class="p">:</span> <span class="n">IntervalClosedType</span> <span class="o">=</span> <span class="s2">&quot;both&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select values between particular times of the day (e.g., 9:00-9:30 AM).</span>

<span class="sd">        By setting ``start_time`` to be later than ``end_time``,</span>
<span class="sd">        you can get the times that are *not* between the two times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_time : datetime.time or str</span>
<span class="sd">            Initial time as a time filter limit.</span>
<span class="sd">        end_time : datetime.time or str</span>
<span class="sd">            End time as a time filter limit.</span>
<span class="sd">        inclusive : {&quot;both&quot;, &quot;neither&quot;, &quot;left&quot;, &quot;right&quot;}, default &quot;both&quot;</span>
<span class="sd">            Include boundaries; whether to set each bound as closed or open.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Determine range time on index or columns value.</span>
<span class="sd">            For `Series` this parameter is unused and defaults to 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Data from the original object filtered to the specified dates range.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the index is not  a :class:`DatetimeIndex`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        at_time : Select values at a particular time of the day.</span>
<span class="sd">        first : Select initial periods of time series based on a date offset.</span>
<span class="sd">        last : Select final periods of time series based on a date offset.</span>
<span class="sd">        DatetimeIndex.indexer_between_time : Get just the index locations for</span>
<span class="sd">            values between particular times of the day.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; i = pd.date_range(&#39;2018-04-09&#39;, periods=4, freq=&#39;1D20min&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ts = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4]}, index=i)</span>
<span class="sd">        &gt;&gt;&gt; ts</span>
<span class="sd">                             A</span>
<span class="sd">        2018-04-09 00:00:00  1</span>
<span class="sd">        2018-04-10 00:20:00  2</span>
<span class="sd">        2018-04-11 00:40:00  3</span>
<span class="sd">        2018-04-12 01:00:00  4</span>

<span class="sd">        &gt;&gt;&gt; ts.between_time(&#39;0:15&#39;, &#39;0:45&#39;)</span>
<span class="sd">                             A</span>
<span class="sd">        2018-04-10 00:20:00  2</span>
<span class="sd">        2018-04-11 00:40:00  3</span>

<span class="sd">        You get the times that are *not* between two times by setting</span>
<span class="sd">        ``start_time`` later than ``end_time``:</span>

<span class="sd">        &gt;&gt;&gt; ts.between_time(&#39;0:45&#39;, &#39;0:15&#39;)</span>
<span class="sd">                             A</span>
<span class="sd">        2018-04-09 00:00:00  1</span>
<span class="sd">        2018-04-12 01:00:00  4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index must be DatetimeIndex&quot;</span><span class="p">)</span>

        <span class="n">left_inclusive</span><span class="p">,</span> <span class="n">right_inclusive</span> <span class="o">=</span> <span class="n">validate_inclusive</span><span class="p">(</span><span class="n">inclusive</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">indexer_between_time</span><span class="p">(</span>
            <span class="n">start_time</span><span class="p">,</span>
            <span class="n">end_time</span><span class="p">,</span>
            <span class="n">include_start</span><span class="o">=</span><span class="n">left_inclusive</span><span class="p">,</span>
            <span class="n">include_end</span><span class="o">=</span><span class="n">right_inclusive</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_with_is_copy</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">closed</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">convention</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">on</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">TimestampConvertibleTypes</span> <span class="o">=</span> <span class="s2">&quot;start_day&quot;</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">TimedeltaConvertibleTypes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">group_keys</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Resampler</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample time-series data.</span>

<span class="sd">        Convenience method for frequency conversion and resampling of time series.</span>
<span class="sd">        The object must have a datetime-like index (`DatetimeIndex`, `PeriodIndex`,</span>
<span class="sd">        or `TimedeltaIndex`), or the caller must pass the label of a datetime-like</span>
<span class="sd">        series/index to the ``on``/``level`` keyword parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rule : DateOffset, Timedelta or str</span>
<span class="sd">            The offset string or object representing target conversion.</span>
<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;}}, default 0</span>
<span class="sd">            Which axis to use for up- or down-sampling. For `Series` this parameter</span>
<span class="sd">            is unused and defaults to 0. Must be</span>
<span class="sd">            `DatetimeIndex`, `TimedeltaIndex` or `PeriodIndex`.</span>
<span class="sd">        closed : {{&#39;right&#39;, &#39;left&#39;}}, default None</span>
<span class="sd">            Which side of bin interval is closed. The default is &#39;left&#39;</span>
<span class="sd">            for all frequency offsets except for &#39;M&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;BM&#39;,</span>
<span class="sd">            &#39;BA&#39;, &#39;BQ&#39;, and &#39;W&#39; which all have a default of &#39;right&#39;.</span>
<span class="sd">        label : {{&#39;right&#39;, &#39;left&#39;}}, default None</span>
<span class="sd">            Which bin edge label to label bucket with. The default is &#39;left&#39;</span>
<span class="sd">            for all frequency offsets except for &#39;M&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;BM&#39;,</span>
<span class="sd">            &#39;BA&#39;, &#39;BQ&#39;, and &#39;W&#39; which all have a default of &#39;right&#39;.</span>
<span class="sd">        convention : {{&#39;start&#39;, &#39;end&#39;, &#39;s&#39;, &#39;e&#39;}}, default &#39;start&#39;</span>
<span class="sd">            For `PeriodIndex` only, controls whether to use the start or</span>
<span class="sd">            end of `rule`.</span>
<span class="sd">        kind : {{&#39;timestamp&#39;, &#39;period&#39;}}, optional, default None</span>
<span class="sd">            Pass &#39;timestamp&#39; to convert the resulting index to a</span>
<span class="sd">            `DateTimeIndex` or &#39;period&#39; to convert it to a `PeriodIndex`.</span>
<span class="sd">            By default the input representation is retained.</span>

<span class="sd">        on : str, optional</span>
<span class="sd">            For a DataFrame, column to use instead of index for resampling.</span>
<span class="sd">            Column must be datetime-like.</span>
<span class="sd">        level : str or int, optional</span>
<span class="sd">            For a MultiIndex, level (name or number) to use for</span>
<span class="sd">            resampling. `level` must be datetime-like.</span>
<span class="sd">        origin : Timestamp or str, default &#39;start_day&#39;</span>
<span class="sd">            The timestamp on which to adjust the grouping. The timezone of origin</span>
<span class="sd">            must match the timezone of the index.</span>
<span class="sd">            If string, must be one of the following:</span>

<span class="sd">            - &#39;epoch&#39;: `origin` is 1970-01-01</span>
<span class="sd">            - &#39;start&#39;: `origin` is the first value of the timeseries</span>
<span class="sd">            - &#39;start_day&#39;: `origin` is the first day at midnight of the timeseries</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">            - &#39;end&#39;: `origin` is the last value of the timeseries</span>
<span class="sd">            - &#39;end_day&#39;: `origin` is the ceiling midnight of the last day</span>

<span class="sd">            .. versionadded:: 1.3.0</span>

<span class="sd">        offset : Timedelta or str, default is None</span>
<span class="sd">            An offset timedelta added to the origin.</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">        group_keys : bool, default False</span>
<span class="sd">            Whether to include the group keys in the result index when using</span>
<span class="sd">            ``.apply()`` on the resampled object.</span>

<span class="sd">            .. versionadded:: 1.5.0</span>

<span class="sd">                Not specifying ``group_keys`` will retain values-dependent behavior</span>
<span class="sd">                from pandas 1.4 and earlier (see :ref:`pandas 1.5.0 Release notes</span>
<span class="sd">                &lt;whatsnew_150.enhancements.resample_group_keys&gt;` for examples).</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>

<span class="sd">                ``group_keys`` now defaults to ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.core.Resampler</span>
<span class="sd">            :class:`~pandas.core.Resampler` object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.resample : Resample a Series.</span>
<span class="sd">        DataFrame.resample : Resample a DataFrame.</span>
<span class="sd">        groupby : Group {klass} by mapping, function, label, or list of labels.</span>
<span class="sd">        asfreq : Reindex a {klass} with the given frequency without grouping.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See the `user guide</span>
<span class="sd">        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#resampling&gt;`__</span>
<span class="sd">        for more.</span>

<span class="sd">        To learn more about the offset strings, please see `this link</span>
<span class="sd">        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects&gt;`__.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Start by creating a series with 9 one minute timestamps.</span>

<span class="sd">        &gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; series = pd.Series(range(9), index=index)</span>
<span class="sd">        &gt;&gt;&gt; series</span>
<span class="sd">        2000-01-01 00:00:00    0</span>
<span class="sd">        2000-01-01 00:01:00    1</span>
<span class="sd">        2000-01-01 00:02:00    2</span>
<span class="sd">        2000-01-01 00:03:00    3</span>
<span class="sd">        2000-01-01 00:04:00    4</span>
<span class="sd">        2000-01-01 00:05:00    5</span>
<span class="sd">        2000-01-01 00:06:00    6</span>
<span class="sd">        2000-01-01 00:07:00    7</span>
<span class="sd">        2000-01-01 00:08:00    8</span>
<span class="sd">        Freq: T, dtype: int64</span>

<span class="sd">        Downsample the series into 3 minute bins and sum the values</span>
<span class="sd">        of the timestamps falling into a bin.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;).sum()</span>
<span class="sd">        2000-01-01 00:00:00     3</span>
<span class="sd">        2000-01-01 00:03:00    12</span>
<span class="sd">        2000-01-01 00:06:00    21</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        Downsample the series into 3 minute bins as above, but label each</span>
<span class="sd">        bin using the right edge instead of the left. Please note that the</span>
<span class="sd">        value in the bucket used as the label is not included in the bucket,</span>
<span class="sd">        which it labels. For example, in the original series the</span>
<span class="sd">        bucket ``2000-01-01 00:03:00`` contains the value 3, but the summed</span>
<span class="sd">        value in the resampled bucket with the label ``2000-01-01 00:03:00``</span>
<span class="sd">        does not include 3 (if it did, the summed value would be 6, not 3).</span>
<span class="sd">        To include this value close the right side of the bin interval as</span>
<span class="sd">        illustrated in the example below this one.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;).sum()</span>
<span class="sd">        2000-01-01 00:03:00     3</span>
<span class="sd">        2000-01-01 00:06:00    12</span>
<span class="sd">        2000-01-01 00:09:00    21</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        Downsample the series into 3 minute bins as above, but close the right</span>
<span class="sd">        side of the bin interval.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;, closed=&#39;right&#39;).sum()</span>
<span class="sd">        2000-01-01 00:00:00     0</span>
<span class="sd">        2000-01-01 00:03:00     6</span>
<span class="sd">        2000-01-01 00:06:00    15</span>
<span class="sd">        2000-01-01 00:09:00    15</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        Upsample the series into 30 second bins.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;30S&#39;).asfreq()[0:5]   # Select first 5 rows</span>
<span class="sd">        2000-01-01 00:00:00   0.0</span>
<span class="sd">        2000-01-01 00:00:30   NaN</span>
<span class="sd">        2000-01-01 00:01:00   1.0</span>
<span class="sd">        2000-01-01 00:01:30   NaN</span>
<span class="sd">        2000-01-01 00:02:00   2.0</span>
<span class="sd">        Freq: 30S, dtype: float64</span>

<span class="sd">        Upsample the series into 30 second bins and fill the ``NaN``</span>
<span class="sd">        values using the ``ffill`` method.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;30S&#39;).ffill()[0:5]</span>
<span class="sd">        2000-01-01 00:00:00    0</span>
<span class="sd">        2000-01-01 00:00:30    0</span>
<span class="sd">        2000-01-01 00:01:00    1</span>
<span class="sd">        2000-01-01 00:01:30    1</span>
<span class="sd">        2000-01-01 00:02:00    2</span>
<span class="sd">        Freq: 30S, dtype: int64</span>

<span class="sd">        Upsample the series into 30 second bins and fill the</span>
<span class="sd">        ``NaN`` values using the ``bfill`` method.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;30S&#39;).bfill()[0:5]</span>
<span class="sd">        2000-01-01 00:00:00    0</span>
<span class="sd">        2000-01-01 00:00:30    1</span>
<span class="sd">        2000-01-01 00:01:00    1</span>
<span class="sd">        2000-01-01 00:01:30    2</span>
<span class="sd">        2000-01-01 00:02:00    2</span>
<span class="sd">        Freq: 30S, dtype: int64</span>

<span class="sd">        Pass a custom function via ``apply``</span>

<span class="sd">        &gt;&gt;&gt; def custom_resampler(arraylike):</span>
<span class="sd">        ...     return np.sum(arraylike) + 5</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;).apply(custom_resampler)</span>
<span class="sd">        2000-01-01 00:00:00     8</span>
<span class="sd">        2000-01-01 00:03:00    17</span>
<span class="sd">        2000-01-01 00:06:00    26</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        For a Series with a PeriodIndex, the keyword `convention` can be</span>
<span class="sd">        used to control whether to use the start or end of `rule`.</span>

<span class="sd">        Resample a year by quarter using &#39;start&#39; `convention`. Values are</span>
<span class="sd">        assigned to the first quarter of the period.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2], index=pd.period_range(&#39;2012-01-01&#39;,</span>
<span class="sd">        ...                                             freq=&#39;A&#39;,</span>
<span class="sd">        ...                                             periods=2))</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        2012    1</span>
<span class="sd">        2013    2</span>
<span class="sd">        Freq: A-DEC, dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.resample(&#39;Q&#39;, convention=&#39;start&#39;).asfreq()</span>
<span class="sd">        2012Q1    1.0</span>
<span class="sd">        2012Q2    NaN</span>
<span class="sd">        2012Q3    NaN</span>
<span class="sd">        2012Q4    NaN</span>
<span class="sd">        2013Q1    2.0</span>
<span class="sd">        2013Q2    NaN</span>
<span class="sd">        2013Q3    NaN</span>
<span class="sd">        2013Q4    NaN</span>
<span class="sd">        Freq: Q-DEC, dtype: float64</span>

<span class="sd">        Resample quarters by month using &#39;end&#39; `convention`. Values are</span>
<span class="sd">        assigned to the last month of the period.</span>

<span class="sd">        &gt;&gt;&gt; q = pd.Series([1, 2, 3, 4], index=pd.period_range(&#39;2018-01-01&#39;,</span>
<span class="sd">        ...                                                   freq=&#39;Q&#39;,</span>
<span class="sd">        ...                                                   periods=4))</span>
<span class="sd">        &gt;&gt;&gt; q</span>
<span class="sd">        2018Q1    1</span>
<span class="sd">        2018Q2    2</span>
<span class="sd">        2018Q3    3</span>
<span class="sd">        2018Q4    4</span>
<span class="sd">        Freq: Q-DEC, dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; q.resample(&#39;M&#39;, convention=&#39;end&#39;).asfreq()</span>
<span class="sd">        2018-03    1.0</span>
<span class="sd">        2018-04    NaN</span>
<span class="sd">        2018-05    NaN</span>
<span class="sd">        2018-06    2.0</span>
<span class="sd">        2018-07    NaN</span>
<span class="sd">        2018-08    NaN</span>
<span class="sd">        2018-09    3.0</span>
<span class="sd">        2018-10    NaN</span>
<span class="sd">        2018-11    NaN</span>
<span class="sd">        2018-12    4.0</span>
<span class="sd">        Freq: M, dtype: float64</span>

<span class="sd">        For DataFrame objects, the keyword `on` can be used to specify the</span>
<span class="sd">        column instead of the index for resampling.</span>

<span class="sd">        &gt;&gt;&gt; d = {{&#39;price&#39;: [10, 11, 9, 13, 14, 18, 17, 19],</span>
<span class="sd">        ...      &#39;volume&#39;: [50, 60, 40, 100, 50, 100, 40, 50]}}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(d)</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;week_starting&#39;] = pd.date_range(&#39;01/01/2018&#39;,</span>
<span class="sd">        ...                                     periods=8,</span>
<span class="sd">        ...                                     freq=&#39;W&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           price  volume week_starting</span>
<span class="sd">        0     10      50    2018-01-07</span>
<span class="sd">        1     11      60    2018-01-14</span>
<span class="sd">        2      9      40    2018-01-21</span>
<span class="sd">        3     13     100    2018-01-28</span>
<span class="sd">        4     14      50    2018-02-04</span>
<span class="sd">        5     18     100    2018-02-11</span>
<span class="sd">        6     17      40    2018-02-18</span>
<span class="sd">        7     19      50    2018-02-25</span>
<span class="sd">        &gt;&gt;&gt; df.resample(&#39;M&#39;, on=&#39;week_starting&#39;).mean()</span>
<span class="sd">                       price  volume</span>
<span class="sd">        week_starting</span>
<span class="sd">        2018-01-31     10.75    62.5</span>
<span class="sd">        2018-02-28     17.00    60.0</span>

<span class="sd">        For a DataFrame with MultiIndex, the keyword `level` can be used to</span>
<span class="sd">        specify on which level the resampling needs to take place.</span>

<span class="sd">        &gt;&gt;&gt; days = pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; d2 = {{&#39;price&#39;: [10, 11, 9, 13, 14, 18, 17, 19],</span>
<span class="sd">        ...       &#39;volume&#39;: [50, 60, 40, 100, 50, 100, 40, 50]}}</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame(</span>
<span class="sd">        ...     d2,</span>
<span class="sd">        ...     index=pd.MultiIndex.from_product(</span>
<span class="sd">        ...         [days, [&#39;morning&#39;, &#39;afternoon&#39;]]</span>
<span class="sd">        ...     )</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; df2</span>
<span class="sd">                              price  volume</span>
<span class="sd">        2000-01-01 morning       10      50</span>
<span class="sd">                   afternoon     11      60</span>
<span class="sd">        2000-01-02 morning        9      40</span>
<span class="sd">                   afternoon     13     100</span>
<span class="sd">        2000-01-03 morning       14      50</span>
<span class="sd">                   afternoon     18     100</span>
<span class="sd">        2000-01-04 morning       17      40</span>
<span class="sd">                   afternoon     19      50</span>
<span class="sd">        &gt;&gt;&gt; df2.resample(&#39;D&#39;, level=0).sum()</span>
<span class="sd">                    price  volume</span>
<span class="sd">        2000-01-01     21     110</span>
<span class="sd">        2000-01-02     22     140</span>
<span class="sd">        2000-01-03     32     150</span>
<span class="sd">        2000-01-04     36      90</span>

<span class="sd">        If you want to adjust the start of the bins based on a fixed timestamp:</span>

<span class="sd">        &gt;&gt;&gt; start, end = &#39;2000-10-01 23:30:00&#39;, &#39;2000-10-02 00:30:00&#39;</span>
<span class="sd">        &gt;&gt;&gt; rng = pd.date_range(start, end, freq=&#39;7min&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ts = pd.Series(np.arange(len(rng)) * 3, index=rng)</span>
<span class="sd">        &gt;&gt;&gt; ts</span>
<span class="sd">        2000-10-01 23:30:00     0</span>
<span class="sd">        2000-10-01 23:37:00     3</span>
<span class="sd">        2000-10-01 23:44:00     6</span>
<span class="sd">        2000-10-01 23:51:00     9</span>
<span class="sd">        2000-10-01 23:58:00    12</span>
<span class="sd">        2000-10-02 00:05:00    15</span>
<span class="sd">        2000-10-02 00:12:00    18</span>
<span class="sd">        2000-10-02 00:19:00    21</span>
<span class="sd">        2000-10-02 00:26:00    24</span>
<span class="sd">        Freq: 7T, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; ts.resample(&#39;17min&#39;).sum()</span>
<span class="sd">        2000-10-01 23:14:00     0</span>
<span class="sd">        2000-10-01 23:31:00     9</span>
<span class="sd">        2000-10-01 23:48:00    21</span>
<span class="sd">        2000-10-02 00:05:00    54</span>
<span class="sd">        2000-10-02 00:22:00    24</span>
<span class="sd">        Freq: 17T, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; ts.resample(&#39;17min&#39;, origin=&#39;epoch&#39;).sum()</span>
<span class="sd">        2000-10-01 23:18:00     0</span>
<span class="sd">        2000-10-01 23:35:00    18</span>
<span class="sd">        2000-10-01 23:52:00    27</span>
<span class="sd">        2000-10-02 00:09:00    39</span>
<span class="sd">        2000-10-02 00:26:00    24</span>
<span class="sd">        Freq: 17T, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; ts.resample(&#39;17min&#39;, origin=&#39;2000-01-01&#39;).sum()</span>
<span class="sd">        2000-10-01 23:24:00     3</span>
<span class="sd">        2000-10-01 23:41:00    15</span>
<span class="sd">        2000-10-01 23:58:00    45</span>
<span class="sd">        2000-10-02 00:15:00    45</span>
<span class="sd">        Freq: 17T, dtype: int64</span>

<span class="sd">        If you want to adjust the start of the bins with an `offset` Timedelta, the two</span>
<span class="sd">        following lines are equivalent:</span>

<span class="sd">        &gt;&gt;&gt; ts.resample(&#39;17min&#39;, origin=&#39;start&#39;).sum()</span>
<span class="sd">        2000-10-01 23:30:00     9</span>
<span class="sd">        2000-10-01 23:47:00    21</span>
<span class="sd">        2000-10-02 00:04:00    54</span>
<span class="sd">        2000-10-02 00:21:00    24</span>
<span class="sd">        Freq: 17T, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; ts.resample(&#39;17min&#39;, offset=&#39;23h30min&#39;).sum()</span>
<span class="sd">        2000-10-01 23:30:00     9</span>
<span class="sd">        2000-10-01 23:47:00    21</span>
<span class="sd">        2000-10-02 00:04:00    54</span>
<span class="sd">        2000-10-02 00:21:00    24</span>
<span class="sd">        Freq: 17T, dtype: int64</span>

<span class="sd">        If you want to take the largest Timestamp as the end of the bins:</span>

<span class="sd">        &gt;&gt;&gt; ts.resample(&#39;17min&#39;, origin=&#39;end&#39;).sum()</span>
<span class="sd">        2000-10-01 23:35:00     0</span>
<span class="sd">        2000-10-01 23:52:00    18</span>
<span class="sd">        2000-10-02 00:09:00    27</span>
<span class="sd">        2000-10-02 00:26:00    63</span>
<span class="sd">        Freq: 17T, dtype: int64</span>

<span class="sd">        In contrast with the `start_day`, you can use `end_day` to take the ceiling</span>
<span class="sd">        midnight of the largest Timestamp as the end of the bins and drop the bins</span>
<span class="sd">        not containing data:</span>

<span class="sd">        &gt;&gt;&gt; ts.resample(&#39;17min&#39;, origin=&#39;end_day&#39;).sum()</span>
<span class="sd">        2000-10-01 23:38:00     3</span>
<span class="sd">        2000-10-01 23:55:00    15</span>
<span class="sd">        2000-10-02 00:12:00    45</span>
<span class="sd">        2000-10-02 00:29:00    45</span>
<span class="sd">        Freq: 17T, dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.resample</span> <span class="kn">import</span> <span class="n">get_resampler</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">get_resampler</span><span class="p">(</span>
            <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;Series | DataFrame&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">rule</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
            <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
            <span class="n">convention</span><span class="o">=</span><span class="n">convention</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">group_keys</span><span class="o">=</span><span class="n">group_keys</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select initial periods of time series data based on a date offset.</span>

<span class="sd">        For a DataFrame with a sorted DatetimeIndex, this function can</span>
<span class="sd">        select the first few rows based on a date offset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : str, DateOffset or dateutil.relativedelta</span>
<span class="sd">            The offset length of the data that will be selected. For instance,</span>
<span class="sd">            &#39;1M&#39; will display all the rows having their index within the first month.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            A subset of the caller.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the index is not  a :class:`DatetimeIndex`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        last : Select final periods of time series based on a date offset.</span>
<span class="sd">        at_time : Select values at a particular time of the day.</span>
<span class="sd">        between_time : Select values between particular times of the day.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; i = pd.date_range(&#39;2018-04-09&#39;, periods=4, freq=&#39;2D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ts = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4]}, index=i)</span>
<span class="sd">        &gt;&gt;&gt; ts</span>
<span class="sd">                    A</span>
<span class="sd">        2018-04-09  1</span>
<span class="sd">        2018-04-11  2</span>
<span class="sd">        2018-04-13  3</span>
<span class="sd">        2018-04-15  4</span>

<span class="sd">        Get the rows for the first 3 days:</span>

<span class="sd">        &gt;&gt;&gt; ts.first(&#39;3D&#39;)</span>
<span class="sd">                    A</span>
<span class="sd">        2018-04-09  1</span>
<span class="sd">        2018-04-11  2</span>

<span class="sd">        Notice the data for 3 first calendar days were returned, not the first</span>
<span class="sd">        3 days observed in the dataset, and therefore data for 2018-04-13 was</span>
<span class="sd">        not returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;first&#39; only supports a DatetimeIndex index&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">Tick</span><span class="p">)</span> <span class="ow">and</span> <span class="n">offset</span><span class="o">.</span><span class="n">is_on_offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># GH#29623 if first value is end of period, remove offset with n = 1</span>
            <span class="c1">#  before adding the real offset</span>
            <span class="n">end_date</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="o">.</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_date</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="c1"># Tick-like, e.g. 3 weeks</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">Tick</span><span class="p">)</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">end_date</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select final periods of time series data based on a date offset.</span>

<span class="sd">        For a DataFrame with a sorted DatetimeIndex, this function</span>
<span class="sd">        selects the last few rows based on a date offset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : str, DateOffset, dateutil.relativedelta</span>
<span class="sd">            The offset length of the data that will be selected. For instance,</span>
<span class="sd">            &#39;3D&#39; will display all the rows having their index within the last 3 days.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            A subset of the caller.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the index is not  a :class:`DatetimeIndex`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        first : Select initial periods of time series based on a date offset.</span>
<span class="sd">        at_time : Select values at a particular time of the day.</span>
<span class="sd">        between_time : Select values between particular times of the day.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; i = pd.date_range(&#39;2018-04-09&#39;, periods=4, freq=&#39;2D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ts = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4]}, index=i)</span>
<span class="sd">        &gt;&gt;&gt; ts</span>
<span class="sd">                    A</span>
<span class="sd">        2018-04-09  1</span>
<span class="sd">        2018-04-11  2</span>
<span class="sd">        2018-04-13  3</span>
<span class="sd">        2018-04-15  4</span>

<span class="sd">        Get the rows for the last 3 days:</span>

<span class="sd">        &gt;&gt;&gt; ts.last(&#39;3D&#39;)</span>
<span class="sd">                    A</span>
<span class="sd">        2018-04-13  3</span>
<span class="sd">        2018-04-15  4</span>

<span class="sd">        Notice the data for 3 last calendar days were returned, not the last</span>
<span class="sd">        3 observed days in the dataset, and therefore data for 2018-04-11 was</span>
<span class="sd">        not returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;last&#39; only supports a DatetimeIndex index&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="n">start_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">na_option</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;keep&quot;</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pct</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute numerical data ranks (1 through n) along axis.</span>

<span class="sd">        By default, equal values are assigned a rank that is the average of the</span>
<span class="sd">        ranks of those values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Index to direct ranking.</span>
<span class="sd">            For `Series` this parameter is unused and defaults to 0.</span>
<span class="sd">        method : {&#39;average&#39;, &#39;min&#39;, &#39;max&#39;, &#39;first&#39;, &#39;dense&#39;}, default &#39;average&#39;</span>
<span class="sd">            How to rank the group of records that have the same value (i.e. ties):</span>

<span class="sd">            * average: average rank of the group</span>
<span class="sd">            * min: lowest rank in the group</span>
<span class="sd">            * max: highest rank in the group</span>
<span class="sd">            * first: ranks assigned in order they appear in the array</span>
<span class="sd">            * dense: like &#39;min&#39;, but rank always increases by 1 between groups.</span>

<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            For DataFrame objects, rank only numeric columns if set to True.</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">                The default value of ``numeric_only`` is now ``False``.</span>

<span class="sd">        na_option : {&#39;keep&#39;, &#39;top&#39;, &#39;bottom&#39;}, default &#39;keep&#39;</span>
<span class="sd">            How to rank NaN values:</span>

<span class="sd">            * keep: assign NaN rank to NaN values</span>
<span class="sd">            * top: assign lowest rank to NaN values</span>
<span class="sd">            * bottom: assign highest rank to NaN values</span>

<span class="sd">        ascending : bool, default True</span>
<span class="sd">            Whether or not the elements should be ranked in ascending order.</span>
<span class="sd">        pct : bool, default False</span>
<span class="sd">            Whether or not to display the returned rankings in percentile</span>
<span class="sd">            form.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as caller</span>
<span class="sd">            Return a Series or DataFrame with data ranks as values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        core.groupby.DataFrameGroupBy.rank : Rank of values within each group.</span>
<span class="sd">        core.groupby.SeriesGroupBy.rank : Rank of values within each group.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data={&#39;Animal&#39;: [&#39;cat&#39;, &#39;penguin&#39;, &#39;dog&#39;,</span>
<span class="sd">        ...                                    &#39;spider&#39;, &#39;snake&#39;],</span>
<span class="sd">        ...                         &#39;Number_legs&#39;: [4, 2, 4, 8, np.nan]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            Animal  Number_legs</span>
<span class="sd">        0      cat          4.0</span>
<span class="sd">        1  penguin          2.0</span>
<span class="sd">        2      dog          4.0</span>
<span class="sd">        3   spider          8.0</span>
<span class="sd">        4    snake          NaN</span>

<span class="sd">        Ties are assigned the mean of the ranks (by default) for the group.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(range(5), index=list(&quot;abcde&quot;))</span>
<span class="sd">        &gt;&gt;&gt; s[&quot;d&quot;] = s[&quot;b&quot;]</span>
<span class="sd">        &gt;&gt;&gt; s.rank()</span>
<span class="sd">        a    1.0</span>
<span class="sd">        b    2.5</span>
<span class="sd">        c    4.0</span>
<span class="sd">        d    2.5</span>
<span class="sd">        e    5.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        The following example shows how the method behaves with the above</span>
<span class="sd">        parameters:</span>

<span class="sd">        * default_rank: this is the default behaviour obtained without using</span>
<span class="sd">          any parameter.</span>
<span class="sd">        * max_rank: setting ``method = &#39;max&#39;`` the records that have the</span>
<span class="sd">          same values are ranked using the highest rank (e.g.: since &#39;cat&#39;</span>
<span class="sd">          and &#39;dog&#39; are both in the 2nd and 3rd position, rank 3 is assigned.)</span>
<span class="sd">        * NA_bottom: choosing ``na_option = &#39;bottom&#39;``, if there are records</span>
<span class="sd">          with NaN values they are placed at the bottom of the ranking.</span>
<span class="sd">        * pct_rank: when setting ``pct = True``, the ranking is expressed as</span>
<span class="sd">          percentile rank.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;default_rank&#39;] = df[&#39;Number_legs&#39;].rank()</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;max_rank&#39;] = df[&#39;Number_legs&#39;].rank(method=&#39;max&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;NA_bottom&#39;] = df[&#39;Number_legs&#39;].rank(na_option=&#39;bottom&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;pct_rank&#39;] = df[&#39;Number_legs&#39;].rank(pct=True)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            Animal  Number_legs  default_rank  max_rank  NA_bottom  pct_rank</span>
<span class="sd">        0      cat          4.0           2.5       3.0        2.5     0.625</span>
<span class="sd">        1  penguin          2.0           1.0       1.0        1.0     0.250</span>
<span class="sd">        2      dog          4.0           2.5       3.0        2.5     0.625</span>
<span class="sd">        3   spider          8.0           4.0       4.0        4.0     1.000</span>
<span class="sd">        4    snake          NaN           NaN       NaN        5.0       NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">na_option</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;keep&quot;</span><span class="p">,</span> <span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;bottom&quot;</span><span class="p">}:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;na_option must be one of &#39;keep&#39;, &#39;top&#39;, or &#39;bottom&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">ranker</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># i.e. DataFrame, we cast to ndarray</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># i.e. Series, can dispatch to EA</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_values</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
                <span class="n">ranks</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">_rank</span><span class="p">(</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis_int</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                    <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                    <span class="n">na_option</span><span class="o">=</span><span class="n">na_option</span><span class="p">,</span>
                    <span class="n">pct</span><span class="o">=</span><span class="n">pct</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ranks</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span>
                    <span class="n">values</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis_int</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                    <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                    <span class="n">na_option</span><span class="o">=</span><span class="n">na_option</span><span class="p">,</span>
                    <span class="n">pct</span><span class="o">=</span><span class="n">pct</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">ranks_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">ranks_obj</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;rank&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># GH#47500</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Series.rank does not allow numeric_only=True with &quot;</span>
                    <span class="s2">&quot;non-numeric dtype.&quot;</span>
                <span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">ranker</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;compare&quot;</span><span class="p">],</span> <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">align_axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">keep_shape</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_equal</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">result_names</span><span class="p">:</span> <span class="n">Suffixes</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="s2">&quot;other&quot;</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">cls_self</span><span class="p">,</span> <span class="n">cls_other</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;can only compare &#39;</span><span class="si">{</span><span class="n">cls_self</span><span class="si">}</span><span class="s2">&#39; (not &#39;</span><span class="si">{</span><span class="n">cls_other</span><span class="si">}</span><span class="s2">&#39;) with &#39;</span><span class="si">{</span><span class="n">cls_self</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">isna</span><span class="p">()))</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_equal</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
                <span class="n">cmask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="n">rmask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rmask</span><span class="p">,</span> <span class="n">cmask</span><span class="p">]</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rmask</span><span class="p">,</span> <span class="n">cmask</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result_names</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Passing &#39;result_names&#39; as a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">result_names</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not &quot;</span>
                <span class="s2">&quot;supported. Provide &#39;result_names&#39; as a tuple instead.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">align_axis</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">):</span>  <span class="c1"># This is needed for Series</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">align_axis</span><span class="p">)</span>

        <span class="n">diff</span> <span class="o">=</span> <span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">result_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="c1"># No need to reorganize data if stacking on new axis</span>
            <span class="c1"># This currently applies for stacking two Series on columns</span>
            <span class="k">return</span> <span class="n">diff</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

        <span class="c1"># set index names to positions to avoid confusion</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax_names</span><span class="p">))</span>

        <span class="c1"># bring self-other to inner level</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">nlevels</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="c1"># restore the index names in order</span>
        <span class="n">diff</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">ax_names</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

        <span class="c1"># reorder axis to keep things organized</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">diff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">diff</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">join</span><span class="p">:</span> <span class="n">AlignJoin</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">broadcast_axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align two objects on their axes with the specified join method.</span>

<span class="sd">        Join method is specified for each axis Index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame or Series</span>
<span class="sd">        join : {{&#39;outer&#39;, &#39;inner&#39;, &#39;left&#39;, &#39;right&#39;}}, default &#39;outer&#39;</span>
<span class="sd">        axis : allowed axis of the other object, default None</span>
<span class="sd">            Align on index (0), columns (1), or both (None).</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            Broadcast across a level, matching Index values on the</span>
<span class="sd">            passed MultiIndex level.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Always returns new objects. If copy=False and no reindexing is</span>
<span class="sd">            required then original objects are returned.</span>
<span class="sd">        fill_value : scalar, default np.NaN</span>
<span class="sd">            Value to use for missing values. Defaults to NaN, but can be any</span>
<span class="sd">            &quot;compatible&quot; value.</span>
<span class="sd">        method : {{&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}}, default None</span>
<span class="sd">            Method to use for filling holes in reindexed Series:</span>

<span class="sd">            - pad / ffill: propagate last valid observation forward to next valid.</span>
<span class="sd">            - backfill / bfill: use NEXT valid observation to fill gap.</span>

<span class="sd">        limit : int, default None</span>
<span class="sd">            If method is specified, this is the maximum number of consecutive</span>
<span class="sd">            NaN values to forward/backward fill. In other words, if there is</span>
<span class="sd">            a gap with more than this number of consecutive NaNs, it will only</span>
<span class="sd">            be partially filled. If method is not specified, this is the</span>
<span class="sd">            maximum number of entries along the entire axis where NaNs will be</span>
<span class="sd">            filled. Must be greater than 0 if not None.</span>
<span class="sd">        fill_axis : {axes_single_arg}, default 0</span>
<span class="sd">            Filling axis, method and limit.</span>
<span class="sd">        broadcast_axis : {axes_single_arg}, default None</span>
<span class="sd">            Broadcast values along this axis, if aligning two objects of</span>
<span class="sd">            different dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of ({klass}, type of other)</span>
<span class="sd">            Aligned objects.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(</span>
<span class="sd">        ...     [[1, 2, 3, 4], [6, 7, 8, 9]], columns=[&quot;D&quot;, &quot;B&quot;, &quot;E&quot;, &quot;A&quot;], index=[1, 2]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; other = pd.DataFrame(</span>
<span class="sd">        ...     [[10, 20, 30, 40], [60, 70, 80, 90], [600, 700, 800, 900]],</span>
<span class="sd">        ...     columns=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;],</span>
<span class="sd">        ...     index=[2, 3, 4],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           D  B  E  A</span>
<span class="sd">        1  1  2  3  4</span>
<span class="sd">        2  6  7  8  9</span>
<span class="sd">        &gt;&gt;&gt; other</span>
<span class="sd">            A    B    C    D</span>
<span class="sd">        2   10   20   30   40</span>
<span class="sd">        3   60   70   80   90</span>
<span class="sd">        4  600  700  800  900</span>

<span class="sd">        Align on columns:</span>

<span class="sd">        &gt;&gt;&gt; left, right = df.align(other, join=&quot;outer&quot;, axis=1)</span>
<span class="sd">        &gt;&gt;&gt; left</span>
<span class="sd">           A  B   C  D  E</span>
<span class="sd">        1  4  2 NaN  1  3</span>
<span class="sd">        2  9  7 NaN  6  8</span>
<span class="sd">        &gt;&gt;&gt; right</span>
<span class="sd">            A    B    C    D   E</span>
<span class="sd">        2   10   20   30   40 NaN</span>
<span class="sd">        3   60   70   80   90 NaN</span>
<span class="sd">        4  600  700  800  900 NaN</span>

<span class="sd">        We can also align on the index:</span>

<span class="sd">        &gt;&gt;&gt; left, right = df.align(other, join=&quot;outer&quot;, axis=0)</span>
<span class="sd">        &gt;&gt;&gt; left</span>
<span class="sd">            D    B    E    A</span>
<span class="sd">        1  1.0  2.0  3.0  4.0</span>
<span class="sd">        2  6.0  7.0  8.0  9.0</span>
<span class="sd">        3  NaN  NaN  NaN  NaN</span>
<span class="sd">        4  NaN  NaN  NaN  NaN</span>
<span class="sd">        &gt;&gt;&gt; right</span>
<span class="sd">            A      B      C      D</span>
<span class="sd">        1    NaN    NaN    NaN    NaN</span>
<span class="sd">        2   10.0   20.0   30.0   40.0</span>
<span class="sd">        3   60.0   70.0   80.0   90.0</span>
<span class="sd">        4  600.0  700.0  800.0  900.0</span>

<span class="sd">        Finally, the default `axis=None` will align on both index and columns:</span>

<span class="sd">        &gt;&gt;&gt; left, right = df.align(other, join=&quot;outer&quot;, axis=None)</span>
<span class="sd">        &gt;&gt;&gt; left</span>
<span class="sd">             A    B   C    D    E</span>
<span class="sd">        1  4.0  2.0 NaN  1.0  3.0</span>
<span class="sd">        2  9.0  7.0 NaN  6.0  8.0</span>
<span class="sd">        3  NaN  NaN NaN  NaN  NaN</span>
<span class="sd">        4  NaN  NaN NaN  NaN  NaN</span>
<span class="sd">        &gt;&gt;&gt; right</span>
<span class="sd">               A      B      C      D   E</span>
<span class="sd">        1    NaN    NaN    NaN    NaN NaN</span>
<span class="sd">        2   10.0   20.0   30.0   40.0 NaN</span>
<span class="sd">        3   60.0   70.0   80.0   90.0 NaN</span>
<span class="sd">        4  600.0  700.0  800.0  900.0 NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">method</span> <span class="o">=</span> <span class="n">clean_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">broadcast_axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
                <span class="c1"># this means other is a DataFrame, and we need to broadcast</span>
                <span class="c1"># self</span>
                <span class="n">cons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_expanddim</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">},</span> <span class="o">**</span><span class="n">other</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span>
                    <span class="n">other</span><span class="p">,</span>
                    <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                    <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                    <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                    <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
                <span class="c1"># this means self is a DataFrame, and we need to broadcast</span>
                <span class="c1"># other</span>
                <span class="n">cons</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_constructor_expanddim</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">other</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">},</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span>
                    <span class="n">df</span><span class="p">,</span>
                    <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                    <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                    <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                    <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span>
                <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_series</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span>
                <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_align_frame</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">join</span><span class="p">:</span> <span class="n">AlignJoin</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># defaults</span>
        <span class="n">join_index</span><span class="p">,</span> <span class="n">join_columns</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">ilidx</span><span class="p">,</span> <span class="n">iridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">clidx</span><span class="p">,</span> <span class="n">cridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">is_series</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">join_index</span><span class="p">,</span> <span class="n">ilidx</span><span class="p">,</span> <span class="n">iridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_series</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">join_columns</span><span class="p">,</span> <span class="n">clidx</span><span class="p">,</span> <span class="n">cridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
            <span class="n">reindexers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span> <span class="n">ilidx</span><span class="p">]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reindexers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span> <span class="n">ilidx</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">join_columns</span><span class="p">,</span> <span class="n">clidx</span><span class="p">]}</span>

        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
            <span class="n">reindexers</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">allow_dups</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="c1"># other must be always DataFrame</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
            <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span> <span class="n">iridx</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">join_columns</span><span class="p">,</span> <span class="n">cridx</span><span class="p">]},</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">allow_dups</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">_left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># needed for mypy</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">_left</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="c1"># if DatetimeIndex have different tz, convert to UTC</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">_align_as_utc</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">join_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">left</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">right</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_align_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">join</span><span class="p">:</span> <span class="n">AlignJoin</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">is_series</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_series</span> <span class="ow">and</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify axis=0 or 1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_series</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot align series to a series other than axis 0&quot;</span><span class="p">)</span>

        <span class="c1"># series/series compat, other must always be a Series</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">axis</span><span class="p">:</span>
            <span class="c1"># equal</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">join_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">ridx</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># one has &gt; 1 ndim</span>
            <span class="n">fdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">join_index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">join_index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bm_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">bm_axis</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">fdata</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">:</span>
                <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">fdata</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ridx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>

        <span class="c1"># fill</span>
        <span class="n">fill_na</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill_na</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="c1"># if DatetimeIndex have different tz, convert to UTC</span>
        <span class="k">if</span> <span class="n">is_series</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_series</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">_align_as_utc</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">join_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">left</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">right</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent to public method `where`, except that `other` is not</span>
<span class="sd">        applied as a function even if callable. Used in __setitem__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># align the cond to same shape as myself</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">NDFrame</span><span class="p">):</span>
            <span class="c1"># CoW: Make sure reference is not kept alive</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">broadcast_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array conditional must be same shape as self&quot;</span><span class="p">)</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># make sure we are boolean</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Boolean array expected for the condition, not </span><span class="si">{dtype}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">cond</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
                <span class="c1"># This is a single-dimensional object.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">cond</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_dt</span> <span class="ow">in</span> <span class="n">cond</span><span class="o">.</span><span class="n">dtypes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">_dt</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">_dt</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># GH#21947 we have an empty DataFrame/Series, could be object-dtype</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">cond</span> <span class="o">=</span> <span class="o">-</span><span class="n">cond</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="n">cond</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_number</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># try to align with other</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDFrame</span><span class="p">):</span>
            <span class="c1"># align with me</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="c1"># CoW: Make sure reference is not kept alive</span>
                <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
                    <span class="n">other</span><span class="p">,</span>
                    <span class="n">join</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                    <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># if we are NOT aligned, raise as we cannot where index</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">InvalidIndexError</span>

                <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="c1"># TODO(EA2D): avoid object-dtype cast in EA case GH#38729</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span>
                    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

                    <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># slice me out of the other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot align with a higher dimensional NDFrame&quot;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">MultiIndex</span><span class="p">,</span> <span class="n">NDFrame</span><span class="p">)):</span>
            <span class="c1"># mainly just catching Index here</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># In the ndim == 1 case we may have</span>
                    <span class="c1">#  other length 1, which we treat as scalar (GH#2745, GH#4192)</span>
                    <span class="c1">#  or len(other) == icond.sum(), which we treat like</span>
                    <span class="c1">#  __setitem__ (GH#3235)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;other must be the same shape as self when an ndarray&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># we are the same shape, so create an actual object for alignment</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                    <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">align</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">align</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># we may have different type blocks come out of putmask, so</span>
            <span class="c1"># reconstruct the block manager</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_inplace_setting</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
                <span class="n">cond</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span>
                <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">],</span>
        <span class="n">cond</span><span class="o">=</span><span class="s2">&quot;True&quot;</span><span class="p">,</span>
        <span class="n">cond_rev</span><span class="o">=</span><span class="s2">&quot;False&quot;</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;where&quot;</span><span class="p">,</span>
        <span class="n">name_other</span><span class="o">=</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace values where the condition is {cond_rev}.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cond : bool {klass}, array-like, or callable</span>
<span class="sd">            Where `cond` is {cond}, keep the original value. Where</span>
<span class="sd">            {cond_rev}, replace with corresponding value from `other`.</span>
<span class="sd">            If `cond` is callable, it is computed on the {klass} and</span>
<span class="sd">            should return boolean {klass} or array. The callable must</span>
<span class="sd">            not change input {klass} (though pandas doesn&#39;t check it).</span>
<span class="sd">        other : scalar, {klass}, or callable</span>
<span class="sd">            Entries where `cond` is {cond_rev} are replaced with</span>
<span class="sd">            corresponding value from `other`.</span>
<span class="sd">            If other is callable, it is computed on the {klass} and</span>
<span class="sd">            should return scalar or {klass}. The callable must not</span>
<span class="sd">            change input {klass} (though pandas doesn&#39;t check it).</span>
<span class="sd">            If not specified, entries will be filled with the corresponding</span>
<span class="sd">            NULL value (``np.nan`` for numpy dtypes, ``pd.NA`` for extension</span>
<span class="sd">            dtypes).</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to perform the operation in place on the data.</span>
<span class="sd">        axis : int, default None</span>
<span class="sd">            Alignment axis if needed. For `Series` this parameter is</span>
<span class="sd">            unused and defaults to 0.</span>
<span class="sd">        level : int, default None</span>
<span class="sd">            Alignment level if needed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Same type as caller or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`DataFrame.{name_other}` : Return an object of same shape as</span>
<span class="sd">            self.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The {name} method is an application of the if-then idiom. For each</span>
<span class="sd">        element in the calling DataFrame, if ``cond`` is ``{cond}`` the</span>
<span class="sd">        element is used; otherwise the corresponding element from the DataFrame</span>
<span class="sd">        ``other`` is used. If the axis of ``other`` does not align with axis of</span>
<span class="sd">        ``cond`` {klass}, the misaligned index positions will be filled with</span>
<span class="sd">        {cond_rev}.</span>

<span class="sd">        The signature for :func:`DataFrame.where` differs from</span>
<span class="sd">        :func:`numpy.where`. Roughly ``df1.where(m, df2)`` is equivalent to</span>
<span class="sd">        ``np.where(m, df1, df2)``.</span>

<span class="sd">        For further details and examples see the ``{name}`` documentation in</span>
<span class="sd">        :ref:`indexing &lt;indexing.where_mask&gt;`.</span>

<span class="sd">        The dtype of the object takes precedence. The fill value is casted to</span>
<span class="sd">        the object&#39;s dtype, if this can be done losslessly.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(range(5))</span>
<span class="sd">        &gt;&gt;&gt; s.where(s &gt; 0)</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    1.0</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    3.0</span>
<span class="sd">        4    4.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; s.mask(s &gt; 0)</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    NaN</span>
<span class="sd">        3    NaN</span>
<span class="sd">        4    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(range(5))</span>
<span class="sd">        &gt;&gt;&gt; t = pd.Series([True, False])</span>
<span class="sd">        &gt;&gt;&gt; s.where(t, 99)</span>
<span class="sd">        0     0</span>
<span class="sd">        1    99</span>
<span class="sd">        2    99</span>
<span class="sd">        3    99</span>
<span class="sd">        4    99</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.mask(t, 99)</span>
<span class="sd">        0    99</span>
<span class="sd">        1     1</span>
<span class="sd">        2    99</span>
<span class="sd">        3    99</span>
<span class="sd">        4    99</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.where(s &gt; 1, 10)</span>
<span class="sd">        0    10</span>
<span class="sd">        1    10</span>
<span class="sd">        2    2</span>
<span class="sd">        3    3</span>
<span class="sd">        4    4</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.mask(s &gt; 1, 10)</span>
<span class="sd">        0     0</span>
<span class="sd">        1     1</span>
<span class="sd">        2    10</span>
<span class="sd">        3    10</span>
<span class="sd">        4    10</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.arange(10).reshape(-1, 2), columns=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  0  1</span>
<span class="sd">        1  2  3</span>
<span class="sd">        2  4  5</span>
<span class="sd">        3  6  7</span>
<span class="sd">        4  8  9</span>
<span class="sd">        &gt;&gt;&gt; m = df % 3 == 0</span>
<span class="sd">        &gt;&gt;&gt; df.where(m, -df)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  0 -1</span>
<span class="sd">        1 -2  3</span>
<span class="sd">        2 -4 -5</span>
<span class="sd">        3  6 -7</span>
<span class="sd">        4 -8  9</span>
<span class="sd">        &gt;&gt;&gt; df.where(m, -df) == np.where(m, df, -df)</span>
<span class="sd">              A     B</span>
<span class="sd">        0  True  True</span>
<span class="sd">        1  True  True</span>
<span class="sd">        2  True  True</span>
<span class="sd">        3  True  True</span>
<span class="sd">        4  True  True</span>
<span class="sd">        &gt;&gt;&gt; df.where(m, -df) == df.mask(~m, -df)</span>
<span class="sd">              A     B</span>
<span class="sd">        0  True  True</span>
<span class="sd">        1  True  True</span>
<span class="sd">        2  True  True</span>
<span class="sd">        3  True  True</span>
<span class="sd">        4  True  True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">where</span><span class="p">,</span>
        <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">],</span>
        <span class="n">cond</span><span class="o">=</span><span class="s2">&quot;False&quot;</span><span class="p">,</span>
        <span class="n">cond_rev</span><span class="o">=</span><span class="s2">&quot;True&quot;</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span>
        <span class="n">name_other</span><span class="o">=</span><span class="s2">&quot;where&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># see gh-21891</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;__invert__&quot;</span><span class="p">):</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="o">~</span><span class="n">cond</span><span class="p">,</span>
            <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift index by desired number of periods with an optional time `freq`.</span>

<span class="sd">        When `freq` is not passed, shift the index without realigning the data.</span>
<span class="sd">        If `freq` is passed (in this case, the index must be date or datetime,</span>
<span class="sd">        or it will raise a `NotImplementedError`), the index will be</span>
<span class="sd">        increased using the periods and the `freq`. `freq` can be inferred</span>
<span class="sd">        when specified as &quot;infer&quot; as long as either freq or inferred_freq</span>
<span class="sd">        attribute is set in the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int</span>
<span class="sd">            Number of periods to shift. Can be positive or negative.</span>
<span class="sd">        freq : DateOffset, tseries.offsets, timedelta, or str, optional</span>
<span class="sd">            Offset to use from the tseries module or time rule (e.g. &#39;EOM&#39;).</span>
<span class="sd">            If `freq` is specified then the index values are shifted but the</span>
<span class="sd">            data is not realigned. That is, use `freq` if you would like to</span>
<span class="sd">            extend the index when shifting and preserve the original data.</span>
<span class="sd">            If `freq` is specified as &quot;infer&quot; then it will be inferred from</span>
<span class="sd">            the freq or inferred_freq attributes of the index. If neither of</span>
<span class="sd">            those attributes exist, a ValueError is thrown.</span>
<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}}, default None</span>
<span class="sd">            Shift direction. For `Series` this parameter is unused and defaults to 0.</span>
<span class="sd">        fill_value : object, optional</span>
<span class="sd">            The scalar value to use for newly introduced missing values.</span>
<span class="sd">            the default depends on the dtype of `self`.</span>
<span class="sd">            For numeric data, ``np.nan`` is used.</span>
<span class="sd">            For datetime, timedelta, or period data, etc. :attr:`NaT` is used.</span>
<span class="sd">            For extension dtypes, ``self.dtype.na_value`` is used.</span>

<span class="sd">            .. versionchanged:: 1.1.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass}</span>
<span class="sd">            Copy of input object, shifted.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.shift : Shift values of Index.</span>
<span class="sd">        DatetimeIndex.shift : Shift values of DatetimeIndex.</span>
<span class="sd">        PeriodIndex.shift : Shift values of PeriodIndex.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({{&quot;Col1&quot;: [10, 20, 15, 30, 45],</span>
<span class="sd">        ...                    &quot;Col2&quot;: [13, 23, 18, 33, 48],</span>
<span class="sd">        ...                    &quot;Col3&quot;: [17, 27, 22, 37, 52]}},</span>
<span class="sd">        ...                   index=pd.date_range(&quot;2020-01-01&quot;, &quot;2020-01-05&quot;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                    Col1  Col2  Col3</span>
<span class="sd">        2020-01-01    10    13    17</span>
<span class="sd">        2020-01-02    20    23    27</span>
<span class="sd">        2020-01-03    15    18    22</span>
<span class="sd">        2020-01-04    30    33    37</span>
<span class="sd">        2020-01-05    45    48    52</span>

<span class="sd">        &gt;&gt;&gt; df.shift(periods=3)</span>
<span class="sd">                    Col1  Col2  Col3</span>
<span class="sd">        2020-01-01   NaN   NaN   NaN</span>
<span class="sd">        2020-01-02   NaN   NaN   NaN</span>
<span class="sd">        2020-01-03   NaN   NaN   NaN</span>
<span class="sd">        2020-01-04  10.0  13.0  17.0</span>
<span class="sd">        2020-01-05  20.0  23.0  27.0</span>

<span class="sd">        &gt;&gt;&gt; df.shift(periods=1, axis=&quot;columns&quot;)</span>
<span class="sd">                    Col1  Col2  Col3</span>
<span class="sd">        2020-01-01   NaN    10    13</span>
<span class="sd">        2020-01-02   NaN    20    23</span>
<span class="sd">        2020-01-03   NaN    15    18</span>
<span class="sd">        2020-01-04   NaN    30    33</span>
<span class="sd">        2020-01-05   NaN    45    48</span>

<span class="sd">        &gt;&gt;&gt; df.shift(periods=3, fill_value=0)</span>
<span class="sd">                    Col1  Col2  Col3</span>
<span class="sd">        2020-01-01     0     0     0</span>
<span class="sd">        2020-01-02     0     0     0</span>
<span class="sd">        2020-01-03     0     0     0</span>
<span class="sd">        2020-01-04    10    13    17</span>
<span class="sd">        2020-01-05    20    23    27</span>

<span class="sd">        &gt;&gt;&gt; df.shift(periods=3, freq=&quot;D&quot;)</span>
<span class="sd">                    Col1  Col2  Col3</span>
<span class="sd">        2020-01-04    10    13    17</span>
<span class="sd">        2020-01-05    20    23    27</span>
<span class="sd">        2020-01-06    15    18    22</span>
<span class="sd">        2020-01-07    30    33    37</span>
<span class="sd">        2020-01-08    45    48    52</span>

<span class="sd">        &gt;&gt;&gt; df.shift(periods=3, freq=&quot;infer&quot;)</span>
<span class="sd">                    Col1  Col2  Col3</span>
<span class="sd">        2020-01-04    10    13    17</span>
<span class="sd">        2020-01-05    20    23    27</span>
<span class="sd">        2020-01-06    15    18    22</span>
<span class="sd">        2020-01-07    30    33    37</span>
<span class="sd">        2020-01-08    45    48    52</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># when freq is None, data is shifted, index is not</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span>
                <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;shift&quot;</span><span class="p">)</span>

        <span class="c1"># when freq is given, index is shifted, data is not</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="s2">&quot;infer&quot;</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;inferred_freq&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Freq was not set in the index hence cannot be inferred&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
            <span class="n">orig_freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">freq</span> <span class="o">!=</span> <span class="n">orig_freq</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">orig_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># for mypy</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Given freq </span><span class="si">{</span><span class="n">freq</span><span class="o">.</span><span class="n">rule_code</span><span class="si">}</span><span class="s2"> does not match &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;PeriodIndex freq </span><span class="si">{</span><span class="n">orig_freq</span><span class="o">.</span><span class="n">rule_code</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">new_ax</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_ax</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">new_ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;shift&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">after</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncate a Series or DataFrame before and after some index value.</span>

<span class="sd">        This is a useful shorthand for boolean indexing based on index</span>
<span class="sd">        values above or below certain thresholds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        before : date, str, int</span>
<span class="sd">            Truncate all rows before this index value.</span>
<span class="sd">        after : date, str, int</span>
<span class="sd">            Truncate all rows after this index value.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, optional</span>
<span class="sd">            Axis to truncate. Truncates the index (rows) by default.</span>
<span class="sd">            For `Series` this parameter is unused and defaults to 0.</span>
<span class="sd">        copy : bool, default is True,</span>
<span class="sd">            Return a copy of the truncated section.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type of caller</span>
<span class="sd">            The truncated Series or DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.loc : Select a subset of a DataFrame by label.</span>
<span class="sd">        DataFrame.iloc : Select a subset of a DataFrame by position.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the index being truncated contains only datetime values,</span>
<span class="sd">        `before` and `after` may be specified as strings instead of</span>
<span class="sd">        Timestamps.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],</span>
<span class="sd">        ...                    &#39;B&#39;: [&#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;],</span>
<span class="sd">        ...                    &#39;C&#39;: [&#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;]},</span>
<span class="sd">        ...                   index=[1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B  C</span>
<span class="sd">        1  a  f  k</span>
<span class="sd">        2  b  g  l</span>
<span class="sd">        3  c  h  m</span>
<span class="sd">        4  d  i  n</span>
<span class="sd">        5  e  j  o</span>

<span class="sd">        &gt;&gt;&gt; df.truncate(before=2, after=4)</span>
<span class="sd">           A  B  C</span>
<span class="sd">        2  b  g  l</span>
<span class="sd">        3  c  h  m</span>
<span class="sd">        4  d  i  n</span>

<span class="sd">        The columns of a DataFrame can be truncated.</span>

<span class="sd">        &gt;&gt;&gt; df.truncate(before=&quot;A&quot;, after=&quot;B&quot;, axis=&quot;columns&quot;)</span>
<span class="sd">           A  B</span>
<span class="sd">        1  a  f</span>
<span class="sd">        2  b  g</span>
<span class="sd">        3  c  h</span>
<span class="sd">        4  d  i</span>
<span class="sd">        5  e  j</span>

<span class="sd">        For Series, only rows can be truncated.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;A&#39;].truncate(before=2, after=4)</span>
<span class="sd">        2    b</span>
<span class="sd">        3    c</span>
<span class="sd">        4    d</span>
<span class="sd">        Name: A, dtype: object</span>

<span class="sd">        The index values in ``truncate`` can be datetimes or string</span>
<span class="sd">        dates.</span>

<span class="sd">        &gt;&gt;&gt; dates = pd.date_range(&#39;2016-01-01&#39;, &#39;2016-02-01&#39;, freq=&#39;s&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(index=dates, data={&#39;A&#39;: 1})</span>
<span class="sd">        &gt;&gt;&gt; df.tail()</span>
<span class="sd">                             A</span>
<span class="sd">        2016-01-31 23:59:56  1</span>
<span class="sd">        2016-01-31 23:59:57  1</span>
<span class="sd">        2016-01-31 23:59:58  1</span>
<span class="sd">        2016-01-31 23:59:59  1</span>
<span class="sd">        2016-02-01 00:00:00  1</span>

<span class="sd">        &gt;&gt;&gt; df.truncate(before=pd.Timestamp(&#39;2016-01-05&#39;),</span>
<span class="sd">        ...             after=pd.Timestamp(&#39;2016-01-10&#39;)).tail()</span>
<span class="sd">                             A</span>
<span class="sd">        2016-01-09 23:59:56  1</span>
<span class="sd">        2016-01-09 23:59:57  1</span>
<span class="sd">        2016-01-09 23:59:58  1</span>
<span class="sd">        2016-01-09 23:59:59  1</span>
<span class="sd">        2016-01-10 00:00:00  1</span>

<span class="sd">        Because the index is a DatetimeIndex containing only dates, we can</span>
<span class="sd">        specify `before` and `after` as strings. They will be coerced to</span>
<span class="sd">        Timestamps before truncation.</span>

<span class="sd">        &gt;&gt;&gt; df.truncate(&#39;2016-01-05&#39;, &#39;2016-01-10&#39;).tail()</span>
<span class="sd">                             A</span>
<span class="sd">        2016-01-09 23:59:56  1</span>
<span class="sd">        2016-01-09 23:59:57  1</span>
<span class="sd">        2016-01-09 23:59:58  1</span>
<span class="sd">        2016-01-09 23:59:59  1</span>
<span class="sd">        2016-01-10 00:00:00  1</span>

<span class="sd">        Note that ``truncate`` assumes a 0 value for any unspecified time</span>
<span class="sd">        component (midnight). This differs from partial string slicing, which</span>
<span class="sd">        returns any partially matching dates.</span>

<span class="sd">        &gt;&gt;&gt; df.loc[&#39;2016-01-05&#39;:&#39;2016-01-10&#39;, :].tail()</span>
<span class="sd">                             A</span>
<span class="sd">        2016-01-10 23:59:55  1</span>
<span class="sd">        2016-01-10 23:59:56  1</span>
<span class="sd">        2016-01-10 23:59:57  1</span>
<span class="sd">        2016-01-10 23:59:58  1</span>
<span class="sd">        2016-01-10 23:59:59  1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># GH 17935</span>
        <span class="c1"># Check that index is sorted</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_monotonic_increasing</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;truncate requires a sorted index&quot;</span><span class="p">)</span>

        <span class="c1"># if we have a date index, convert to dates, otherwise</span>
        <span class="c1"># treat like a slice</span>
        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">_is_all_dates</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.core.tools.datetimes</span> <span class="kn">import</span> <span class="n">to_datetime</span>

            <span class="n">before</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>
            <span class="n">after</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">before</span> <span class="o">&gt;</span> <span class="n">after</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Truncate: </span><span class="si">{</span><span class="n">after</span><span class="si">}</span><span class="s2"> must be after </span><span class="si">{</span><span class="n">before</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span> <span class="ow">and</span> <span class="n">ax</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">before</span><span class="p">,</span> <span class="n">after</span> <span class="o">=</span> <span class="n">after</span><span class="p">,</span> <span class="n">before</span>

        <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span>
        <span class="n">slicer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">ax</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">tz_convert</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert tz-aware axis to target time zone.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : str or tzinfo object or None</span>
<span class="sd">            Target time zone. Passing ``None`` will convert to</span>
<span class="sd">            UTC and remove the timezone information.</span>
<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;}}, default 0</span>
<span class="sd">            The axis to convert</span>
<span class="sd">        level : int, str, default None</span>
<span class="sd">            If axis is a MultiIndex, convert a specific level. Otherwise</span>
<span class="sd">            must be None.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Also make a copy of the underlying data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass}</span>
<span class="sd">            Object with time zone converted axis.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the axis is tz-naive.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Change to another time zone:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(</span>
<span class="sd">        ...     [1],</span>
<span class="sd">        ...     index=pd.DatetimeIndex([&#39;2018-09-15 01:30:00+02:00&#39;]),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s.tz_convert(&#39;Asia/Shanghai&#39;)</span>
<span class="sd">        2018-09-15 07:30:00+08:00    1</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Pass None to convert to UTC and get a tz-naive index:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1],</span>
<span class="sd">        ...     index=pd.DatetimeIndex([&#39;2018-09-15 01:30:00+02:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.tz_convert(None)</span>
<span class="sd">        2018-09-14 23:30:00    1</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;tz_convert&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ax_name</span><span class="si">}</span><span class="s2"> is not a valid DatetimeIndex or PeriodIndex&quot;</span>
                    <span class="p">)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">([],</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ax</span>

        <span class="c1"># if a level is given it must be a MultiIndex level or</span>
        <span class="c1"># equivalent to the axis name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">new_level</span> <span class="o">=</span> <span class="n">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">tz</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_levels</span><span class="p">(</span><span class="n">new_level</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The level </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2"> is not valid&quot;</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">())</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;tz_convert&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">tz_localize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ambiguous</span><span class="p">:</span> <span class="n">TimeAmbiguous</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">nonexistent</span><span class="p">:</span> <span class="n">TimeNonexistent</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Localize tz-naive index of a Series or DataFrame to target time zone.</span>

<span class="sd">        This operation localizes the Index. To localize the values in a</span>
<span class="sd">        timezone-naive Series, use :meth:`Series.dt.tz_localize`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : str or tzinfo or None</span>
<span class="sd">            Time zone to localize. Passing ``None`` will remove the</span>
<span class="sd">            time zone information and preserve local time.</span>
<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;}}, default 0</span>
<span class="sd">            The axis to localize</span>
<span class="sd">        level : int, str, default None</span>
<span class="sd">            If axis ia a MultiIndex, localize a specific level. Otherwise</span>
<span class="sd">            must be None.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Also make a copy of the underlying data.</span>
<span class="sd">        ambiguous : &#39;infer&#39;, bool-ndarray, &#39;NaT&#39;, default &#39;raise&#39;</span>
<span class="sd">            When clocks moved backward due to DST, ambiguous times may arise.</span>
<span class="sd">            For example in Central European Time (UTC+01), when going from</span>
<span class="sd">            03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at</span>
<span class="sd">            00:30:00 UTC and at 01:30:00 UTC. In such a situation, the</span>
<span class="sd">            `ambiguous` parameter dictates how ambiguous times should be</span>
<span class="sd">            handled.</span>

<span class="sd">            - &#39;infer&#39; will attempt to infer fall dst-transition hours based on</span>
<span class="sd">              order</span>
<span class="sd">            - bool-ndarray where True signifies a DST time, False designates</span>
<span class="sd">              a non-DST time (note that this flag is only applicable for</span>
<span class="sd">              ambiguous times)</span>
<span class="sd">            - &#39;NaT&#39; will return NaT where there are ambiguous times</span>
<span class="sd">            - &#39;raise&#39; will raise an AmbiguousTimeError if there are ambiguous</span>
<span class="sd">              times.</span>
<span class="sd">        nonexistent : str, default &#39;raise&#39;</span>
<span class="sd">            A nonexistent time does not exist in a particular timezone</span>
<span class="sd">            where clocks moved forward due to DST. Valid values are:</span>

<span class="sd">            - &#39;shift_forward&#39; will shift the nonexistent time forward to the</span>
<span class="sd">              closest existing time</span>
<span class="sd">            - &#39;shift_backward&#39; will shift the nonexistent time backward to the</span>
<span class="sd">              closest existing time</span>
<span class="sd">            - &#39;NaT&#39; will return NaT where there are nonexistent times</span>
<span class="sd">            - timedelta objects will shift nonexistent times by the timedelta</span>
<span class="sd">            - &#39;raise&#39; will raise an NonExistentTimeError if there are</span>
<span class="sd">              nonexistent times.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {klass}</span>
<span class="sd">            Same type as the input.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the TimeSeries is tz-aware and tz is not None.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Localize local times:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(</span>
<span class="sd">        ...     [1],</span>
<span class="sd">        ...     index=pd.DatetimeIndex([&#39;2018-09-15 01:30:00&#39;]),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;CET&#39;)</span>
<span class="sd">        2018-09-15 01:30:00+02:00    1</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Pass None to convert to tz-naive index and preserve local time:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1],</span>
<span class="sd">        ...     index=pd.DatetimeIndex([&#39;2018-09-15 01:30:00+02:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(None)</span>
<span class="sd">        2018-09-15 01:30:00    1</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Be careful with DST changes. When there is sequential data, pandas</span>
<span class="sd">        can infer the DST time:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(range(7),</span>
<span class="sd">        ...               index=pd.DatetimeIndex([&#39;2018-10-28 01:30:00&#39;,</span>
<span class="sd">        ...                                       &#39;2018-10-28 02:00:00&#39;,</span>
<span class="sd">        ...                                       &#39;2018-10-28 02:30:00&#39;,</span>
<span class="sd">        ...                                       &#39;2018-10-28 02:00:00&#39;,</span>
<span class="sd">        ...                                       &#39;2018-10-28 02:30:00&#39;,</span>
<span class="sd">        ...                                       &#39;2018-10-28 03:00:00&#39;,</span>
<span class="sd">        ...                                       &#39;2018-10-28 03:30:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;CET&#39;, ambiguous=&#39;infer&#39;)</span>
<span class="sd">        2018-10-28 01:30:00+02:00    0</span>
<span class="sd">        2018-10-28 02:00:00+02:00    1</span>
<span class="sd">        2018-10-28 02:30:00+02:00    2</span>
<span class="sd">        2018-10-28 02:00:00+01:00    3</span>
<span class="sd">        2018-10-28 02:30:00+01:00    4</span>
<span class="sd">        2018-10-28 03:00:00+01:00    5</span>
<span class="sd">        2018-10-28 03:30:00+01:00    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        In some cases, inferring the DST is impossible. In such cases, you can</span>
<span class="sd">        pass an ndarray to the ambiguous parameter to set the DST explicitly</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(range(3),</span>
<span class="sd">        ...               index=pd.DatetimeIndex([&#39;2018-10-28 01:20:00&#39;,</span>
<span class="sd">        ...                                       &#39;2018-10-28 02:36:00&#39;,</span>
<span class="sd">        ...                                       &#39;2018-10-28 03:46:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;CET&#39;, ambiguous=np.array([True, True, False]))</span>
<span class="sd">        2018-10-28 01:20:00+02:00    0</span>
<span class="sd">        2018-10-28 02:36:00+02:00    1</span>
<span class="sd">        2018-10-28 03:46:00+01:00    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        If the DST transition causes nonexistent times, you can shift these</span>
<span class="sd">        dates forward or backward with a timedelta object or `&#39;shift_forward&#39;`</span>
<span class="sd">        or `&#39;shift_backward&#39;`.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(range(2),</span>
<span class="sd">        ...               index=pd.DatetimeIndex([&#39;2015-03-29 02:30:00&#39;,</span>
<span class="sd">        ...                                       &#39;2015-03-29 03:30:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;Europe/Warsaw&#39;, nonexistent=&#39;shift_forward&#39;)</span>
<span class="sd">        2015-03-29 03:00:00+02:00    0</span>
<span class="sd">        2015-03-29 03:30:00+02:00    1</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;Europe/Warsaw&#39;, nonexistent=&#39;shift_backward&#39;)</span>
<span class="sd">        2015-03-29 01:59:59.999999999+01:00    0</span>
<span class="sd">        2015-03-29 03:30:00+02:00              1</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;Europe/Warsaw&#39;, nonexistent=pd.Timedelta(&#39;1H&#39;))</span>
<span class="sd">        2015-03-29 03:30:00+02:00    0</span>
<span class="sd">        2015-03-29 03:30:00+02:00    1</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nonexistent_options</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;NaT&quot;</span><span class="p">,</span> <span class="s2">&quot;shift_forward&quot;</span><span class="p">,</span> <span class="s2">&quot;shift_backward&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nonexistent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nonexistent_options</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">nonexistent</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The nonexistent argument must be one of &#39;raise&#39;, &quot;</span>
                <span class="s2">&quot;&#39;NaT&#39;, &#39;shift_forward&#39;, &#39;shift_backward&#39; or &quot;</span>
                <span class="s2">&quot;a timedelta object&quot;</span>
            <span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;tz_localize&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ax_name</span><span class="si">}</span><span class="s2"> is not a valid DatetimeIndex or PeriodIndex&quot;</span>
                    <span class="p">)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">([],</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="o">=</span><span class="n">nonexistent</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ax</span>

        <span class="c1"># if a level is given it must be a MultiIndex level or</span>
        <span class="c1"># equivalent to the axis name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">new_level</span> <span class="o">=</span> <span class="n">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_levels</span><span class="p">(</span><span class="n">new_level</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The level </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2"> is not valid&quot;</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">())</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;tz_localize&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Numeric Methods</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">percentiles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate descriptive statistics.</span>

<span class="sd">        Descriptive statistics include those that summarize the central</span>
<span class="sd">        tendency, dispersion and shape of a</span>
<span class="sd">        dataset&#39;s distribution, excluding ``NaN`` values.</span>

<span class="sd">        Analyzes both numeric and object series, as well</span>
<span class="sd">        as ``DataFrame`` column sets of mixed data types. The output</span>
<span class="sd">        will vary depending on what is provided. Refer to the notes</span>
<span class="sd">        below for more detail.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        percentiles : list-like of numbers, optional</span>
<span class="sd">            The percentiles to include in the output. All should</span>
<span class="sd">            fall between 0 and 1. The default is</span>
<span class="sd">            ``[.25, .5, .75]``, which returns the 25th, 50th, and</span>
<span class="sd">            75th percentiles.</span>
<span class="sd">        include : &#39;all&#39;, list-like of dtypes or None (default), optional</span>
<span class="sd">            A white list of data types to include in the result. Ignored</span>
<span class="sd">            for ``Series``. Here are the options:</span>

<span class="sd">            - &#39;all&#39; : All columns of the input will be included in the output.</span>
<span class="sd">            - A list-like of dtypes : Limits the results to the</span>
<span class="sd">              provided data types.</span>
<span class="sd">              To limit the result to numeric types submit</span>
<span class="sd">              ``numpy.number``. To limit it instead to object columns submit</span>
<span class="sd">              the ``numpy.object`` data type. Strings</span>
<span class="sd">              can also be used in the style of</span>
<span class="sd">              ``select_dtypes`` (e.g. ``df.describe(include=[&#39;O&#39;])``). To</span>
<span class="sd">              select pandas categorical columns, use ``&#39;category&#39;``</span>
<span class="sd">            - None (default) : The result will include all numeric columns.</span>
<span class="sd">        exclude : list-like of dtypes or None (default), optional,</span>
<span class="sd">            A black list of data types to omit from the result. Ignored</span>
<span class="sd">            for ``Series``. Here are the options:</span>

<span class="sd">            - A list-like of dtypes : Excludes the provided data types</span>
<span class="sd">              from the result. To exclude numeric types submit</span>
<span class="sd">              ``numpy.number``. To exclude object columns submit the data</span>
<span class="sd">              type ``numpy.object``. Strings can also be used in the style of</span>
<span class="sd">              ``select_dtypes`` (e.g. ``df.describe(exclude=[&#39;O&#39;])``). To</span>
<span class="sd">              exclude pandas categorical columns, use ``&#39;category&#39;``</span>
<span class="sd">            - None (default) : The result will exclude nothing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Summary statistics of the Series or Dataframe provided.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.count: Count number of non-NA/null observations.</span>
<span class="sd">        DataFrame.max: Maximum of the values in the object.</span>
<span class="sd">        DataFrame.min: Minimum of the values in the object.</span>
<span class="sd">        DataFrame.mean: Mean of the values.</span>
<span class="sd">        DataFrame.std: Standard deviation of the observations.</span>
<span class="sd">        DataFrame.select_dtypes: Subset of a DataFrame including/excluding</span>
<span class="sd">            columns based on their dtype.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For numeric data, the result&#39;s index will include ``count``,</span>
<span class="sd">        ``mean``, ``std``, ``min``, ``max`` as well as lower, ``50`` and</span>
<span class="sd">        upper percentiles. By default the lower percentile is ``25`` and the</span>
<span class="sd">        upper percentile is ``75``. The ``50`` percentile is the</span>
<span class="sd">        same as the median.</span>

<span class="sd">        For object data (e.g. strings or timestamps), the result&#39;s index</span>
<span class="sd">        will include ``count``, ``unique``, ``top``, and ``freq``. The ``top``</span>
<span class="sd">        is the most common value. The ``freq`` is the most common value&#39;s</span>
<span class="sd">        frequency. Timestamps also include the ``first`` and ``last`` items.</span>

<span class="sd">        If multiple object values have the highest count, then the</span>
<span class="sd">        ``count`` and ``top`` results will be arbitrarily chosen from</span>
<span class="sd">        among those with the highest count.</span>

<span class="sd">        For mixed data types provided via a ``DataFrame``, the default is to</span>
<span class="sd">        return only an analysis of numeric columns. If the dataframe consists</span>
<span class="sd">        only of object and categorical data without any numeric columns, the</span>
<span class="sd">        default is to return an analysis of both the object and categorical</span>
<span class="sd">        columns. If ``include=&#39;all&#39;`` is provided as an option, the result</span>
<span class="sd">        will include a union of attributes of each type.</span>

<span class="sd">        The `include` and `exclude` parameters can be used to limit</span>
<span class="sd">        which columns in a ``DataFrame`` are analyzed for the output.</span>
<span class="sd">        The parameters are ignored when analyzing a ``Series``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Describing a numeric ``Series``.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; s.describe()</span>
<span class="sd">        count    3.0</span>
<span class="sd">        mean     2.0</span>
<span class="sd">        std      1.0</span>
<span class="sd">        min      1.0</span>
<span class="sd">        25%      1.5</span>
<span class="sd">        50%      2.0</span>
<span class="sd">        75%      2.5</span>
<span class="sd">        max      3.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Describing a categorical ``Series``.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s.describe()</span>
<span class="sd">        count     4</span>
<span class="sd">        unique    3</span>
<span class="sd">        top       a</span>
<span class="sd">        freq      2</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Describing a timestamp ``Series``.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([</span>
<span class="sd">        ...     np.datetime64(&quot;2000-01-01&quot;),</span>
<span class="sd">        ...     np.datetime64(&quot;2010-01-01&quot;),</span>
<span class="sd">        ...     np.datetime64(&quot;2010-01-01&quot;)</span>
<span class="sd">        ... ])</span>
<span class="sd">        &gt;&gt;&gt; s.describe()</span>
<span class="sd">        count                      3</span>
<span class="sd">        mean     2006-09-01 08:00:00</span>
<span class="sd">        min      2000-01-01 00:00:00</span>
<span class="sd">        25%      2004-12-31 12:00:00</span>
<span class="sd">        50%      2010-01-01 00:00:00</span>
<span class="sd">        75%      2010-01-01 00:00:00</span>
<span class="sd">        max      2010-01-01 00:00:00</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Describing a ``DataFrame``. By default only numeric fields</span>
<span class="sd">        are returned.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;categorical&#39;: pd.Categorical([&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]),</span>
<span class="sd">        ...                    &#39;numeric&#39;: [1, 2, 3],</span>
<span class="sd">        ...                    &#39;object&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">        ...                   })</span>
<span class="sd">        &gt;&gt;&gt; df.describe()</span>
<span class="sd">               numeric</span>
<span class="sd">        count      3.0</span>
<span class="sd">        mean       2.0</span>
<span class="sd">        std        1.0</span>
<span class="sd">        min        1.0</span>
<span class="sd">        25%        1.5</span>
<span class="sd">        50%        2.0</span>
<span class="sd">        75%        2.5</span>
<span class="sd">        max        3.0</span>

<span class="sd">        Describing all columns of a ``DataFrame`` regardless of data type.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=&#39;all&#39;)  # doctest: +SKIP</span>
<span class="sd">               categorical  numeric object</span>
<span class="sd">        count            3      3.0      3</span>
<span class="sd">        unique           3      NaN      3</span>
<span class="sd">        top              f      NaN      a</span>
<span class="sd">        freq             1      NaN      1</span>
<span class="sd">        mean           NaN      2.0    NaN</span>
<span class="sd">        std            NaN      1.0    NaN</span>
<span class="sd">        min            NaN      1.0    NaN</span>
<span class="sd">        25%            NaN      1.5    NaN</span>
<span class="sd">        50%            NaN      2.0    NaN</span>
<span class="sd">        75%            NaN      2.5    NaN</span>
<span class="sd">        max            NaN      3.0    NaN</span>

<span class="sd">        Describing a column from a ``DataFrame`` by accessing it as</span>
<span class="sd">        an attribute.</span>

<span class="sd">        &gt;&gt;&gt; df.numeric.describe()</span>
<span class="sd">        count    3.0</span>
<span class="sd">        mean     2.0</span>
<span class="sd">        std      1.0</span>
<span class="sd">        min      1.0</span>
<span class="sd">        25%      1.5</span>
<span class="sd">        50%      2.0</span>
<span class="sd">        75%      2.5</span>
<span class="sd">        max      3.0</span>
<span class="sd">        Name: numeric, dtype: float64</span>

<span class="sd">        Including only numeric columns in a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=[np.number])</span>
<span class="sd">               numeric</span>
<span class="sd">        count      3.0</span>
<span class="sd">        mean       2.0</span>
<span class="sd">        std        1.0</span>
<span class="sd">        min        1.0</span>
<span class="sd">        25%        1.5</span>
<span class="sd">        50%        2.0</span>
<span class="sd">        75%        2.5</span>
<span class="sd">        max        3.0</span>

<span class="sd">        Including only string columns in a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=[object])  # doctest: +SKIP</span>
<span class="sd">               object</span>
<span class="sd">        count       3</span>
<span class="sd">        unique      3</span>
<span class="sd">        top         a</span>
<span class="sd">        freq        1</span>

<span class="sd">        Including only categorical columns from a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=[&#39;category&#39;])</span>
<span class="sd">               categorical</span>
<span class="sd">        count            3</span>
<span class="sd">        unique           3</span>
<span class="sd">        top              d</span>
<span class="sd">        freq             1</span>

<span class="sd">        Excluding numeric columns from a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(exclude=[np.number])  # doctest: +SKIP</span>
<span class="sd">               categorical object</span>
<span class="sd">        count            3      3</span>
<span class="sd">        unique           3      3</span>
<span class="sd">        top              f      a</span>
<span class="sd">        freq             1      1</span>

<span class="sd">        Excluding object columns from a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(exclude=[object])  # doctest: +SKIP</span>
<span class="sd">               categorical  numeric</span>
<span class="sd">        count            3      3.0</span>
<span class="sd">        unique           3      NaN</span>
<span class="sd">        top              f      NaN</span>
<span class="sd">        freq             1      NaN</span>
<span class="sd">        mean           NaN      2.0</span>
<span class="sd">        std            NaN      1.0</span>
<span class="sd">        min            NaN      1.0</span>
<span class="sd">        25%            NaN      1.5</span>
<span class="sd">        50%            NaN      2.0</span>
<span class="sd">        75%            NaN      2.5</span>
<span class="sd">        max            NaN      3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">describe_ndframe</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">include</span><span class="o">=</span><span class="n">include</span><span class="p">,</span>
            <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">,</span>
            <span class="n">percentiles</span><span class="o">=</span><span class="n">percentiles</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">pct_change</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span>
        <span class="n">periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">fill_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;backfill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;pad&quot;</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Percentage change between the current and a prior element.</span>

<span class="sd">        Computes the percentage change from the immediately previous row by</span>
<span class="sd">        default. This is useful in comparing the percentage of change in a time</span>
<span class="sd">        series of elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int, default 1</span>
<span class="sd">            Periods to shift for forming percent change.</span>
<span class="sd">        fill_method : {&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}, default &#39;pad&#39;</span>
<span class="sd">            How to handle NAs **before** computing percent changes.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            The number of consecutive NAs to fill before stopping.</span>
<span class="sd">        freq : DateOffset, timedelta, or str, optional</span>
<span class="sd">            Increment to use from time series API (e.g. &#39;M&#39; or BDay()).</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments are passed into</span>
<span class="sd">            `DataFrame.shift` or `Series.shift`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            The same type as the calling object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.diff : Compute the difference of two elements in a Series.</span>
<span class="sd">        DataFrame.diff : Compute the difference of two elements in a DataFrame.</span>
<span class="sd">        Series.shift : Shift the index by some number of periods.</span>
<span class="sd">        DataFrame.shift : Shift the index by some number of periods.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Series**</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([90, 91, 85])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    90</span>
<span class="sd">        1    91</span>
<span class="sd">        2    85</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.pct_change()</span>
<span class="sd">        0         NaN</span>
<span class="sd">        1    0.011111</span>
<span class="sd">        2   -0.065934</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.pct_change(periods=2)</span>
<span class="sd">        0         NaN</span>
<span class="sd">        1         NaN</span>
<span class="sd">        2   -0.055556</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        See the percentage change in a Series where filling NAs with last</span>
<span class="sd">        valid observation forward to next valid.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([90, 91, None, 85])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    90.0</span>
<span class="sd">        1    91.0</span>
<span class="sd">        2     NaN</span>
<span class="sd">        3    85.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.pct_change(fill_method=&#39;ffill&#39;)</span>
<span class="sd">        0         NaN</span>
<span class="sd">        1    0.011111</span>
<span class="sd">        2    0.000000</span>
<span class="sd">        3   -0.065934</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        **DataFrame**</span>

<span class="sd">        Percentage change in French franc, Deutsche Mark, and Italian lira from</span>
<span class="sd">        1980-01-01 to 1980-03-01.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...     &#39;FR&#39;: [4.0405, 4.0963, 4.3149],</span>
<span class="sd">        ...     &#39;GR&#39;: [1.7246, 1.7482, 1.8519],</span>
<span class="sd">        ...     &#39;IT&#39;: [804.74, 810.01, 860.13]},</span>
<span class="sd">        ...     index=[&#39;1980-01-01&#39;, &#39;1980-02-01&#39;, &#39;1980-03-01&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                        FR      GR      IT</span>
<span class="sd">        1980-01-01  4.0405  1.7246  804.74</span>
<span class="sd">        1980-02-01  4.0963  1.7482  810.01</span>
<span class="sd">        1980-03-01  4.3149  1.8519  860.13</span>

<span class="sd">        &gt;&gt;&gt; df.pct_change()</span>
<span class="sd">                          FR        GR        IT</span>
<span class="sd">        1980-01-01       NaN       NaN       NaN</span>
<span class="sd">        1980-02-01  0.013810  0.013684  0.006549</span>
<span class="sd">        1980-03-01  0.053365  0.059318  0.061876</span>

<span class="sd">        Percentage of change in GOOG and APPL stock volume. Shows computing</span>
<span class="sd">        the percentage change between columns.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...     &#39;2016&#39;: [1769950, 30586265],</span>
<span class="sd">        ...     &#39;2015&#39;: [1500923, 40912316],</span>
<span class="sd">        ...     &#39;2014&#39;: [1371819, 41403351]},</span>
<span class="sd">        ...     index=[&#39;GOOG&#39;, &#39;APPL&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                  2016      2015      2014</span>
<span class="sd">        GOOG   1769950   1500923   1371819</span>
<span class="sd">        APPL  30586265  40912316  41403351</span>

<span class="sd">        &gt;&gt;&gt; df.pct_change(axis=&#39;columns&#39;, periods=-1)</span>
<span class="sd">                  2016      2015  2014</span>
<span class="sd">        GOOG  0.179241  0.094112   NaN</span>
<span class="sd">        APPL -0.252395 -0.011860   NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fill_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># needed for mypy</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_data</span>

        <span class="n">shifted</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Unsupported left operand type for / (&quot;NDFrameT&quot;)</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">data</span> <span class="o">/</span> <span class="n">shifted</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># type: ignore[operator]</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Shift method is implemented differently when freq is not None</span>
            <span class="c1"># We want to restore the original index</span>
            <span class="n">rs</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">rs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()]</span>
            <span class="n">rs</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rs</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;pct_change&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_logical_func</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">func</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">bool_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">bool_t</span><span class="p">:</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_logical_func</span><span class="p">((),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">skipna</span><span class="p">,</span> <span class="s2">&quot;skipna&quot;</span><span class="p">,</span> <span class="n">none_allowed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Reduce along one dimension then the other, to simplify DataFrame._reduce</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logical_func</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bool_only</span><span class="o">=</span><span class="n">bool_only</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">_logical_func</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">arrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="c1"># TODO(EA2D): special-case not needed</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">arrays</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">kwargs</span>
        <span class="p">):</span>
            <span class="c1"># Fastpath avoiding potentially expensive transpose</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="n">bool_only</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bool_data</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">_reduce_axis1</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="o">=</span><span class="n">bool_only</span><span class="p">,</span>
            <span class="n">filter_type</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">bool_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">bool_t</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logical_func</span><span class="p">(</span>
            <span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanany</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">bool_only</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">bool_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">bool_t</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logical_func</span><span class="p">(</span>
            <span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanall</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">bool_only</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_accum_func</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">func</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">skipna</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_cum_func_with_skipna</span><span class="p">(</span><span class="n">skipna</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">_accum_func</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>  <span class="c1"># noqa: B026</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">def</span> <span class="nf">block_accum_func</span><span class="p">(</span><span class="n">blk_values</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">blk_values</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">blk_values</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">blk_values</span>

            <span class="n">result</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">ExtensionArray</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">_accumulate</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">na_accum_func</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">block_accum_func</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cummax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accum_func</span><span class="p">(</span>
            <span class="s2">&quot;cummax&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">cummin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accum_func</span><span class="p">(</span>
            <span class="s2">&quot;cummin&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accum_func</span><span class="p">(</span><span class="s2">&quot;cumsum&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accum_func</span><span class="p">(</span><span class="s2">&quot;cumprod&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_stat_function_ddof</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">func</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_stat_ddof_func</span><span class="p">((),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">skipna</span><span class="p">,</span> <span class="s2">&quot;skipna&quot;</span><span class="p">,</span> <span class="n">none_allowed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">sem</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_function_ddof</span><span class="p">(</span>
            <span class="s2">&quot;sem&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nansem</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_function_ddof</span><span class="p">(</span>
            <span class="s2">&quot;var&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanvar</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_function_ddof</span><span class="p">(</span>
            <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanstd</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_stat_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">func</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_median</span><span class="p">((),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_stat_func</span><span class="p">((),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">skipna</span><span class="p">,</span> <span class="s2">&quot;skipna&quot;</span><span class="p">,</span> <span class="n">none_allowed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_function</span><span class="p">(</span>
            <span class="s2">&quot;min&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmin</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_function</span><span class="p">(</span>
            <span class="s2">&quot;max&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmax</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_function</span><span class="p">(</span>
            <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">median</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_function</span><span class="p">(</span>
            <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_function</span><span class="p">(</span>
            <span class="s2">&quot;skew&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanskew</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">kurt</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_function</span><span class="p">(</span>
            <span class="s2">&quot;kurt&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nankurt</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="n">kurtosis</span> <span class="o">=</span> <span class="n">kurt</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_min_count_stat_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">func</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_sum</span><span class="p">((),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;prod&quot;</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_prod</span><span class="p">((),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_stat_func</span><span class="p">((),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">skipna</span><span class="p">,</span> <span class="s2">&quot;skipna&quot;</span><span class="p">,</span> <span class="n">none_allowed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="n">min_count</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_count_stat_function</span><span class="p">(</span>
            <span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nansum</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="n">min_count</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">prod</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_count_stat_function</span><span class="p">(</span>
            <span class="s2">&quot;prod&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanprod</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">,</span>
            <span class="n">min_count</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">product</span> <span class="o">=</span> <span class="n">prod</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_numeric_operations</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the operations to the cls; evaluate the doc strings again</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis_descr</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span> <span class="o">=</span> <span class="n">_doc_params</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_bool_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="n">_any_desc</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="n">_any_see_also</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_any_examples</span><span class="p">,</span>
            <span class="n">empty_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">any</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">bool_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">bool_only</span><span class="o">=</span><span class="n">bool_only</span><span class="p">,</span>
                <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="nb">any</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_bool_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="n">_all_desc</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="n">_all_see_also</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_all_examples</span><span class="p">,</span>
            <span class="n">empty_value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">bool_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">bool_only</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="nb">all</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_num_ddof_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return unbiased standard error of the mean over requested &quot;</span>
            <span class="s2">&quot;axis.</span><span class="se">\n\n</span><span class="s2">Normalized by N-1 by default. This can be changed &quot;</span>
            <span class="s2">&quot;using the ddof argument&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">notes</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">sem</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">sem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;sem&quot;</span><span class="p">,</span> <span class="n">sem</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_num_ddof_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return unbiased variance over requested axis.</span><span class="se">\n\n</span><span class="s2">Normalized by &quot;</span>
            <span class="s2">&quot;N-1 by default. This can be changed using the ddof argument.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">notes</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_var_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">var</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;var&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_num_ddof_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return sample standard deviation over requested axis.&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Normalized by N-1 by default. This can be changed using the &quot;</span>
            <span class="s2">&quot;ddof argument.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">notes</span><span class="o">=</span><span class="n">_std_notes</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_std_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">std</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_cnum_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;minimum&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">accum_func_name</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_cummin_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">cummin</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">cummin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;cummin&quot;</span><span class="p">,</span> <span class="n">cummin</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_cnum_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;maximum&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">accum_func_name</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_cummax_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">cummax</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">cummax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;cummax&quot;</span><span class="p">,</span> <span class="n">cummax</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_cnum_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">accum_func_name</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_cumsum_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;cumsum&quot;</span><span class="p">,</span> <span class="n">cumsum</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_cnum_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;product&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">accum_func_name</span><span class="o">=</span><span class="s2">&quot;prod&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_cumprod_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;cumprod&quot;</span><span class="p">,</span> <span class="n">cumprod</span><span class="p">)</span>

        <span class="c1"># error: Untyped decorator makes function &quot;sum&quot; untyped</span>
        <span class="nd">@doc</span><span class="p">(</span>  <span class="c1"># type: ignore[misc]</span>
            <span class="n">_num_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return the sum of the values over the requested axis.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;This is equivalent to the method ``numpy.sum``.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="n">_min_count_stub</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="n">_stat_func_see_also</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_sum_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="n">min_count</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_num_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return the product of the values over the requested axis.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="n">_min_count_stub</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="n">_stat_func_see_also</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_prod_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">prod</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="n">min_count</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="n">prod</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">product</span> <span class="o">=</span> <span class="n">prod</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_num_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return the mean of the values over the requested axis.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">mean</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_num_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return unbiased skew over requested axis.</span><span class="se">\n\n</span><span class="s2">Normalized by N-1.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;skew&quot;</span><span class="p">,</span> <span class="n">skew</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_num_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return unbiased kurtosis over requested axis.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Kurtosis obtained using Fisher&#39;s definition of</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;kurtosis (kurtosis of normal == 0.0). Normalized &quot;</span>
            <span class="s2">&quot;by N-1.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">kurt</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">kurt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;kurt&quot;</span><span class="p">,</span> <span class="n">kurt</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">kurtosis</span> <span class="o">=</span> <span class="n">kurt</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_num_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return the median of the values over the requested axis.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">median</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">median</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_num_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return the maximum of the values over the requested axis.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;If you want the *index* of the maximum, use ``idxmax``. This is &quot;</span>
            <span class="s2">&quot;the equivalent of the ``numpy.ndarray`` method ``argmax``.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="n">_stat_func_see_also</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_max_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">max</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>

        <span class="nd">@doc</span><span class="p">(</span>
            <span class="n">_num_doc</span><span class="p">,</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return the minimum of the values over the requested axis.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;If you want the *index* of the minimum, use ``idxmin``. This is &quot;</span>
            <span class="s2">&quot;the equivalent of the ``numpy.ndarray`` method ``argmin``.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="n">_stat_func_see_also</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_min_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">min</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">skipna</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">Rolling</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rolling</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">window</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">BaseOffset</span> <span class="o">|</span> <span class="n">BaseIndexer</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">win_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">on</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">closed</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Window</span> <span class="o">|</span> <span class="n">Rolling</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">win_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Window</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span>
                <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                <span class="n">win_type</span><span class="o">=</span><span class="n">win_type</span><span class="p">,</span>
                <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">Rolling</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">win_type</span><span class="o">=</span><span class="n">win_type</span><span class="p">,</span>
            <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
            <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">Expanding</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">expanding</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expanding</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Expanding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">ExponentialMovingWindow</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ewm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">com</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">span</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">halflife</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">TimedeltaConvertibleTypes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">adjust</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ignore_na</span><span class="p">:</span> <span class="n">bool_t</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExponentialMovingWindow</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ExponentialMovingWindow</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">com</span><span class="o">=</span><span class="n">com</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span>
            <span class="n">halflife</span><span class="o">=</span><span class="n">halflife</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span>
            <span class="n">adjust</span><span class="o">=</span><span class="n">adjust</span><span class="p">,</span>
            <span class="n">ignore_na</span><span class="o">=</span><span class="n">ignore_na</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Arithmetic Methods</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_inplace_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap arithmetic method to operate inplace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># GH#36498 this inplace op can _actually_ be inplace.</span>
            <span class="c1"># Item &quot;ArrayManager&quot; of &quot;Union[ArrayManager, SingleArrayManager,</span>
            <span class="c1"># BlockManager, SingleBlockManager]&quot; has no attribute &quot;setitem_inplace&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">setitem_inplace</span><span class="p">(</span>  <span class="c1"># type: ignore[union-attr]</span>
                <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">result</span><span class="o">.</span><span class="n">_values</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Delete cacher</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_cacher</span><span class="p">()</span>

        <span class="c1"># this makes sure that we are aligned like the input</span>
        <span class="c1"># we are updating inplace so we want to ignore is_copy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span>
            <span class="n">result</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">verify_is_copy</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="c1"># error: Unsupported left operand type for + (&quot;Type[NDFrame]&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__add__</span><span class="p">)</span>  <span class="c1"># type: ignore[operator]</span>

    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="c1"># error: Unsupported left operand type for - (&quot;Type[NDFrame]&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__sub__</span><span class="p">)</span>  <span class="c1"># type: ignore[operator]</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="c1"># error: Unsupported left operand type for * (&quot;Type[NDFrame]&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">)</span>  <span class="c1"># type: ignore[operator]</span>

    <span class="k">def</span> <span class="fm">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="c1"># error: Unsupported left operand type for / (&quot;Type[NDFrame]&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_method</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__truediv__</span>  <span class="c1"># type: ignore[operator]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ifloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="c1"># error: Unsupported left operand type for // (&quot;Type[NDFrame]&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_method</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__floordiv__</span>  <span class="c1"># type: ignore[operator]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__imod__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="c1"># error: Unsupported left operand type for % (&quot;Type[NDFrame]&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__mod__</span><span class="p">)</span>  <span class="c1"># type: ignore[operator]</span>

    <span class="k">def</span> <span class="fm">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="c1"># error: Unsupported left operand type for ** (&quot;Type[NDFrame]&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__pow__</span><span class="p">)</span>  <span class="c1"># type: ignore[operator]</span>

    <span class="k">def</span> <span class="fm">__iand__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="c1"># error: Unsupported left operand type for &amp; (&quot;Type[NDFrame]&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__and__</span><span class="p">)</span>  <span class="c1"># type: ignore[operator]</span>

    <span class="k">def</span> <span class="fm">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="c1"># error: Unsupported left operand type for | (&quot;Type[NDFrame]&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__or__</span><span class="p">)</span>  <span class="c1"># type: ignore[operator]</span>

    <span class="k">def</span> <span class="fm">__ixor__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDFrameT</span><span class="p">:</span>
        <span class="c1"># error: Unsupported left operand type for ^ (&quot;Type[NDFrame]&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplace_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__xor__</span><span class="p">)</span>  <span class="c1"># type: ignore[operator]</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Misc methods</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_find_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the index of the first valid value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        how : {&#39;first&#39;, &#39;last&#39;}</span>
<span class="sd">            Use this parameter to change between the first or last valid index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx_first_valid : type of index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idxpos</span> <span class="o">=</span> <span class="n">find_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">is_valid</span><span class="o">=~</span><span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">idxpos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">idxpos</span><span class="p">]</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">first_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index for {position} non-NA value or None, if no non-NA value is found.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type of index</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If all elements are non-NA/null, returns None.</span>
<span class="sd">        Also returns None for empty {klass}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_valid_index</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">first_valid_index</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s2">&quot;last&quot;</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">last_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_valid_index</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s2">&quot;last&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_doc_params</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tuple of the doc params.&quot;&quot;&quot;</span>
    <span class="n">axis_descr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">)&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)])</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;scalar&quot;</span>
    <span class="n">name2</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span>


<span class="n">_num_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">{desc}</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : </span><span class="si">{axis_descr}</span>
<span class="s2">    Axis for the function to be applied on.</span>
<span class="s2">    For `Series` this parameter is unused and defaults to 0.</span>

<span class="s2">    For DataFrames, specifying ``axis=None`` will apply the aggregation</span>
<span class="s2">    across both axes.</span>

<span class="s2">    .. versionadded:: 2.0.0</span>

<span class="s2">skipna : bool, default True</span>
<span class="s2">    Exclude NA/null values when computing the result.</span>
<span class="s2">numeric_only : bool, default False</span>
<span class="s2">    Include only float, int, boolean columns. Not implemented for Series.</span>

<span class="si">{min_count}</span><span class="se">\</span>
<span class="s2">**kwargs</span>
<span class="s2">    Additional keyword arguments to be passed to the function.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">{name1}</span><span class="s2"> or scalar</span><span class="se">\</span>
<span class="si">{see_also}</span><span class="se">\</span>
<span class="si">{examples}</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_num_ddof_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">{desc}</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : </span><span class="si">{axis_descr}</span>
<span class="s2">    For `Series` this parameter is unused and defaults to 0.</span>
<span class="s2">skipna : bool, default True</span>
<span class="s2">    Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="s2">    will be NA.</span>
<span class="s2">ddof : int, default 1</span>
<span class="s2">    Delta Degrees of Freedom. The divisor used in calculations is N - ddof,</span>
<span class="s2">    where N represents the number of elements.</span>
<span class="s2">numeric_only : bool, default False</span>
<span class="s2">    Include only float, int, boolean columns. Not implemented for Series.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">{name1}</span><span class="s2"> or </span><span class="si">{name2}</span><span class="s2"> (if level specified) </span><span class="se">\</span>
<span class="si">{notes}</span><span class="se">\</span>
<span class="si">{examples}</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_std_notes</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">Notes</span>
<span class="s2">-----</span>
<span class="s2">To have the same behaviour as `numpy.std`, use `ddof=0` (instead of the</span>
<span class="s2">default `ddof=1`)&quot;&quot;&quot;</span>

<span class="n">_std_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({&#39;person_id&#39;: [0, 1, 2, 3],</span>
<span class="s2">...                    &#39;age&#39;: [21, 25, 62, 43],</span>
<span class="s2">...                    &#39;height&#39;: [1.61, 1.87, 1.49, 2.01]}</span>
<span class="s2">...                   ).set_index(&#39;person_id&#39;)</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">           age  height</span>
<span class="s2">person_id</span>
<span class="s2">0           21    1.61</span>
<span class="s2">1           25    1.87</span>
<span class="s2">2           62    1.49</span>
<span class="s2">3           43    2.01</span>

<span class="s2">The standard deviation of the columns can be found as follows:</span>

<span class="s2">&gt;&gt;&gt; df.std()</span>
<span class="s2">age       18.786076</span>
<span class="s2">height     0.237417</span>
<span class="s2">dtype: float64</span>

<span class="s2">Alternatively, `ddof=0` can be set to normalize by N instead of N-1:</span>

<span class="s2">&gt;&gt;&gt; df.std(ddof=0)</span>
<span class="s2">age       16.269219</span>
<span class="s2">height     0.205609</span>
<span class="s2">dtype: float64&quot;&quot;&quot;</span>

<span class="n">_var_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({&#39;person_id&#39;: [0, 1, 2, 3],</span>
<span class="s2">...                   &#39;age&#39;: [21, 25, 62, 43],</span>
<span class="s2">...                   &#39;height&#39;: [1.61, 1.87, 1.49, 2.01]}</span>
<span class="s2">...                  ).set_index(&#39;person_id&#39;)</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">           age  height</span>
<span class="s2">person_id</span>
<span class="s2">0           21    1.61</span>
<span class="s2">1           25    1.87</span>
<span class="s2">2           62    1.49</span>
<span class="s2">3           43    2.01</span>

<span class="s2">&gt;&gt;&gt; df.var()</span>
<span class="s2">age       352.916667</span>
<span class="s2">height      0.056367</span>
<span class="s2">dtype: float64</span>

<span class="s2">Alternatively, ``ddof=0`` can be set to normalize by N instead of N-1:</span>

<span class="s2">&gt;&gt;&gt; df.var(ddof=0)</span>
<span class="s2">age       264.687500</span>
<span class="s2">height      0.042275</span>
<span class="s2">dtype: float64&quot;&quot;&quot;</span>

<span class="n">_bool_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">{desc}</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}}, default 0</span>
<span class="s2">    Indicate which axis or axes should be reduced. For `Series` this parameter</span>
<span class="s2">    is unused and defaults to 0.</span>

<span class="s2">    * 0 / &#39;index&#39; : reduce the index, return a Series whose index is the</span>
<span class="s2">      original column labels.</span>
<span class="s2">    * 1 / &#39;columns&#39; : reduce the columns, return a Series whose index is the</span>
<span class="s2">      original index.</span>
<span class="s2">    * None : reduce all axes, return a scalar.</span>

<span class="s2">bool_only : bool, default None</span>
<span class="s2">    Include only boolean columns. If None, will attempt to use everything,</span>
<span class="s2">    then use only boolean data. Not implemented for Series.</span>
<span class="s2">skipna : bool, default True</span>
<span class="s2">    Exclude NA/null values. If the entire row/column is NA and skipna is</span>
<span class="s2">    True, then the result will be </span><span class="si">{empty_value}</span><span class="s2">, as for an empty row/column.</span>
<span class="s2">    If skipna is False, then NA are treated as True, because these are not</span>
<span class="s2">    equal to zero.</span>
<span class="s2">**kwargs : any, default None</span>
<span class="s2">    Additional keywords have no effect but might be accepted for</span>
<span class="s2">    compatibility with NumPy.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">{name1}</span><span class="s2"> or </span><span class="si">{name2}</span>
<span class="s2">    If level is specified, then, </span><span class="si">{name2}</span><span class="s2"> is returned; otherwise, </span><span class="si">{name1}</span>
<span class="s2">    is returned.</span>

<span class="si">{see_also}</span>
<span class="si">{examples}</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_all_desc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Return whether all elements are True, potentially over an axis.</span>

<span class="s2">Returns True unless there at least one element within a series or</span>
<span class="s2">along a Dataframe axis that is False or equivalent (e.g. zero or</span>
<span class="s2">empty).&quot;&quot;&quot;</span>

<span class="n">_all_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">&gt;&gt;&gt; pd.Series([True, True]).all()</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; pd.Series([True, False]).all()</span>
<span class="s2">False</span>
<span class="s2">&gt;&gt;&gt; pd.Series([], dtype=&quot;float64&quot;).all()</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).all()</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).all(skipna=False)</span>
<span class="s2">True</span>

<span class="s2">**DataFrames**</span>

<span class="s2">Create a dataframe from a dictionary.</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [True, True], &#39;col2&#39;: [True, False]})</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">   col1   col2</span>
<span class="s2">0  True   True</span>
<span class="s2">1  True  False</span>

<span class="s2">Default behaviour checks if values in each column all return True.</span>

<span class="s2">&gt;&gt;&gt; df.all()</span>
<span class="s2">col1     True</span>
<span class="s2">col2    False</span>
<span class="s2">dtype: bool</span>

<span class="s2">Specify ``axis=&#39;columns&#39;`` to check if values in each row all return True.</span>

<span class="s2">&gt;&gt;&gt; df.all(axis=&#39;columns&#39;)</span>
<span class="s2">0     True</span>
<span class="s2">1    False</span>
<span class="s2">dtype: bool</span>

<span class="s2">Or ``axis=None`` for whether every value is True.</span>

<span class="s2">&gt;&gt;&gt; df.all(axis=None)</span>
<span class="s2">False</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_all_see_also</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">Series.all : Return True if all elements are True.</span>
<span class="s2">DataFrame.any : Return True if one (or more) elements are True.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cnum_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Return cumulative </span><span class="si">{desc}</span><span class="s2"> over a DataFrame or Series axis.</span>

<span class="s2">Returns a DataFrame or Series of the same size containing the cumulative</span>
<span class="si">{desc}</span><span class="s2">.</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;}}, default 0</span>
<span class="s2">    The index or the name of the axis. 0 is equivalent to None or &#39;index&#39;.</span>
<span class="s2">    For `Series` this parameter is unused and defaults to 0.</span>
<span class="s2">skipna : bool, default True</span>
<span class="s2">    Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="s2">    will be NA.</span>
<span class="s2">*args, **kwargs</span>
<span class="s2">    Additional keywords have no effect but might be accepted for</span>
<span class="s2">    compatibility with NumPy.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">{name1}</span><span class="s2"> or </span><span class="si">{name2}</span>
<span class="s2">    Return cumulative </span><span class="si">{desc}</span><span class="s2"> of </span><span class="si">{name1}</span><span class="s2"> or </span><span class="si">{name2}</span><span class="s2">.</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">core.window.expanding.Expanding.</span><span class="si">{accum_func_name}</span><span class="s2"> : Similar functionality</span>
<span class="s2">    but ignores ``NaN`` values.</span>
<span class="si">{name2}</span><span class="s2">.</span><span class="si">{accum_func_name}</span><span class="s2"> : Return the </span><span class="si">{desc}</span><span class="s2"> over</span>
<span class="s2">    </span><span class="si">{name2}</span><span class="s2"> axis.</span>
<span class="si">{name2}</span><span class="s2">.cummax : Return cumulative maximum over </span><span class="si">{name2}</span><span class="s2"> axis.</span>
<span class="si">{name2}</span><span class="s2">.cummin : Return cumulative minimum over </span><span class="si">{name2}</span><span class="s2"> axis.</span>
<span class="si">{name2}</span><span class="s2">.cumsum : Return cumulative sum over </span><span class="si">{name2}</span><span class="s2"> axis.</span>
<span class="si">{name2}</span><span class="s2">.cumprod : Return cumulative product over </span><span class="si">{name2}</span><span class="s2"> axis.</span>

<span class="si">{examples}</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cummin_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])</span>
<span class="s2">&gt;&gt;&gt; s</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    5.0</span>
<span class="s2">3   -1.0</span>
<span class="s2">4    0.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">By default, NA values are ignored.</span>

<span class="s2">&gt;&gt;&gt; s.cummin()</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    2.0</span>
<span class="s2">3   -1.0</span>
<span class="s2">4   -1.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">To include NA values in the operation, use ``skipna=False``</span>

<span class="s2">&gt;&gt;&gt; s.cummin(skipna=False)</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    NaN</span>
<span class="s2">3    NaN</span>
<span class="s2">4    NaN</span>
<span class="s2">dtype: float64</span>

<span class="s2">**DataFrame**</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],</span>
<span class="s2">...                    [3.0, np.nan],</span>
<span class="s2">...                    [1.0, 0.0]],</span>
<span class="s2">...                   columns=list(&#39;AB&#39;))</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>

<span class="s2">By default, iterates over rows and finds the minimum</span>
<span class="s2">in each column. This is equivalent to ``axis=None`` or ``axis=&#39;index&#39;``.</span>

<span class="s2">&gt;&gt;&gt; df.cummin()</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  2.0  NaN</span>
<span class="s2">2  1.0  0.0</span>

<span class="s2">To iterate over columns and find the minimum in each row,</span>
<span class="s2">use ``axis=1``</span>

<span class="s2">&gt;&gt;&gt; df.cummin(axis=1)</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cumsum_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])</span>
<span class="s2">&gt;&gt;&gt; s</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    5.0</span>
<span class="s2">3   -1.0</span>
<span class="s2">4    0.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">By default, NA values are ignored.</span>

<span class="s2">&gt;&gt;&gt; s.cumsum()</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    7.0</span>
<span class="s2">3    6.0</span>
<span class="s2">4    6.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">To include NA values in the operation, use ``skipna=False``</span>

<span class="s2">&gt;&gt;&gt; s.cumsum(skipna=False)</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    NaN</span>
<span class="s2">3    NaN</span>
<span class="s2">4    NaN</span>
<span class="s2">dtype: float64</span>

<span class="s2">**DataFrame**</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],</span>
<span class="s2">...                    [3.0, np.nan],</span>
<span class="s2">...                    [1.0, 0.0]],</span>
<span class="s2">...                   columns=list(&#39;AB&#39;))</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>

<span class="s2">By default, iterates over rows and finds the sum</span>
<span class="s2">in each column. This is equivalent to ``axis=None`` or ``axis=&#39;index&#39;``.</span>

<span class="s2">&gt;&gt;&gt; df.cumsum()</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  5.0  NaN</span>
<span class="s2">2  6.0  1.0</span>

<span class="s2">To iterate over columns and find the sum in each row,</span>
<span class="s2">use ``axis=1``</span>

<span class="s2">&gt;&gt;&gt; df.cumsum(axis=1)</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  3.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  1.0</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cumprod_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])</span>
<span class="s2">&gt;&gt;&gt; s</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    5.0</span>
<span class="s2">3   -1.0</span>
<span class="s2">4    0.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">By default, NA values are ignored.</span>

<span class="s2">&gt;&gt;&gt; s.cumprod()</span>
<span class="s2">0     2.0</span>
<span class="s2">1     NaN</span>
<span class="s2">2    10.0</span>
<span class="s2">3   -10.0</span>
<span class="s2">4    -0.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">To include NA values in the operation, use ``skipna=False``</span>

<span class="s2">&gt;&gt;&gt; s.cumprod(skipna=False)</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    NaN</span>
<span class="s2">3    NaN</span>
<span class="s2">4    NaN</span>
<span class="s2">dtype: float64</span>

<span class="s2">**DataFrame**</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],</span>
<span class="s2">...                    [3.0, np.nan],</span>
<span class="s2">...                    [1.0, 0.0]],</span>
<span class="s2">...                   columns=list(&#39;AB&#39;))</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>

<span class="s2">By default, iterates over rows and finds the product</span>
<span class="s2">in each column. This is equivalent to ``axis=None`` or ``axis=&#39;index&#39;``.</span>

<span class="s2">&gt;&gt;&gt; df.cumprod()</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  6.0  NaN</span>
<span class="s2">2  6.0  0.0</span>

<span class="s2">To iterate over columns and find the product in each row,</span>
<span class="s2">use ``axis=1``</span>

<span class="s2">&gt;&gt;&gt; df.cumprod(axis=1)</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  2.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cummax_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])</span>
<span class="s2">&gt;&gt;&gt; s</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    5.0</span>
<span class="s2">3   -1.0</span>
<span class="s2">4    0.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">By default, NA values are ignored.</span>

<span class="s2">&gt;&gt;&gt; s.cummax()</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    5.0</span>
<span class="s2">3    5.0</span>
<span class="s2">4    5.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">To include NA values in the operation, use ``skipna=False``</span>

<span class="s2">&gt;&gt;&gt; s.cummax(skipna=False)</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    NaN</span>
<span class="s2">3    NaN</span>
<span class="s2">4    NaN</span>
<span class="s2">dtype: float64</span>

<span class="s2">**DataFrame**</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],</span>
<span class="s2">...                    [3.0, np.nan],</span>
<span class="s2">...                    [1.0, 0.0]],</span>
<span class="s2">...                   columns=list(&#39;AB&#39;))</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>

<span class="s2">By default, iterates over rows and finds the maximum</span>
<span class="s2">in each column. This is equivalent to ``axis=None`` or ``axis=&#39;index&#39;``.</span>

<span class="s2">&gt;&gt;&gt; df.cummax()</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  3.0  1.0</span>

<span class="s2">To iterate over columns and find the maximum in each row,</span>
<span class="s2">use ``axis=1``</span>

<span class="s2">&gt;&gt;&gt; df.cummax(axis=1)</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  2.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  1.0</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_any_see_also</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">numpy.any : Numpy version of this method.</span>
<span class="s2">Series.any : Return whether any element is True.</span>
<span class="s2">Series.all : Return whether all elements are True.</span>
<span class="s2">DataFrame.any : Return whether any element is True over requested axis.</span>
<span class="s2">DataFrame.all : Return whether all elements are True over requested axis.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_any_desc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Return whether any element is True, potentially over an axis.</span>

<span class="s2">Returns False unless there is at least one element within a series or</span>
<span class="s2">along a Dataframe axis that is True or equivalent (e.g. non-zero or</span>
<span class="s2">non-empty).&quot;&quot;&quot;</span>

<span class="n">_any_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">For Series input, the output is a scalar indicating whether any element</span>
<span class="s2">is True.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([False, False]).any()</span>
<span class="s2">False</span>
<span class="s2">&gt;&gt;&gt; pd.Series([True, False]).any()</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; pd.Series([], dtype=&quot;float64&quot;).any()</span>
<span class="s2">False</span>
<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).any()</span>
<span class="s2">False</span>
<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).any(skipna=False)</span>
<span class="s2">True</span>

<span class="s2">**DataFrame**</span>

<span class="s2">Whether each column contains at least one True element (the default).</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2], &quot;B&quot;: [0, 2], &quot;C&quot;: [0, 0]})</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">   A  B  C</span>
<span class="s2">0  1  0  0</span>
<span class="s2">1  2  2  0</span>

<span class="s2">&gt;&gt;&gt; df.any()</span>
<span class="s2">A     True</span>
<span class="s2">B     True</span>
<span class="s2">C    False</span>
<span class="s2">dtype: bool</span>

<span class="s2">Aggregating over the columns.</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [True, False], &quot;B&quot;: [1, 2]})</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">       A  B</span>
<span class="s2">0   True  1</span>
<span class="s2">1  False  2</span>

<span class="s2">&gt;&gt;&gt; df.any(axis=&#39;columns&#39;)</span>
<span class="s2">0    True</span>
<span class="s2">1    True</span>
<span class="s2">dtype: bool</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [True, False], &quot;B&quot;: [1, 0]})</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">       A  B</span>
<span class="s2">0   True  1</span>
<span class="s2">1  False  0</span>

<span class="s2">&gt;&gt;&gt; df.any(axis=&#39;columns&#39;)</span>
<span class="s2">0    True</span>
<span class="s2">1    False</span>
<span class="s2">dtype: bool</span>

<span class="s2">Aggregating over the entire DataFrame with ``axis=None``.</span>

<span class="s2">&gt;&gt;&gt; df.any(axis=None)</span>
<span class="s2">True</span>

<span class="s2">`any` for an empty DataFrame is an empty Series.</span>

<span class="s2">&gt;&gt;&gt; pd.DataFrame([]).any()</span>
<span class="s2">Series([], dtype: bool)</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_shared_docs</span><span class="p">[</span>
    <span class="s2">&quot;stat_func_example&quot;</span>
<span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([</span>
<span class="s2">...     [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],</span>
<span class="s2">...     [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],</span>
<span class="s2">...     names=[&#39;blooded&#39;, &#39;animal&#39;])</span>
<span class="s2">&gt;&gt;&gt; s = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)</span>
<span class="s2">&gt;&gt;&gt; s</span>
<span class="s2">blooded  animal</span>
<span class="s2">warm     dog       4</span>
<span class="s2">         falcon    2</span>
<span class="s2">cold     fish      0</span>
<span class="s2">         spider    8</span>
<span class="s2">Name: legs, dtype: int64</span>

<span class="s2">&gt;&gt;&gt; s.</span><span class="si">{stat_func}</span><span class="s2">()</span>
<span class="si">{default_output}</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_sum_examples</span> <span class="o">=</span> <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;stat_func_example&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">stat_func</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">verb</span><span class="o">=</span><span class="s2">&quot;Sum&quot;</span><span class="p">,</span> <span class="n">default_output</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">level_output_0</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">level_output_1</span><span class="o">=</span><span class="mi">8</span>
<span class="p">)</span>

<span class="n">_sum_examples</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">By default, the sum of an empty or all-NA Series is ``0``.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([], dtype=&quot;float64&quot;).sum()  # min_count=0 is the default</span>
<span class="s2">0.0</span>

<span class="s2">This can be controlled with the ``min_count`` parameter. For example, if</span>
<span class="s2">you&#39;d like the sum of an empty series to be NaN, pass ``min_count=1``.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([], dtype=&quot;float64&quot;).sum(min_count=1)</span>
<span class="s2">nan</span>

<span class="s2">Thanks to the ``skipna`` parameter, ``min_count`` handles all-NA and</span>
<span class="s2">empty series identically.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).sum()</span>
<span class="s2">0.0</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).sum(min_count=1)</span>
<span class="s2">nan&quot;&quot;&quot;</span>

<span class="n">_max_examples</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;stat_func_example&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">stat_func</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">verb</span><span class="o">=</span><span class="s2">&quot;Max&quot;</span><span class="p">,</span> <span class="n">default_output</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">level_output_0</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">level_output_1</span><span class="o">=</span><span class="mi">8</span>
<span class="p">)</span>

<span class="n">_min_examples</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;stat_func_example&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">stat_func</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">verb</span><span class="o">=</span><span class="s2">&quot;Min&quot;</span><span class="p">,</span> <span class="n">default_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level_output_0</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">level_output_1</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>

<span class="n">_stat_func_see_also</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">Series.sum : Return the sum.</span>
<span class="s2">Series.min : Return the minimum.</span>
<span class="s2">Series.max : Return the maximum.</span>
<span class="s2">Series.idxmin : Return the index of the minimum.</span>
<span class="s2">Series.idxmax : Return the index of the maximum.</span>
<span class="s2">DataFrame.sum : Return the sum over the requested axis.</span>
<span class="s2">DataFrame.min : Return the minimum over the requested axis.</span>
<span class="s2">DataFrame.max : Return the maximum over the requested axis.</span>
<span class="s2">DataFrame.idxmin : Return the index of the minimum over the requested axis.</span>
<span class="s2">DataFrame.idxmax : Return the index of the maximum over the requested axis.&quot;&quot;&quot;</span>

<span class="n">_prod_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">By default, the product of an empty or all-NA Series is ``1``</span>

<span class="s2">&gt;&gt;&gt; pd.Series([], dtype=&quot;float64&quot;).prod()</span>
<span class="s2">1.0</span>

<span class="s2">This can be controlled with the ``min_count`` parameter</span>

<span class="s2">&gt;&gt;&gt; pd.Series([], dtype=&quot;float64&quot;).prod(min_count=1)</span>
<span class="s2">nan</span>

<span class="s2">Thanks to the ``skipna`` parameter, ``min_count`` handles all-NA and</span>
<span class="s2">empty series identically.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).prod()</span>
<span class="s2">1.0</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).prod(min_count=1)</span>
<span class="s2">nan&quot;&quot;&quot;</span>

<span class="n">_min_count_stub</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">min_count : int, default 0</span>
<span class="s2">    The required number of valid values to perform the operation. If fewer than</span>
<span class="s2">    ``min_count`` non-NA values are present the result will be NA.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_align_as_utc</span><span class="p">(</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">NDFrameT</span><span class="p">,</span> <span class="n">join_index</span><span class="p">:</span> <span class="n">Index</span> <span class="o">|</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">NDFrameT</span><span class="p">,</span> <span class="n">NDFrameT</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If we are aligning timezone-aware DatetimeIndexes and the timezones</span>
<span class="sd">    do not match, convert both to UTC.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">join_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># GH#33671 ensure we don&#39;t change the index on</span>
                <span class="c1">#  our original Series (NB: by default deep=False)</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">left</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">join_index</span>
                <span class="n">right</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">join_index</span>

    <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso Furlanello, and Daniel Hug.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>