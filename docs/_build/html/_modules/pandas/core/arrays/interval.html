<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pandas.core.arrays.interval &mdash; BabyDragon  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            BabyDragon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tasks:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/llm_task.html">LLMReader</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/llm_task.html#llmwriter">LLMWriter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/multi_kernel_task.html">MultiKernelTask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/base_task.html">BaseTask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/topic_tree_task.html">TopicTreeTask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/embedding_task.html">EmbeddingTask</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Kernels:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/memory_kernel.html">MemoryKernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_clustering.html">ClusterPaths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_clustering.html#hdbscanpaths">HDBSCANPaths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_clustering.html#spectralclusteringpaths">SpectralClusteringPaths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel.html">MultiKernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel.html#hdbscanmultikernel">HDBSCANMultiKernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel.html#spectralclusteringmultikernel">SpectralClusteringMultiKernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel_visualization.html">MultiKernelVisualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel_visualization.html#multikernelstabilityanalysis">MultiKernelStabilityAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_utils.html">kernel_utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Threads:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/base_thread.html">BaseThread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/fifo_thread.html">FifoThread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/vector_thread.html">VectorThread</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Indexes:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/memory_index.html">MemoryIndex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/pandas_index.html">PandasIndex</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Chat:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/base_chat.html">Prompter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/base_chat.html#basechat">BaseChat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/memory_chat.html">FifoChat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/memory_chat.html#vectorchat">VectorChat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/memory_chat.html#fifovectorchat">FifoVectorChat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/chat.html">Chat</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utils:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/pandas.html">pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/hf_datasets.html">hf_datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/chatml.html">chatml</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/embedders:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/ada2.html">OpenAiEmbedder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/cohere.html">CohereEmbedder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/sbert.html">SBERTEmbedder</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/generators:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/chatgpt.html">chatgpt</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Processors:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/github_processors.html">GithubProcessor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/os_processor.html">OsProcessor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/git_metadata.html">IssueParser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/git_metadata.html#commitparser">CommitParser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html">FunctionCallFinder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html#multiplicationcountervisitor">MultiplicationCounterVisitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html#functionandclassvisitor">FunctionAndClassVisitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html#typingcollector">TypingCollector</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html">PythonMinifier</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html#pythondocstringextractor">PythonDocstringExtractor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html#functionandclassvisitor">FunctionAndClassVisitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html#pythonparser">PythonParser</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Apps:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html">SubjectPerspectiveAnalyzer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html#ideation">Ideation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html#ideacluster">IdeaCluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html#summarizer">Summarizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html#perspectivepromptgenerator">PerspectivePromptGenerator</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">BabyDragon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pandas.core.arrays.interval</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pandas.core.arrays.interval</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">le</span><span class="p">,</span>
    <span class="n">lt</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._config</span> <span class="kn">import</span> <span class="n">get_option</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="kn">from</span> <span class="nn">pandas._libs.interval</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">VALID_CLOSED</span><span class="p">,</span>
    <span class="n">Interval</span><span class="p">,</span>
    <span class="n">IntervalMixin</span><span class="p">,</span>
    <span class="n">intervals_to_interval_bounds</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._libs.missing</span> <span class="kn">import</span> <span class="n">NA</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">AxisInt</span><span class="p">,</span>
    <span class="n">Dtype</span><span class="p">,</span>
    <span class="n">IntervalClosedType</span><span class="p">,</span>
    <span class="n">NpDtype</span><span class="p">,</span>
    <span class="n">PositionalIndexer</span><span class="p">,</span>
    <span class="n">ScalarIndexer</span><span class="p">,</span>
    <span class="n">SequenceIndexer</span><span class="p">,</span>
    <span class="n">SortKind</span><span class="p">,</span>
    <span class="n">TimeArrayLike</span><span class="p">,</span>
    <span class="n">npt</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="kn">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="n">IntCastingNaNError</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="n">Appender</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">LossySetitemError</span><span class="p">,</span>
    <span class="n">maybe_upcast_numeric_to_64bit</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">is_categorical_dtype</span><span class="p">,</span>
    <span class="n">is_dtype_equal</span><span class="p">,</span>
    <span class="n">is_float_dtype</span><span class="p">,</span>
    <span class="n">is_integer_dtype</span><span class="p">,</span>
    <span class="n">is_interval_dtype</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">is_string_dtype</span><span class="p">,</span>
    <span class="n">needs_i8_conversion</span><span class="p">,</span>
    <span class="n">pandas_dtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.dtypes</span> <span class="kn">import</span> <span class="n">IntervalDtype</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ABCDataFrame</span><span class="p">,</span>
    <span class="n">ABCDatetimeIndex</span><span class="p">,</span>
    <span class="n">ABCIntervalIndex</span><span class="p">,</span>
    <span class="n">ABCPeriodIndex</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">is_valid_na_for_dtype</span><span class="p">,</span>
    <span class="n">isna</span><span class="p">,</span>
    <span class="n">notna</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core.algorithms</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">isin</span><span class="p">,</span>
    <span class="n">take</span><span class="p">,</span>
    <span class="n">unique</span><span class="p">,</span>
    <span class="n">value_counts</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ExtensionArray</span><span class="p">,</span>
    <span class="n">_extension_array_shared_docs</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.datetimes</span> <span class="kn">import</span> <span class="n">DatetimeArray</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.timedeltas</span> <span class="kn">import</span> <span class="n">TimedeltaArray</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">from</span> <span class="nn">pandas.core.construction</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">array</span> <span class="k">as</span> <span class="n">pd_array</span><span class="p">,</span>
    <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">,</span>
    <span class="n">extract_array</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexers</span> <span class="kn">import</span> <span class="n">check_array_indexer</span>
<span class="kn">from</span> <span class="nn">pandas.core.ops</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">invalid_comparison</span><span class="p">,</span>
    <span class="n">unpack_zerodim_and_defer</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">Index</span><span class="p">,</span>
        <span class="n">Series</span><span class="p">,</span>
    <span class="p">)</span>


<span class="n">IntervalArrayT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;IntervalArrayT&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;IntervalArray&quot;</span><span class="p">)</span>
<span class="n">IntervalSideT</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeArrayLike</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
<span class="n">IntervalOrNA</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Interval</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>

<span class="n">_interval_shared_docs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">_shared_docs_kwargs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;IntervalArray&quot;</span><span class="p">,</span>
    <span class="s2">&quot;qualname&quot;</span><span class="p">:</span> <span class="s2">&quot;arrays.IntervalArray&quot;</span><span class="p">,</span>
    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="p">}</span>


<span class="n">_interval_shared_docs</span><span class="p">[</span>
    <span class="s2">&quot;class&quot;</span>
<span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">%(summary)s</span>

<span class="s2">.. versionadded:: </span><span class="si">%(versionadded)s</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">data : array-like (1-dimensional)</span>
<span class="s2">    Array-like (ndarray, :class:`DateTimeArray`, :class:`TimeDeltaArray`) containing</span>
<span class="s2">    Interval objects from which to build the </span><span class="si">%(klass)s</span><span class="s2">.</span>
<span class="s2">closed : {&#39;left&#39;, &#39;right&#39;, &#39;both&#39;, &#39;neither&#39;}, default &#39;right&#39;</span>
<span class="s2">    Whether the intervals are closed on the left-side, right-side, both or</span>
<span class="s2">    neither.</span>
<span class="s2">dtype : dtype or None, default None</span>
<span class="s2">    If None, dtype will be inferred.</span>
<span class="s2">copy : bool, default False</span>
<span class="s2">    Copy the input data.</span>
<span class="si">%(name)s</span><span class="se">\</span>
<span class="s2">verify_integrity : bool, default True</span>
<span class="s2">    Verify that the </span><span class="si">%(klass)s</span><span class="s2"> is valid.</span>

<span class="s2">Attributes</span>
<span class="s2">----------</span>
<span class="s2">left</span>
<span class="s2">right</span>
<span class="s2">closed</span>
<span class="s2">mid</span>
<span class="s2">length</span>
<span class="s2">is_empty</span>
<span class="s2">is_non_overlapping_monotonic</span>
<span class="si">%(extra_attributes)s</span><span class="se">\</span>

<span class="s2">Methods</span>
<span class="s2">-------</span>
<span class="s2">from_arrays</span>
<span class="s2">from_tuples</span>
<span class="s2">from_breaks</span>
<span class="s2">contains</span>
<span class="s2">overlaps</span>
<span class="s2">set_closed</span>
<span class="s2">to_tuples</span>
<span class="si">%(extra_methods)s</span><span class="se">\</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">Index : The base pandas Index type.</span>
<span class="s2">Interval : A bounded slice-like interval; the elements of an </span><span class="si">%(klass)s</span><span class="s2">.</span>
<span class="s2">interval_range : Function to create a fixed frequency IntervalIndex.</span>
<span class="s2">cut : Bin values into discrete Intervals.</span>
<span class="s2">qcut : Bin values into equal-sized Intervals based on rank or sample quantiles.</span>

<span class="s2">Notes</span>
<span class="s2">-----</span>
<span class="s2">See the `user guide</span>
<span class="s2">&lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html#intervalindex&gt;`__</span>
<span class="s2">for more.</span>

<span class="si">%(examples)s</span><span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="nd">@Appender</span><span class="p">(</span>
    <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span>
    <span class="o">%</span> <span class="p">{</span>
        <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;IntervalArray&quot;</span><span class="p">,</span>
        <span class="s2">&quot;summary&quot;</span><span class="p">:</span> <span class="s2">&quot;Pandas array for interval data that are closed on the same side.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;versionadded&quot;</span><span class="p">:</span> <span class="s2">&quot;0.24.0&quot;</span><span class="p">,</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;extra_attributes&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;extra_methods&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;examples&quot;</span><span class="p">:</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A new ``IntervalArray`` can be constructed directly from an array-like of</span>
<span class="sd">    ``Interval`` objects:</span>

<span class="sd">    &gt;&gt;&gt; pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)])</span>
<span class="sd">    &lt;IntervalArray&gt;</span>
<span class="sd">    [(0, 1], (1, 5]]</span>
<span class="sd">    Length: 2, dtype: interval[int64, right]</span>

<span class="sd">    It may also be constructed using one of the constructor</span>
<span class="sd">    methods: :meth:`IntervalArray.from_arrays`,</span>
<span class="sd">    :meth:`IntervalArray.from_breaks`, and :meth:`IntervalArray.from_tuples`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="p">),</span>
    <span class="p">}</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">IntervalArray</span><span class="p">(</span><span class="n">IntervalMixin</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
    <span class="n">can_hold_na</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_na_value</span> <span class="o">=</span> <span class="n">_fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="c1"># To make mypy recognize the fields</span>
    <span class="n">_left</span><span class="p">:</span> <span class="n">IntervalSideT</span>
    <span class="n">_right</span><span class="p">:</span> <span class="n">IntervalSideT</span>
    <span class="n">_dtype</span><span class="p">:</span> <span class="n">IntervalDtype</span>

    <span class="c1"># ---------------------------------------------------------------------</span>
    <span class="c1"># Constructors</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">IntervalArrayT</span><span class="p">],</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verify_integrity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="n">left</span><span class="p">:</span> <span class="n">IntervalSideT</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_left</span>
            <span class="n">right</span><span class="p">:</span> <span class="n">IntervalSideT</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_right</span>
            <span class="n">closed</span> <span class="o">=</span> <span class="n">closed</span> <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">closed</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">IntervalDtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># don&#39;t allow scalars</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(...) must be called with a collection &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;of some kind, </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2"> was passed&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># might need to convert empty or purely na data</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_maybe_convert_platform_interval</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">infer_closed</span> <span class="o">=</span> <span class="n">intervals_to_interval_bounds</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">validate_closed</span><span class="o">=</span><span class="n">closed</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="n">closed</span> <span class="o">=</span> <span class="n">closed</span> <span class="ow">or</span> <span class="n">infer_closed</span>

            <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_ensure_simple_new_inputs</span><span class="p">(</span>
                <span class="n">left</span><span class="p">,</span>
                <span class="n">right</span><span class="p">,</span>
                <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">verify_integrity</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span>
            <span class="n">left</span><span class="p">,</span>
            <span class="n">right</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_simple_new</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">IntervalArrayT</span><span class="p">],</span>
        <span class="n">left</span><span class="p">:</span> <span class="n">IntervalSideT</span><span class="p">,</span>
        <span class="n">right</span><span class="p">:</span> <span class="n">IntervalSideT</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">IntervalDtype</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">IntervalMixin</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_ensure_simple_new_inputs</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">left</span><span class="p">,</span>
        <span class="n">right</span><span class="p">,</span>
        <span class="n">closed</span><span class="p">:</span> <span class="n">IntervalClosedType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">IntervalSideT</span><span class="p">,</span> <span class="n">IntervalSideT</span><span class="p">,</span> <span class="n">IntervalDtype</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensure correctness of input parameters for cls._simple_new.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.indexes.base</span> <span class="kn">import</span> <span class="n">ensure_index</span>

        <span class="n">left</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">maybe_upcast_numeric_to_64bit</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

        <span class="n">right</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">maybe_upcast_numeric_to_64bit</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">closed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">IntervalDtype</span><span class="p">):</span>
            <span class="n">closed</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">closed</span>

        <span class="n">closed</span> <span class="o">=</span> <span class="n">closed</span> <span class="ow">or</span> <span class="s2">&quot;right&quot;</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># GH 19262: dtype must be an IntervalDtype to override inferred</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">IntervalDtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;dtype must be an IntervalDtype, got </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">closed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># possibly loading an old pickle</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">IntervalDtype</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">,</span> <span class="n">closed</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">closed</span> <span class="o">!=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;closed keyword does not match dtype.closed&quot;</span><span class="p">)</span>

        <span class="c1"># coerce dtypes to match if needed</span>
        <span class="k">if</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;must not have differing left [</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">] and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;right [</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">] types&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_string_dtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># GH 19016</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;category, object, and string subtypes are not supported &quot;</span>
                <span class="s2">&quot;for IntervalArray&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">ABCPeriodIndex</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Period dtypes are not supported, use a PeriodIndex instead&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">ABCDatetimeIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">tz</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;left and right must have the same time zone, got &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">left</span><span class="o">.</span><span class="n">tz</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">right</span><span class="o">.</span><span class="n">tz</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># For dt64/td64 we want DatetimeArray/TimedeltaArray instead of ndarray</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">lbase</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="s2">&quot;_ndarray&quot;</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span><span class="o">.</span><span class="n">base</span>
        <span class="n">rbase</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="s2">&quot;_ndarray&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span><span class="o">.</span><span class="n">base</span>
        <span class="k">if</span> <span class="n">lbase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lbase</span> <span class="ow">is</span> <span class="n">rbase</span><span class="p">:</span>
            <span class="c1"># If these share data, then setitem could corrupt our IA</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">IntervalDtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_sequence</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">IntervalArrayT</span><span class="p">],</span>
        <span class="n">scalars</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_factorized</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">IntervalArrayT</span><span class="p">],</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">original</span><span class="p">:</span> <span class="n">IntervalArrayT</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># An empty array returns object-dtype here. We can&#39;t create</span>
            <span class="c1"># a new IA from an (empty) object-dtype array, so turn it into the</span>
            <span class="c1"># correct dtype.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="n">original</span><span class="o">.</span><span class="n">closed</span><span class="p">)</span>

    <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;from_breaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct an %(klass)s from an array of splits.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        breaks : array-like (1-dimensional)</span>
<span class="sd">            Left and right bounds for each interval.</span>
<span class="sd">        closed : {&#39;left&#39;, &#39;right&#39;, &#39;both&#39;, &#39;neither&#39;}, default &#39;right&#39;</span>
<span class="sd">            Whether the intervals are closed on the left-side, right-side, both</span>
<span class="sd">            or neither.\</span>
<span class="sd">        %(name)s</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            Copy the data.</span>
<span class="sd">        dtype : dtype or None, default None</span>
<span class="sd">            If None, dtype will be inferred.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        interval_range : Function to create a fixed frequency IntervalIndex.</span>
<span class="sd">        %(klass)s.from_arrays : Construct from a left and right array.</span>
<span class="sd">        %(klass)s.from_tuples : Construct from a sequence of tuples.</span>

<span class="sd">        %(examples)s\</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;from_breaks&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;IntervalArray&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;examples&quot;</span><span class="p">:</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pd.arrays.IntervalArray.from_breaks([0, 1, 2, 3])</span>
<span class="sd">        &lt;IntervalArray&gt;</span>
<span class="sd">        [(0, 1], (1, 2], (2, 3]]</span>
<span class="sd">        Length: 3, dtype: interval[int64, right]</span>
<span class="sd">        &quot;&quot;&quot;</span>
            <span class="p">),</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_breaks</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">IntervalArrayT</span><span class="p">],</span>
        <span class="n">breaks</span><span class="p">,</span>
        <span class="n">closed</span><span class="p">:</span> <span class="n">IntervalClosedType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
        <span class="n">breaks</span> <span class="o">=</span> <span class="n">_maybe_convert_platform_interval</span><span class="p">(</span><span class="n">breaks</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">breaks</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">breaks</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">closed</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;from_arrays&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct from two arrays defining the left and right bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : array-like (1-dimensional)</span>
<span class="sd">            Left bounds for each interval.</span>
<span class="sd">        right : array-like (1-dimensional)</span>
<span class="sd">            Right bounds for each interval.</span>
<span class="sd">        closed : {&#39;left&#39;, &#39;right&#39;, &#39;both&#39;, &#39;neither&#39;}, default &#39;right&#39;</span>
<span class="sd">            Whether the intervals are closed on the left-side, right-side, both</span>
<span class="sd">            or neither.\</span>
<span class="sd">        %(name)s</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            Copy the data.</span>
<span class="sd">        dtype : dtype, optional</span>
<span class="sd">            If None, dtype will be inferred.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When a value is missing in only one of `left` or `right`.</span>
<span class="sd">            When a value in `left` is greater than the corresponding value</span>
<span class="sd">            in `right`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        interval_range : Function to create a fixed frequency IntervalIndex.</span>
<span class="sd">        %(klass)s.from_breaks : Construct an %(klass)s from an array of</span>
<span class="sd">            splits.</span>
<span class="sd">        %(klass)s.from_tuples : Construct an %(klass)s from an</span>
<span class="sd">            array-like of tuples.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Each element of `left` must be less than or equal to the `right`</span>
<span class="sd">        element at the same position. If an element is missing, it must be</span>
<span class="sd">        missing in both `left` and `right`. A TypeError is raised when</span>
<span class="sd">        using an unsupported type for `left` or `right`. At the moment,</span>
<span class="sd">        &#39;category&#39;, &#39;object&#39;, and &#39;string&#39; subtypes are not supported.</span>

<span class="sd">        %(examples)s\</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;from_arrays&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;IntervalArray&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;examples&quot;</span><span class="p">:</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        &gt;&gt;&gt; pd.arrays.IntervalArray.from_arrays([0, 1, 2], [1, 2, 3])</span>
<span class="sd">        &lt;IntervalArray&gt;</span>
<span class="sd">        [(0, 1], (1, 2], (2, 3]]</span>
<span class="sd">        Length: 3, dtype: interval[int64, right]</span>
<span class="sd">        &quot;&quot;&quot;</span>
            <span class="p">),</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_arrays</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">IntervalArrayT</span><span class="p">],</span>
        <span class="n">left</span><span class="p">,</span>
        <span class="n">right</span><span class="p">,</span>
        <span class="n">closed</span><span class="p">:</span> <span class="n">IntervalClosedType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">_maybe_convert_platform_interval</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">_maybe_convert_platform_interval</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_ensure_simple_new_inputs</span><span class="p">(</span>
            <span class="n">left</span><span class="p">,</span>
            <span class="n">right</span><span class="p">,</span>
            <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;from_tuples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct an %(klass)s from an array-like of tuples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : array-like (1-dimensional)</span>
<span class="sd">            Array of tuples.</span>
<span class="sd">        closed : {&#39;left&#39;, &#39;right&#39;, &#39;both&#39;, &#39;neither&#39;}, default &#39;right&#39;</span>
<span class="sd">            Whether the intervals are closed on the left-side, right-side, both</span>
<span class="sd">            or neither.\</span>
<span class="sd">        %(name)s</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            By-default copy the data, this is compat only and ignored.</span>
<span class="sd">        dtype : dtype or None, default None</span>
<span class="sd">            If None, dtype will be inferred.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        interval_range : Function to create a fixed frequency IntervalIndex.</span>
<span class="sd">        %(klass)s.from_arrays : Construct an %(klass)s from a left and</span>
<span class="sd">                                    right array.</span>
<span class="sd">        %(klass)s.from_breaks : Construct an %(klass)s from an array of</span>
<span class="sd">                                    splits.</span>

<span class="sd">        %(examples)s\</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;from_tuples&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;IntervalArray&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;examples&quot;</span><span class="p">:</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pd.arrays.IntervalArray.from_tuples([(0, 1), (1, 2)])</span>
<span class="sd">        &lt;IntervalArray&gt;</span>
<span class="sd">        [(0, 1], (1, 2]]</span>
<span class="sd">        Length: 2, dtype: interval[int64, right]</span>
<span class="sd">        &quot;&quot;&quot;</span>
            <span class="p">),</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_tuples</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">IntervalArrayT</span><span class="p">],</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">closed</span><span class="p">:</span> <span class="n">IntervalClosedType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ensure that empty data keeps input dtype</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="n">data</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isna</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># need list of length 2 tuples, e.g. [(0, 1), (1, 2), ...]</span>
                    <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.from_tuples requires tuples of length 2, got </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.from_tuples received an invalid item, </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
            <span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>
            <span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">closed</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">IntervalDtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that the IntervalArray is valid.</span>

<span class="sd">        Checks that</span>

<span class="sd">        * dtype is correct</span>
<span class="sd">        * left and right match lengths</span>
<span class="sd">        * left and right have the same missing values</span>
<span class="sd">        * left is always below right</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">IntervalDtype</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;invalid dtype: </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;left and right must have the same length&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">left_mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">left_mask</span> <span class="o">==</span> <span class="n">right_mask</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;missing values must be missing in the same &quot;</span>
                <span class="s2">&quot;location both left and right sides&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">left_mask</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">left_mask</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;left side of interval must be &lt;= right side&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_shallow_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">IntervalArrayT</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new IntervalArray with the replacement attributes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : Index</span>
<span class="sd">            Values to be used for the left-side of the intervals.</span>
<span class="sd">        right : Index</span>
<span class="sd">            Values to be used for the right-side of the intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">IntervalDtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">)</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_simple_new_inputs</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># ---------------------------------------------------------------------</span>
    <span class="c1"># Descriptive</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalDtype</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">nbytes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># Avoid materializing self.values</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># ---------------------------------------------------------------------</span>
    <span class="c1"># EA Interface</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">ScalarIndexer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalOrNA</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">IntervalArrayT</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">SequenceIndexer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">IntervalArrayT</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">PositionalIndexer</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span> <span class="o">|</span> <span class="n">IntervalOrNA</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">check_array_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">)):</span>
            <span class="c1"># scalar</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isna</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span>
            <span class="k">return</span> <span class="n">Interval</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># GH#30588 multi-dimensional indexer disallowed</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;multi-dimensional indexing not allowed&quot;</span><span class="p">)</span>
        <span class="c1"># Argument 2 to &quot;_simple_new&quot; of &quot;IntervalArray&quot; has incompatible type</span>
        <span class="c1"># &quot;Union[Period, Timestamp, Timedelta, NaTType, DatetimeArray, TimedeltaArray,</span>
        <span class="c1"># ndarray[Any, Any]]&quot;; expected &quot;Union[Union[DatetimeArray, TimedeltaArray],</span>
        <span class="c1"># ndarray[Any, Any]]&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">value_left</span><span class="p">,</span> <span class="n">value_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_setitem_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">check_array_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_right</span>

    <span class="k">def</span> <span class="nf">_cmp_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="c1"># ensure pandas array for list-like and eliminate non-interval scalars</span>
        <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lengths must match to compare&quot;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">pd_array</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
            <span class="c1"># non-interval scalar -&gt; no matches</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="n">NA</span><span class="p">:</span>
                <span class="c1"># GH#31882</span>
                <span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="n">BooleanArray</span>

                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">BooleanArray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">invalid_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="c1"># determine the dtype of the elements we want to compare</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
            <span class="n">other_dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="s2">&quot;interval&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">other_dtype</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for categorical defer to categories for dtype</span>
            <span class="n">other_dtype</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">dtype</span>

            <span class="c1"># extract intervals if we have interval categories with matching closed</span>
            <span class="k">if</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="n">other_dtype</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">invalid_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

                <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span> <span class="n">allow_fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">_na_value</span>
                <span class="p">)</span>

        <span class="c1"># interval-like -&gt; need same closed and matching endpoints</span>
        <span class="k">if</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="n">other_dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">invalid_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
                <span class="n">other</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&gt;</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># operator.lt</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">)</span>

        <span class="c1"># non-interval/non-object dtype -&gt; no matches</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">other_dtype</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">invalid_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="c1"># object dtype -&gt; iteratively check for intervals</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">NA</span><span class="p">:</span>
                    <span class="c1"># comparison with np.nan returns NA</span>
                    <span class="c1"># github.com/pandas-dev/pandas/pull/37124#discussion_r509095092</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NA</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@unpack_zerodim_and_defer</span><span class="p">(</span><span class="s2">&quot;__eq__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">)</span>

    <span class="nd">@unpack_zerodim_and_defer</span><span class="p">(</span><span class="s2">&quot;__ne__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">)</span>

    <span class="nd">@unpack_zerodim_and_defer</span><span class="p">(</span><span class="s2">&quot;__gt__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">)</span>

    <span class="nd">@unpack_zerodim_and_defer</span><span class="p">(</span><span class="s2">&quot;__ge__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">)</span>

    <span class="nd">@unpack_zerodim_and_defer</span><span class="p">(</span><span class="s2">&quot;__lt__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">)</span>

    <span class="nd">@unpack_zerodim_and_defer</span><span class="p">(</span><span class="s2">&quot;__le__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SortKind</span> <span class="o">=</span> <span class="s2">&quot;quicksort&quot;</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">ascending</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_argsort_with_ascending</span><span class="p">(</span><span class="n">ascending</span><span class="p">,</span> <span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ascending</span> <span class="ow">and</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;quicksort&quot;</span> <span class="ow">and</span> <span class="n">na_position</span> <span class="o">==</span> <span class="s2">&quot;last&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: in an IntervalIndex we can re-use the cached</span>
            <span class="c1">#  IntervalTree.left_sorter</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>

        <span class="c1"># TODO: other cases we can use lexsort for?  much more performant.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
            <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalOrNA</span><span class="p">:</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_minmax_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">skipna</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">indexer</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalOrNA</span><span class="p">:</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_minmax_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">skipna</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">indexer</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">IntervalArrayT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NA/NaN values using the specified method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, dict, Series</span>
<span class="sd">            If a scalar value is passed it is used to fill all missing values.</span>
<span class="sd">            Alternatively, a Series or dict can be used to fill in different</span>
<span class="sd">            values for each index. The value should not be a list. The</span>
<span class="sd">            value(s) passed should be either Interval objects or NA/NaN.</span>
<span class="sd">        method : {&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}, default None</span>
<span class="sd">            (Not implemented yet for IntervalArray)</span>
<span class="sd">            Method to use for filling holes in reindexed Series</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            (Not implemented yet for IntervalArray)</span>
<span class="sd">            If method is specified, this is the maximum number of consecutive</span>
<span class="sd">            NaN values to forward/backward fill. In other words, if there is</span>
<span class="sd">            a gap with more than this number of consecutive NaNs, it will only</span>
<span class="sd">            be partially filled. If method is not specified, this is the</span>
<span class="sd">            maximum number of entries along the entire axis where NaNs will be</span>
<span class="sd">            filled.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled : IntervalArray with NA/NaN filled</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Filling by method is not supported for IntervalArray.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;limit is not supported for IntervalArray.&quot;</span><span class="p">)</span>

        <span class="n">value_left</span><span class="p">,</span> <span class="n">value_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_scalar</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value_left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value_right</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast to an ExtensionArray or NumPy array with dtype &#39;dtype&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str or dtype</span>
<span class="sd">            Typecode or data-type to which the array is cast.</span>

<span class="sd">        copy : bool, default True</span>
<span class="sd">            Whether to copy the data, even if not necessary. If False,</span>
<span class="sd">            a copy is made only if the old dtype does not match the</span>
<span class="sd">            new dtype.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array : ExtensionArray or ndarray</span>
<span class="sd">            ExtensionArray or NumPy ndarray with &#39;dtype&#39; for its dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Index</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>

            <span class="k">if</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">needs_i8_conversion</span><span class="p">(</span>
                <span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span>
            <span class="p">):</span>
                <span class="c1"># This is allowed on the Index.astype but we disallow it here</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot convert </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">; subtypes are incompatible&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># need to cast to different subtype</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># We need to use Index rules for astype to prevent casting</span>
                <span class="c1">#  np.nan entries to int subtypes</span>
                <span class="n">new_left</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span>
                <span class="n">new_right</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">IntCastingNaNError</span><span class="p">:</span>
                <span class="c1"># e.g test_subtype_integer</span>
                <span class="k">raise</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="c1"># e.g. test_subtype_integer_errors f8-&gt;u8 can be lossy</span>
                <span class="c1">#  and raises ValueError</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot convert </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">; subtypes are incompatible&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">new_left</span><span class="p">,</span> <span class="n">new_right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cannot cast </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> to dtype </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">closed</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_concat_same_type</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">IntervalArrayT</span><span class="p">],</span> <span class="n">to_concat</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">IntervalArrayT</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate multiple IntervalArray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_concat : sequence of IntervalArray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        IntervalArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">closed_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">interval</span><span class="o">.</span><span class="n">closed</span> <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closed_set</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Intervals must all be closed on the same side.&quot;</span><span class="p">)</span>
        <span class="n">closed</span> <span class="o">=</span> <span class="n">closed_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">interval</span><span class="o">.</span><span class="n">left</span> <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">])</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span> <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">])</span>

        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_ensure_simple_new_inputs</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">IntervalArrayT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        IntervalArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_scalar</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="c1"># ExtensionArray.shift doesn&#39;t work for two reasons</span>
        <span class="c1"># 1. IntervalArray.dtype.na_value may not be correct for the dtype.</span>
        <span class="c1"># 2. IntervalArray._from_sequence only accepts NaN for missing values,</span>
        <span class="c1">#    not other values like NaT</span>

        <span class="n">empty_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">periods</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">isna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Index</span>

            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_na_value</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="n">IntervalArray</span><span class="o">.</span><span class="n">from_breaks</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">empty_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="n">empty_len</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">empty</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:</span><span class="o">-</span><span class="n">periods</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span> <span class="p">:]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">empty</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concat_same_type</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">IntervalArrayT</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">allow_fill</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take elements from the IntervalArray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : sequence of integers</span>
<span class="sd">            Indices to be taken.</span>

<span class="sd">        allow_fill : bool, default False</span>
<span class="sd">            How to handle negative values in `indices`.</span>

<span class="sd">            * False: negative values in `indices` indicate positional indices</span>
<span class="sd">              from the right (the default). This is similar to</span>
<span class="sd">              :func:`numpy.take`.</span>

<span class="sd">            * True: negative values in `indices` indicate</span>
<span class="sd">              missing values. These values are set to `fill_value`. Any other</span>
<span class="sd">              other negative values raise a ``ValueError``.</span>

<span class="sd">        fill_value : Interval or NA, optional</span>
<span class="sd">            Fill value to use for NA-indices when `allow_fill` is True.</span>
<span class="sd">            This may be ``None``, in which case the default NA value for</span>
<span class="sd">            the type, ``self.dtype.na_value``, is used.</span>

<span class="sd">            For many ExtensionArrays, there will be two representations of</span>
<span class="sd">            `fill_value`: a user-facing &quot;boxed&quot; scalar, and a low-level</span>
<span class="sd">            physical NA value. `fill_value` should be the user-facing version,</span>
<span class="sd">            and the implementation should handle translating that to the</span>
<span class="sd">            physical version for processing the take if necessary.</span>

<span class="sd">        axis : any, default None</span>
<span class="sd">            Present for compat with IntervalIndex; does nothing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        IntervalArray</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            When the indices are out of bounds for the array.</span>
<span class="sd">        ValueError</span>
<span class="sd">            When `indices` contains negative values other than ``-1``</span>
<span class="sd">            and `allow_fill` is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_take</span><span class="p">((),</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="n">fill_left</span> <span class="o">=</span> <span class="n">fill_right</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">if</span> <span class="n">allow_fill</span><span class="p">:</span>
            <span class="n">fill_left</span><span class="p">,</span> <span class="n">fill_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_scalar</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="n">left_take</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">allow_fill</span><span class="o">=</span><span class="n">allow_fill</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_left</span>
        <span class="p">)</span>
        <span class="n">right_take</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">allow_fill</span><span class="o">=</span><span class="n">allow_fill</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_right</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">left_take</span><span class="p">,</span> <span class="n">right_take</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_listlike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># list-like of intervals</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">IntervalArray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_closed_matches</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
            <span class="n">value_left</span><span class="p">,</span> <span class="n">value_right</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">right</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="c1"># wrong type: not interval or NA</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&#39;value&#39; should be an interval type, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead.&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_validate_fill_value</span><span class="p">(</span><span class="n">value_left</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">LossySetitemError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;&#39;value&#39; should be a compatible interval type, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="k">return</span> <span class="n">value_left</span><span class="p">,</span> <span class="n">value_right</span>

    <span class="k">def</span> <span class="nf">_validate_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_closed_matches</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">right</span>
            <span class="c1"># TODO: check subdtype match like _validate_setitem_value?</span>
        <span class="k">elif</span> <span class="n">is_valid_na_for_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># GH#18295</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_na_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;can only insert Interval objects and NA into an IntervalArray&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">_validate_setitem_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_valid_na_for_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># na value: need special casing to set directly on numpy arrays</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_na_value</span>
            <span class="k">if</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">):</span>
                <span class="c1"># can&#39;t set NaN on a numpy integer array</span>
                <span class="c1"># GH#45484 TypeError, not ValueError, matches what we get with</span>
                <span class="c1">#  non-NA un-holdable value.</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot set float NaN to integer-backed IntervalArray&quot;</span><span class="p">)</span>
            <span class="n">value_left</span><span class="p">,</span> <span class="n">value_right</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="n">value</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
            <span class="c1"># scalar interval</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_closed_matches</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
            <span class="n">value_left</span><span class="p">,</span> <span class="n">value_right</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">right</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_validate_fill_value</span><span class="p">(</span><span class="n">value_left</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_validate_fill_value</span><span class="p">(</span><span class="n">value_right</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_listlike</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value_left</span><span class="p">,</span> <span class="n">value_right</span>

    <span class="k">def</span> <span class="nf">value_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Series containing counts of each interval.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dropna : bool, default True</span>
<span class="sd">            Don&#39;t include counts of NaN.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.value_counts</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: implement this is a non-naive way!</span>
        <span class="k">return</span> <span class="n">value_counts</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>

    <span class="c1"># ---------------------------------------------------------------------</span>
    <span class="c1"># Rendering Methods</span>

    <span class="k">def</span> <span class="nf">_format_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># TODO: integrate with categorical and make generic</span>
        <span class="c1"># name argument is unused here; just for compat with base / categorical</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">max_seq_items</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_seq_items&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="nb">str</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="s2">&quot;[]&quot;</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">first</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">first</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">last</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">max_seq_items</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_seq_items</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
                <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="n">formatter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[:</span><span class="n">n</span><span class="p">]]</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="p">[</span><span class="n">formatter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]]</span>
                <span class="n">head_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
                <span class="n">tail_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
                <span class="n">summary</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">head_str</span><span class="si">}</span><span class="s2"> ... </span><span class="si">{</span><span class="n">tail_str</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="p">[</span><span class="n">formatter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
                <span class="n">tail_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
                <span class="n">summary</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">tail_str</span><span class="si">}</span><span class="s2">]&quot;</span>

        <span class="k">return</span> <span class="n">summary</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># the short repr has no trailing newline, while the truncated</span>
        <span class="c1"># repr does. So we include a newline in our template, and strip</span>
        <span class="c1"># any trailing newlines from format_object_summary</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_data</span><span class="p">()</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="n">template</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">class_name</span><span class="si">}{</span><span class="n">data</span><span class="si">}</span><span class="se">\n</span><span class="s2">Length: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">, dtype: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">template</span>

    <span class="k">def</span> <span class="nf">_format_space</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">space</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">space</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># ---------------------------------------------------------------------</span>
    <span class="c1"># Vectorized Interval Properties/Attributes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the left endpoints of each Interval in the IntervalArray as an Index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Index</span>

        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the right endpoints of each Interval in the IntervalArray as an Index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Index</span>

        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an Index with entries denoting the length of each Interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the midpoint of each Interval in the IntervalArray as an Index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># datetime safe version</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;overlaps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check elementwise if an Interval overlaps the values in the %(klass)s.</span>

<span class="sd">        Two intervals overlap if they share a common point, including closed</span>
<span class="sd">        endpoints. Intervals that only have an open endpoint in common do not</span>
<span class="sd">        overlap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : %(klass)s</span>
<span class="sd">            Interval to check against for an overlap.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Boolean array positionally indicating where an overlap occurs.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Interval.overlaps : Check whether two Interval objects overlap.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        %(examples)s</span>
<span class="sd">        &gt;&gt;&gt; intervals.overlaps(pd.Interval(0.5, 1.5))</span>
<span class="sd">        array([ True,  True, False])</span>

<span class="sd">        Intervals that share closed endpoints overlap:</span>

<span class="sd">        &gt;&gt;&gt; intervals.overlaps(pd.Interval(1, 3, closed=&#39;left&#39;))</span>
<span class="sd">        array([ True,  True, True])</span>

<span class="sd">        Intervals that only have an open endpoint in common do not overlap:</span>

<span class="sd">        &gt;&gt;&gt; intervals.overlaps(pd.Interval(1, 2, closed=&#39;right&#39;))</span>
<span class="sd">        array([False,  True, False])</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;overlaps&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;IntervalArray&quot;</span><span class="p">,</span>
            <span class="s2">&quot;examples&quot;</span><span class="p">:</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        &gt;&gt;&gt; data = [(0, 1), (1, 3), (2, 4)]</span>
<span class="sd">        &gt;&gt;&gt; intervals = pd.arrays.IntervalArray.from_tuples(data)</span>
<span class="sd">        &gt;&gt;&gt; intervals</span>
<span class="sd">        &lt;IntervalArray&gt;</span>
<span class="sd">        [(0, 1], (1, 3], (2, 4]]</span>
<span class="sd">        Length: 3, dtype: interval[int64, right]</span>
<span class="sd">        &quot;&quot;&quot;</span>
            <span class="p">),</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">IntervalArray</span><span class="p">,</span> <span class="n">ABCIntervalIndex</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;`other` must be Interval-like, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># equality is okay if both endpoints are closed (overlap at a point)</span>
        <span class="n">op1</span> <span class="o">=</span> <span class="n">le</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closed_left</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">closed_right</span><span class="p">)</span> <span class="k">else</span> <span class="n">lt</span>
        <span class="n">op2</span> <span class="o">=</span> <span class="n">le</span> <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">closed_left</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed_right</span><span class="p">)</span> <span class="k">else</span> <span class="n">lt</span>

        <span class="c1"># overlaps is equivalent negation of two interval being disjoint:</span>
        <span class="c1"># disjoint = (A.left &gt; B.right) or (B.left &gt; A.right)</span>
        <span class="c1"># (simplifying the negation allows this to be done in less operations)</span>
        <span class="k">return</span> <span class="n">op1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">op2</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="c1"># ---------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalClosedType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String describing the inclusive side the intervals.</span>

<span class="sd">        Either ``left``, ``right``, ``both`` or ``neither``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">closed</span>

    <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;set_closed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an identical %(klass)s closed on the specified side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        closed : {&#39;left&#39;, &#39;right&#39;, &#39;both&#39;, &#39;neither&#39;}</span>
<span class="sd">            Whether the intervals are closed on the left-side, right-side, both</span>
<span class="sd">            or neither.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s</span>

<span class="sd">        %(examples)s\</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;set_closed&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;IntervalArray&quot;</span><span class="p">,</span>
            <span class="s2">&quot;examples&quot;</span><span class="p">:</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = pd.arrays.IntervalArray.from_breaks(range(4))</span>
<span class="sd">        &gt;&gt;&gt; index</span>
<span class="sd">        &lt;IntervalArray&gt;</span>
<span class="sd">        [(0, 1], (1, 2], (2, 3]]</span>
<span class="sd">        Length: 3, dtype: interval[int64, right]</span>
<span class="sd">        &gt;&gt;&gt; index.set_closed(&#39;both&#39;)</span>
<span class="sd">        &lt;IntervalArray&gt;</span>
<span class="sd">        [[0, 1], [1, 2], [2, 3]]</span>
<span class="sd">        Length: 3, dtype: interval[int64, both]</span>
<span class="sd">        &quot;&quot;&quot;</span>
            <span class="p">),</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_closed</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">IntervalArrayT</span><span class="p">,</span> <span class="n">closed</span><span class="p">:</span> <span class="n">IntervalClosedType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">closed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VALID_CLOSED</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;invalid option for &#39;closed&#39;: </span><span class="si">{</span><span class="n">closed</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">IntervalDtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">_interval_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;is_non_overlapping_monotonic&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return a boolean whether the </span><span class="si">%(klass)s</span><span class="s2"> is non-overlapping and monotonic.</span>

<span class="s2">        Non-overlapping means (no Intervals share points), and monotonic means</span>
<span class="s2">        either monotonic increasing or monotonic decreasing.</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;is_non_overlapping_monotonic&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_docs_kwargs</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_non_overlapping_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># must be increasing  (e.g., [0, 1), [1, 2), [2, 3), ... )</span>
        <span class="c1"># or decreasing (e.g., [-1, 0), [-2, -1), [-3, -2), ...)</span>
        <span class="c1"># we already require left &lt;= right</span>

        <span class="c1"># strict inequality for closed == &#39;both&#39;; equality implies overlapping</span>
        <span class="c1"># at a point when both sides of intervals are included</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="c1"># non-strict inequality when closed != &#39;both&#39;; at least one side is</span>
        <span class="c1"># not included in the intervals, so equality does not imply overlapping</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="c1"># ---------------------------------------------------------------------</span>
    <span class="c1"># Conversion</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">NpDtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the IntervalArray&#39;s data as a numpy array of Interval</span>
<span class="sd">        objects (with dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        <span class="n">closed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">left_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Interval</span><span class="p">(</span><span class="n">left_value</span><span class="p">,</span> <span class="n">right</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">closed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__arrow_array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert myself into a pyarrow Array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pyarrow</span>

        <span class="kn">from</span> <span class="nn">pandas.core.arrays.arrow.extension_types</span> <span class="kn">import</span> <span class="n">ArrowIntervalType</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">subtype</span> <span class="o">=</span> <span class="n">pyarrow</span><span class="o">.</span><span class="n">from_numpy_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Conversion to arrow with subtype &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;is not supported&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="n">interval_type</span> <span class="o">=</span> <span class="n">ArrowIntervalType</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">)</span>
        <span class="n">storage_array</span> <span class="o">=</span> <span class="n">pyarrow</span><span class="o">.</span><span class="n">StructArray</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">pyarrow</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">subtype</span><span class="p">,</span> <span class="n">from_pandas</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">pyarrow</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">subtype</span><span class="p">,</span> <span class="n">from_pandas</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="p">],</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># if there are missing values, set validity bitmap also on the array level</span>
            <span class="n">null_bitmap</span> <span class="o">=</span> <span class="n">pyarrow</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">buffers</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">storage_array</span> <span class="o">=</span> <span class="n">pyarrow</span><span class="o">.</span><span class="n">StructArray</span><span class="o">.</span><span class="n">from_buffers</span><span class="p">(</span>
                <span class="n">storage_array</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">storage_array</span><span class="p">),</span>
                <span class="p">[</span><span class="n">null_bitmap</span><span class="p">],</span>
                <span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">storage_array</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">storage_array</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">interval_type</span><span class="o">.</span><span class="n">storage_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">storage_array</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">ArrowIntervalType</span><span class="p">):</span>
                <span class="c1"># ensure we have the same subtype and closed attributes</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">interval_type</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Not supported to convert IntervalArray to type with &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;different &#39;subtype&#39; (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="nb">type</span><span class="o">.</span><span class="n">subtype</span><span class="si">}</span><span class="s2">) &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;and &#39;closed&#39; (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="nb">type</span><span class="o">.</span><span class="n">closed</span><span class="si">}</span><span class="s2">) attributes&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Not supported to convert IntervalArray to &#39;</span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">&#39; type&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">pyarrow</span><span class="o">.</span><span class="n">ExtensionArray</span><span class="o">.</span><span class="n">from_storage</span><span class="p">(</span><span class="n">interval_type</span><span class="p">,</span> <span class="n">storage_array</span><span class="p">)</span>

    <span class="n">_interval_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;to_tuples&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return an </span><span class="si">%(return_type)s</span><span class="s2"> of tuples of the form (left, right).</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        na_tuple : bool, default True</span>
<span class="s2">            Returns NA as a tuple if True, ``(nan, nan)``, or just as the NA</span>
<span class="s2">            value itself if False, ``nan``.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        tuples: </span><span class="si">%(return_type)s</span>
<span class="s2">        </span><span class="si">%(examples)s</span><span class="se">\</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;to_tuples&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;return_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ndarray&quot;</span><span class="p">,</span> <span class="s2">&quot;examples&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na_tuple</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">tuples</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">asarray_tuplesafe</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">na_tuple</span><span class="p">:</span>
            <span class="c1"># GH 18756</span>
            <span class="n">tuples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span> <span class="n">tuples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tuples</span>

    <span class="c1"># ---------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_putmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">value_left</span><span class="p">,</span> <span class="n">value_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_setitem_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">value_left</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">value_right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="o">.</span><span class="n">_putmask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">value_left</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="o">.</span><span class="n">_putmask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">value_right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">IntervalArrayT</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Interval</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new IntervalArray inserting new item at location. Follows</span>
<span class="sd">        Python numpy.insert semantics for negative values.  Only Interval</span>
<span class="sd">        objects and NA can be inserted into an IntervalIndex</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : int</span>
<span class="sd">        item : Interval</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        IntervalArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_insert</span><span class="p">,</span> <span class="n">right_insert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_scalar</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="n">new_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">left_insert</span><span class="p">)</span>
        <span class="n">new_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">right_insert</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">new_left</span><span class="p">,</span> <span class="n">new_right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">IntervalArrayT</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">new_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">new_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">new_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">new_left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">new_right</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_extension_array_shared_docs</span><span class="p">[</span><span class="s2">&quot;repeat&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_docs_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">IntervalArrayT</span><span class="p">,</span>
        <span class="n">repeats</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArrayT</span><span class="p">:</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_repeat</span><span class="p">((),</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="n">axis</span><span class="p">})</span>
        <span class="n">left_repeat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
        <span class="n">right_repeat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">left_repeat</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right_repeat</span><span class="p">)</span>

    <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;contains&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check elementwise if the Intervals contain the value.</span>

<span class="sd">        Return a boolean mask whether the value is contained in the Intervals</span>
<span class="sd">        of the %(klass)s.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : scalar</span>
<span class="sd">            The value to check whether it is contained in the Intervals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        boolean array</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Interval.contains : Check whether Interval object contains value.</span>
<span class="sd">        %(klass)s.overlaps : Check if an Interval overlaps the values in the</span>
<span class="sd">            %(klass)s.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        %(examples)s</span>
<span class="sd">        &gt;&gt;&gt; intervals.contains(0.5)</span>
<span class="sd">        array([ True, False, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_interval_shared_docs</span><span class="p">[</span><span class="s2">&quot;contains&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;IntervalArray&quot;</span><span class="p">,</span>
            <span class="s2">&quot;examples&quot;</span><span class="p">:</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        &gt;&gt;&gt; intervals = pd.arrays.IntervalArray.from_tuples([(0, 1), (1, 3), (2, 4)])</span>
<span class="sd">        &gt;&gt;&gt; intervals</span>
<span class="sd">        &lt;IntervalArray&gt;</span>
<span class="sd">        [(0, 1], (1, 3], (2, 4]]</span>
<span class="sd">        Length: 3, dtype: interval[int64, right]</span>
<span class="sd">        &quot;&quot;&quot;</span>
            <span class="p">),</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;contains not implemented for two intervals&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">&lt;</span> <span class="n">other</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_left</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">other</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_right</span> <span class="k">else</span> <span class="n">other</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">!=</span> <span class="n">values</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
                <span class="c1"># not comparable -&gt; no overlap</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># GH#38353 instead of casting to object, operating on a</span>
                <span class="c1">#  complex128 ndarray is much more performant.</span>
                <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combined</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;complex128&quot;</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">_combined</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;complex128&quot;</span><span class="p">)</span>
                <span class="c1"># error: Argument 1 to &quot;in1d&quot; has incompatible type</span>
                <span class="c1"># &quot;Union[ExtensionArray, ndarray[Any, Any],</span>
                <span class="c1"># ndarray[Any, dtype[Any]]]&quot;; expected</span>
                <span class="c1"># &quot;Union[_SupportsArray[dtype[Any]],</span>
                <span class="c1"># _NestedSequence[_SupportsArray[dtype[Any]]], bool,</span>
                <span class="c1"># int, float, complex, str, bytes, _NestedSequence[</span>
                <span class="c1"># Union[bool, int, float, complex, str, bytes]]]&quot;</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

            <span class="k">elif</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">^</span> <span class="n">needs_i8_conversion</span><span class="p">(</span>
                <span class="n">values</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">):</span>
                <span class="c1"># not comparable -&gt; no overlap</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">),</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_combined</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalSideT</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">comb</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_concat_same_type</span><span class="p">([</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">comb</span>

    <span class="k">def</span> <span class="nf">_from_combined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">combined</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new IntervalArray with our dtype from a 1D complex128 ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">combined</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">,</span> <span class="p">(</span><span class="n">DatetimeArray</span><span class="p">,</span> <span class="n">TimedeltaArray</span><span class="p">))</span>
            <span class="n">new_left</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_left</span><span class="p">)</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">nc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">,</span> <span class="p">(</span><span class="n">DatetimeArray</span><span class="p">,</span> <span class="n">TimedeltaArray</span><span class="p">))</span>
            <span class="n">new_right</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_right</span><span class="p">)</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">nc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">new_left</span> <span class="o">=</span> <span class="n">nc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">new_right</span> <span class="o">=</span> <span class="n">nc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">new_left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">new_right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalArray</span><span class="p">:</span>
        <span class="c1"># No overload variant of &quot;__getitem__&quot; of &quot;ExtensionArray&quot; matches argument</span>
        <span class="c1"># type &quot;Tuple[slice, int]&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_combined</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;complex128&quot;</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># type: ignore[call-overload]</span>
        <span class="p">)</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">nc</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_combined</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_maybe_convert_platform_interval</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Try to do platform conversion, with special casing for IntervalArray.</span>
<span class="sd">    Wrapper around maybe_convert_platform that alters the default return</span>
<span class="sd">    dtype in certain cases to be compatible with IntervalArray.  For example,</span>
<span class="sd">    empty lists return with integer dtype instead of object dtype, which is</span>
<span class="sd">    prohibited for IntervalArray.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : array-like</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># GH 19016</span>
        <span class="c1"># empty lists/tuples get object dtype by default, but this is</span>
        <span class="c1"># prohibited for IntervalArray, so coerce to integer instead</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
        <span class="c1"># This will raise later, but we avoid passing to maybe_convert_platform</span>
        <span class="k">return</span> <span class="n">values</span>
    <span class="k">elif</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">range</span><span class="p">)):</span>
        <span class="c1"># TODO: should we just cast these to list?</span>
        <span class="k">return</span> <span class="n">values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">and</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso Furlanello, and Daniel Hug.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>