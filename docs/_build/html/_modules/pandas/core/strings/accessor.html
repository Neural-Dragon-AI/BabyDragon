<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pandas.core.strings.accessor &mdash; BabyDragon  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            BabyDragon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tasks:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/llm_task.html">llm_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/multi_kernel_task.html">multi_kernel_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/base_task.html">base_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/topic_tree_task.html">topic_tree_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/embedding_task.html">embedding_task</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Kernels:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/memory_kernel.html">memory_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_clustering.html">kernel_clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel.html">multi_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel_visualization.html">multi_kernel_visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_utils.html">kernel_utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Threads:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/base_thread.html">base_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/fifo_thread.html">fifo_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/vector_thread.html">vector_thread</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Indexes:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/memory_index.html">memory_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/pandas_index.html">pandas_index</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Chat:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/base_chat.html">base_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/memory_chat.html">memory_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/chat.html">chat</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utils:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/pandas.html">pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/hf_datasets.html">hf_datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/chatml.html">chatml</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/embedders:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/ada2.html">ada2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/sbert.html">sbert</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/generators:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/chatgpt.html">chatgpt</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Processors:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/git_metadata.html">git_metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html">visitors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html">python_parser</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Apps:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html">perspective</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">BabyDragon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pandas.core.strings.accessor</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pandas.core.strings.accessor</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AlignJoin</span><span class="p">,</span>
    <span class="n">DtypeObj</span><span class="p">,</span>
    <span class="n">F</span><span class="p">,</span>
    <span class="n">Scalar</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="n">Appender</span>
<span class="kn">from</span> <span class="nn">pandas.util._exceptions</span> <span class="kn">import</span> <span class="n">find_stack_level</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ensure_object</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_categorical_dtype</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
    <span class="n">is_re</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ABCDataFrame</span><span class="p">,</span>
    <span class="n">ABCIndex</span><span class="p">,</span>
    <span class="n">ABCMultiIndex</span><span class="p">,</span>
    <span class="n">ABCSeries</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="n">isna</span>

<span class="kn">from</span> <span class="nn">pandas.core.arrays.arrow.dtype</span> <span class="kn">import</span> <span class="n">ArrowDtype</span>
<span class="kn">from</span> <span class="nn">pandas.core.base</span> <span class="kn">import</span> <span class="n">NoNewAttributesMixin</span>
<span class="kn">from</span> <span class="nn">pandas.core.construction</span> <span class="kn">import</span> <span class="n">extract_array</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">Index</span><span class="p">,</span>
        <span class="n">Series</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">_shared_docs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_cpython_optimized_encoders</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;utf-8&quot;</span><span class="p">,</span>
    <span class="s2">&quot;utf8&quot;</span><span class="p">,</span>
    <span class="s2">&quot;latin-1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;latin1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;iso-8859-1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mbcs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ascii&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">_cpython_optimized_decoders</span> <span class="o">=</span> <span class="n">_cpython_optimized_encoders</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;utf-16&quot;</span><span class="p">,</span> <span class="s2">&quot;utf-32&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">forbid_nonstring_types</span><span class="p">(</span>
    <span class="n">forbidden</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">F</span><span class="p">],</span> <span class="n">F</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to forbid specific types for a method of StringMethods.</span>

<span class="sd">    For calling `.str.{method}` on a Series or Index, it is necessary to first</span>
<span class="sd">    initialize the :class:`StringMethods` object, and then call the method.</span>
<span class="sd">    However, different methods allow different input types, and so this can not</span>
<span class="sd">    be checked during :meth:`StringMethods.__init__`, but must be done on a</span>
<span class="sd">    per-method basis. This decorator exists to facilitate this process, and</span>
<span class="sd">    make it explicit which (inferred) types are disallowed by the method.</span>

<span class="sd">    :meth:`StringMethods.__init__` allows the *union* of types its different</span>
<span class="sd">    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),</span>
<span class="sd">    namely: [&#39;string&#39;, &#39;empty&#39;, &#39;bytes&#39;, &#39;mixed&#39;, &#39;mixed-integer&#39;].</span>

<span class="sd">    The default string types [&#39;string&#39;, &#39;empty&#39;] are allowed for all methods.</span>
<span class="sd">    For the additional types [&#39;bytes&#39;, &#39;mixed&#39;, &#39;mixed-integer&#39;], each method</span>
<span class="sd">    then needs to forbid the types it is not intended for.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    forbidden : list-of-str or None</span>
<span class="sd">        List of forbidden non-string types, may be one or more of</span>
<span class="sd">        `[&#39;bytes&#39;, &#39;mixed&#39;, &#39;mixed-integer&#39;]`.</span>
<span class="sd">    name : str, default None</span>
<span class="sd">        Name of the method to use in the error message. By default, this is</span>
<span class="sd">        None, in which case the name from the method being wrapped will be</span>
<span class="sd">        copied. However, for working with further wrappers (like _pat_wrapper</span>
<span class="sd">        and _noarg_wrapper), it is necessary to specify the name.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : wrapper</span>
<span class="sd">        The method to which the decorator is applied, with an added check that</span>
<span class="sd">        enforces the inferred type to not be in the list of forbidden types.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the inferred type of the underlying data is in `forbidden`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># deal with None</span>
    <span class="n">forbidden</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">forbidden</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">forbidden</span>

    <span class="n">allowed_types</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;empty&quot;</span><span class="p">,</span> <span class="s2">&quot;bytes&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed-integer&quot;</span><span class="p">}</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">forbidden</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_forbid_nonstring_types</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">F</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inferred_dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_types</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot use .str.</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2"> with values of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;inferred dtype &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_inferred_dtype</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func_name</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_forbid_nonstring_types</span>


<span class="k">def</span> <span class="nf">_map_and_wrap</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">docstring</span><span class="p">):</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_str_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">docstring</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">class</span> <span class="nc">StringMethods</span><span class="p">(</span><span class="n">NoNewAttributesMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vectorized string functions for Series and Index.</span>

<span class="sd">    NAs stay NA unless handled otherwise by a particular method.</span>
<span class="sd">    Patterned after Python&#39;s string methods, with some inspiration from</span>
<span class="sd">    R&#39;s stringr package.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s = pd.Series([&quot;A_Str_Series&quot;])</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    0    A_Str_Series</span>
<span class="sd">    dtype: object</span>

<span class="sd">    &gt;&gt;&gt; s.str.split(&quot;_&quot;)</span>
<span class="sd">    0    [A, Str, Series]</span>
<span class="sd">    dtype: object</span>

<span class="sd">    &gt;&gt;&gt; s.str.replace(&quot;_&quot;, &quot;&quot;)</span>
<span class="sd">    0    AStrSeries</span>
<span class="sd">    dtype: object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Note: see the docstring in pandas.core.strings.__init__</span>
    <span class="c1"># for an explanation of the implementation.</span>
    <span class="c1"># TODO: Dispatch all the methods</span>
    <span class="c1"># Currently the following are not dispatched to the array</span>
    <span class="c1"># * cat</span>
    <span class="c1"># * extractall</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.arrays.string_</span> <span class="kn">import</span> <span class="n">StringDtype</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_inferred_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_categorical</span> <span class="o">=</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_string</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">StringDtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># ._values.categories works for both Series/Index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">categories</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_categorical</span> <span class="k">else</span> <span class="n">data</span>
        <span class="c1"># save orig to blow up categoricals to the right type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freeze</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Auxiliary function for StringMethods, infers and checks dtype of data.</span>

<span class="sd">        This is a &quot;first line of defence&quot; at the creation of the StringMethods-</span>
<span class="sd">        object, and just checks that the dtype is in the</span>
<span class="sd">        *union* of the allowed types over all string methods below; this</span>
<span class="sd">        restriction is then refined on a per-method basis using the decorator</span>
<span class="sd">        @forbid_nonstring_types (more info in the corresponding docstring).</span>

<span class="sd">        This really should exclude all series/index with any non-string values,</span>
<span class="sd">        but that isn&#39;t practical for performance reasons until we have a str</span>
<span class="sd">        dtype (GH 9343 / 13877)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : The content of the Series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dtype : inferred dtype of data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Can only use .str accessor with Index, not MultiIndex&quot;</span>
            <span class="p">)</span>

        <span class="c1"># see _libs/lib.pyx for list of inferred types</span>
        <span class="n">allowed_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;empty&quot;</span><span class="p">,</span> <span class="s2">&quot;bytes&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed-integer&quot;</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;categories&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>  <span class="c1"># categorical / normal</span>

        <span class="n">inferred_dtype</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inferred_dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Can only use .str accessor with string values!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inferred_dtype</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_getitem</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_wrap_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">result</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">expand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">returns_string</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">returns_bool</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">Index</span><span class="p">,</span>
            <span class="n">MultiIndex</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;str&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span>

        <span class="c1"># We can be wrapping a string / object / categorical result, in which</span>
        <span class="c1"># case we&#39;ll want to return the same dtype as the input.</span>
        <span class="c1"># Or we can be wrapping a numeric output, in which case we don&#39;t want</span>
        <span class="c1"># to return a StringArray.</span>
        <span class="c1"># Ideally the array method returns the right array type.</span>
        <span class="k">if</span> <span class="n">expand</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># infer from ndim if expand is not specified</span>
            <span class="n">expand</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">expand</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">):</span>
            <span class="c1"># required when expand=True is explicitly specified</span>
            <span class="c1"># not needed when inferred</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ArrowDtype</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>

                <span class="kn">from</span> <span class="nn">pandas.core.arrays.arrow.array</span> <span class="kn">import</span> <span class="n">ArrowExtensionArray</span>

                <span class="n">max_len</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">compute</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">combine_chunks</span><span class="p">()</span><span class="o">.</span><span class="n">value_lengths</span><span class="p">()</span>
                <span class="p">)</span><span class="o">.</span><span class="n">as_py</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="c1"># ArrowExtensionArray.fillna doesn&#39;t work for list scalars</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fill_null</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">max_len</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_len</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">label</span><span class="p">:</span> <span class="n">ArrowExtensionArray</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="o">.</span><span class="n">tolist</span><span class="p">())))</span>
                <span class="p">}</span>
            <span class="k">elif</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">cons_row</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">x</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

                <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">cons_row</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_string</span><span class="p">:</span>
                    <span class="c1"># propagate nan values to match longest sequence (GH 18450)</span>
                    <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">x</span> <span class="o">*</span> <span class="n">max_len</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">else</span> <span class="n">x</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span>
                    <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expand</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expand must be True or False&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expand</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># if expand is False, result should have the same name</span>
            <span class="c1"># as the original otherwise specified</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># do not use logical or, _orig may be a DataFrame</span>
                <span class="c1"># which has &quot;name&quot; column</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># Wait until we are sure result is a Series or Index before</span>
        <span class="c1"># checking attributes (GH 12180)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">):</span>
            <span class="c1"># if result is a boolean np.array, return the np.array</span>
            <span class="c1"># instead of wrapping it into a boolean Index (GH 8875)</span>
            <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="k">if</span> <span class="n">expand</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># We had all tuples of length-one, which are</span>
                    <span class="c1"># better represented as a regular Index.</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">out</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">index</span>
            <span class="c1"># This is a mess.</span>
            <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeObj</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span>
            <span class="n">vdtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_string</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">vdtype</span><span class="p">):</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span>
                <span class="k">elif</span> <span class="n">returns_string</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">dtype</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">vdtype</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">vdtype</span>

            <span class="k">if</span> <span class="n">expand</span><span class="p">:</span>
                <span class="n">cons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">_constructor_expanddim</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Must be a Series</span>
                <span class="n">cons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">_constructor</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;str&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># __finalize__ might copy over the original name, but we may</span>
                <span class="c1"># want the new name (e.g. str.extract).</span>
                <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_get_series_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">others</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input</span>
<span class="sd">        into a list of Series (elements without an index must match the length</span>
<span class="sd">        of the calling Series/Index).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        others : Series, DataFrame, np.ndarray, list-like or list-like of</span>
<span class="sd">            Objects that are either Series, Index or np.ndarray (1-dim).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of Series</span>
<span class="sd">            Others transformed into list of Series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">Series</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># self._orig is either Series or Index</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">index</span>

        <span class="c1"># Generally speaking, all objects without an index inherit the index</span>
        <span class="c1"># `idx` of the calling Series/Index - i.e. must have matching length.</span>
        <span class="c1"># Objects with an index (i.e. Series/Index/DataFrame) keep their own.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">others</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Series</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">others</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">others</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">others</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">others</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">others</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">others</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">others</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">allow_sets</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">others</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">others</span><span class="p">)</span>  <span class="c1"># ensure iterators do not get read twice etc</span>

            <span class="c1"># in case of list-like `others`, all elements must be</span>
            <span class="c1"># either Series/Index/np.ndarray (1-dim)...</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">others</span>
            <span class="p">):</span>
                <span class="n">los</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="n">others</span><span class="p">:</span>  <span class="c1"># iterate through list and append each element</span>
                    <span class="n">los</span> <span class="o">=</span> <span class="n">los</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_series_list</span><span class="p">(</span><span class="n">others</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">los</span>
            <span class="c1"># ... or just strings</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">others</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">Series</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)]</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;others must be Series, Index, DataFrame, np.ndarray &quot;</span>
            <span class="s2">&quot;or list-like (either containing only strings or &quot;</span>
            <span class="s2">&quot;containing only objects of type Series/Index/&quot;</span>
            <span class="s2">&quot;np.ndarray[1-dim])&quot;</span>
        <span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed-integer&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">cat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">others</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">join</span><span class="p">:</span> <span class="n">AlignJoin</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate strings in the Series/Index with given separator.</span>

<span class="sd">        If `others` is specified, this function concatenates the Series/Index</span>
<span class="sd">        and elements of `others` element-wise.</span>
<span class="sd">        If `others` is not passed, then all values in the Series/Index are</span>
<span class="sd">        concatenated into a single string with a given `sep`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        others : Series, Index, DataFrame, np.ndarray or list-like</span>
<span class="sd">            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and</span>
<span class="sd">            other list-likes of strings must have the same length as the</span>
<span class="sd">            calling Series/Index, with the exception of indexed objects (i.e.</span>
<span class="sd">            Series/Index/DataFrame) if `join` is not None.</span>

<span class="sd">            If others is a list-like that contains a combination of Series,</span>
<span class="sd">            Index or np.ndarray (1-dim), then all elements will be unpacked and</span>
<span class="sd">            must satisfy the above criteria individually.</span>

<span class="sd">            If others is None, the method returns the concatenation of all</span>
<span class="sd">            strings in the calling Series/Index.</span>
<span class="sd">        sep : str, default &#39;&#39;</span>
<span class="sd">            The separator between the different elements/columns. By default</span>
<span class="sd">            the empty string `&#39;&#39;` is used.</span>
<span class="sd">        na_rep : str or None, default None</span>
<span class="sd">            Representation that is inserted for all missing values:</span>

<span class="sd">            - If `na_rep` is None, and `others` is None, missing values in the</span>
<span class="sd">              Series/Index are omitted from the result.</span>
<span class="sd">            - If `na_rep` is None, and `others` is not None, a row containing a</span>
<span class="sd">              missing value in any of the columns (before concatenation) will</span>
<span class="sd">              have a missing value in the result.</span>
<span class="sd">        join : {&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;}, default &#39;left&#39;</span>
<span class="sd">            Determines the join-style between the calling Series/Index and any</span>
<span class="sd">            Series/Index/DataFrame in `others` (objects without an index need</span>
<span class="sd">            to match the length of the calling Series/Index). To disable</span>
<span class="sd">            alignment, use `.values` on any Series/Index/DataFrame in `others`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str, Series or Index</span>
<span class="sd">            If `others` is None, `str` is returned, otherwise a `Series/Index`</span>
<span class="sd">            (same type as caller) of objects is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        split : Split each string in the Series/Index.</span>
<span class="sd">        join : Join lists contained as elements in the Series/Index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        When not passing `others`, all values are concatenated into a single</span>
<span class="sd">        string:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;b&#39;, np.nan, &#39;d&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s.str.cat(sep=&#39; &#39;)</span>
<span class="sd">        &#39;a b d&#39;</span>

<span class="sd">        By default, NA values in the Series are ignored. Using `na_rep`, they</span>
<span class="sd">        can be given a representation:</span>

<span class="sd">        &gt;&gt;&gt; s.str.cat(sep=&#39; &#39;, na_rep=&#39;?&#39;)</span>
<span class="sd">        &#39;a b ? d&#39;</span>

<span class="sd">        If `others` is specified, corresponding values are concatenated with</span>
<span class="sd">        the separator. Result will be a Series of strings.</span>

<span class="sd">        &gt;&gt;&gt; s.str.cat([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], sep=&#39;,&#39;)</span>
<span class="sd">        0    a,A</span>
<span class="sd">        1    b,B</span>
<span class="sd">        2    NaN</span>
<span class="sd">        3    d,D</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Missing values will remain missing in the result, but can again be</span>
<span class="sd">        represented using `na_rep`</span>

<span class="sd">        &gt;&gt;&gt; s.str.cat([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], sep=&#39;,&#39;, na_rep=&#39;-&#39;)</span>
<span class="sd">        0    a,A</span>
<span class="sd">        1    b,B</span>
<span class="sd">        2    -,C</span>
<span class="sd">        3    d,D</span>
<span class="sd">        dtype: object</span>

<span class="sd">        If `sep` is not specified, the values are concatenated without</span>
<span class="sd">        separation.</span>

<span class="sd">        &gt;&gt;&gt; s.str.cat([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], na_rep=&#39;-&#39;)</span>
<span class="sd">        0    aA</span>
<span class="sd">        1    bB</span>
<span class="sd">        2    -C</span>
<span class="sd">        3    dD</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Series with different indexes can be aligned before concatenation. The</span>
<span class="sd">        `join`-keyword works as in other methods.</span>

<span class="sd">        &gt;&gt;&gt; t = pd.Series([&#39;d&#39;, &#39;a&#39;, &#39;e&#39;, &#39;c&#39;], index=[3, 0, 4, 2])</span>
<span class="sd">        &gt;&gt;&gt; s.str.cat(t, join=&#39;left&#39;, na_rep=&#39;-&#39;)</span>
<span class="sd">        0    aa</span>
<span class="sd">        1    b-</span>
<span class="sd">        2    -c</span>
<span class="sd">        3    dd</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.str.cat(t, join=&#39;outer&#39;, na_rep=&#39;-&#39;)</span>
<span class="sd">        0    aa</span>
<span class="sd">        1    b-</span>
<span class="sd">        2    -c</span>
<span class="sd">        3    dd</span>
<span class="sd">        4    -e</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.str.cat(t, join=&#39;inner&#39;, na_rep=&#39;-&#39;)</span>
<span class="sd">        0    aa</span>
<span class="sd">        2    -c</span>
<span class="sd">        3    dd</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.str.cat(t, join=&#39;right&#39;, na_rep=&#39;-&#39;)</span>
<span class="sd">        3    dd</span>
<span class="sd">        0    aa</span>
<span class="sd">        4    -e</span>
<span class="sd">        2    -c</span>
<span class="sd">        dtype: object</span>

<span class="sd">        For more examples, see :ref:`here &lt;text.concatenate&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: dispatch</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">Index</span><span class="p">,</span>
            <span class="n">Series</span><span class="p">,</span>
            <span class="n">concat</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Did you mean to supply a `sep` keyword?&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Series</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span>

        <span class="c1"># concatenate Series/Index with itself if no &quot;others&quot;</span>
        <span class="k">if</span> <span class="n">others</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># error: Incompatible types in assignment (expression has type</span>
            <span class="c1"># &quot;ndarray&quot;, variable has type &quot;Series&quot;)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">ensure_object</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># type: ignore[assignment]</span>
            <span class="n">na_mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">na_rep</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">na_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">na_mask</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">na_rep</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">na_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">na_mask</span><span class="p">,</span> <span class="n">na_rep</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># turn anything in &quot;others&quot; into lists of Series</span>
            <span class="n">others</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_series_list</span><span class="p">(</span><span class="n">others</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>  <span class="c1"># do not catch TypeError raised by _get_series_list</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If `others` contains arrays or lists (or other &quot;</span>
                <span class="s2">&quot;list-likes without an index), these must all be &quot;</span>
                <span class="s2">&quot;of the same length as the calling Series/Index.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># align if required</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">others</span><span class="p">):</span>
            <span class="c1"># Need to add keys for uniqueness in case of duplicate columns</span>
            <span class="n">others</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span>
                <span class="n">others</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">join</span><span class="o">=</span><span class="p">(</span><span class="n">join</span> <span class="k">if</span> <span class="n">join</span> <span class="o">==</span> <span class="s2">&quot;inner&quot;</span> <span class="k">else</span> <span class="s2">&quot;outer&quot;</span><span class="p">),</span>
                <span class="n">keys</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)),</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">others</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">)</span>
            <span class="n">others</span> <span class="o">=</span> <span class="p">[</span><span class="n">others</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">others</span><span class="p">]</span>  <span class="c1"># again list of Series</span>

        <span class="n">all_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">ensure_object</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">+</span> <span class="n">others</span><span class="p">]</span>
        <span class="n">na_masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_cols</span><span class="p">])</span>
        <span class="n">union_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">na_masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">na_rep</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">union_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># no na_rep means NaNs for all rows where any column has a NaN</span>
            <span class="c1"># only necessary if there are actually any NaNs</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">union_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="n">not_masked</span> <span class="o">=</span> <span class="o">~</span><span class="n">union_mask</span>
            <span class="n">result</span><span class="p">[</span><span class="n">not_masked</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat_safe</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">not_masked</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_cols</span><span class="p">],</span> <span class="n">sep</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">na_rep</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">union_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># fill NaNs with na_rep in case there are actually any NaNs</span>
            <span class="n">all_cols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span> <span class="n">na_rep</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">nm</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">na_masks</span><span class="p">,</span> <span class="n">all_cols</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">cat_safe</span><span class="p">(</span><span class="n">all_cols</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no NaNs - can just concatenate</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">cat_safe</span><span class="p">(</span><span class="n">all_cols</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>

        <span class="n">out</span><span class="p">:</span> <span class="n">Index</span> <span class="o">|</span> <span class="n">Series</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">):</span>
            <span class="c1"># add dtype for case that result is all-NA</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Series</span>
            <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># We need to infer the new categories.</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">dtype</span>
            <span class="n">res_ser</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">res_ser</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;str_cat&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;str_split&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Split strings around given separator/delimiter.</span>

<span class="s2">    Splits the string in the Series/Index from the </span><span class="si">%(side)s</span><span class="s2">,</span>
<span class="s2">    at the specified delimiter string.</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    pat : str</span><span class="si">%(pat_regex)s</span><span class="s2">, optional</span>
<span class="s2">        </span><span class="si">%(pat_description)s</span><span class="s2">.</span>
<span class="s2">        If not specified, split on whitespace.</span>
<span class="s2">    n : int, default -1 (all)</span>
<span class="s2">        Limit number of splits in output.</span>
<span class="s2">        ``None``, 0 and -1 will be interpreted as return all splits.</span>
<span class="s2">    expand : bool, default False</span>
<span class="s2">        Expand the split strings into separate columns.</span>

<span class="s2">        - If ``True``, return DataFrame/MultiIndex expanding dimensionality.</span>
<span class="s2">        - If ``False``, return Series/Index, containing lists of strings.</span>
<span class="s2">    </span><span class="si">%(regex_argument)s</span>
<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    Series, Index, DataFrame or MultiIndex</span>
<span class="s2">        Type matches caller unless ``expand=True`` (see Notes).</span>
<span class="s2">    </span><span class="si">%(raises_split)s</span>
<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    Series.str.split : Split strings around given separator/delimiter.</span>
<span class="s2">    Series.str.rsplit : Splits string around given separator/delimiter,</span>
<span class="s2">        starting from the right.</span>
<span class="s2">    Series.str.join : Join lists contained as elements in the Series/Index</span>
<span class="s2">        with passed delimiter.</span>
<span class="s2">    str.split : Standard library version for split.</span>
<span class="s2">    str.rsplit : Standard library version for rsplit.</span>

<span class="s2">    Notes</span>
<span class="s2">    -----</span>
<span class="s2">    The handling of the `n` keyword depends on the number of found splits:</span>

<span class="s2">    - If found splits &gt; `n`,  make first `n` splits only</span>
<span class="s2">    - If found splits &lt;= `n`, make all splits</span>
<span class="s2">    - If for a certain row the number of found splits &lt; `n`,</span>
<span class="s2">      append `None` for padding up to `n` if ``expand=True``</span>

<span class="s2">    If using ``expand=True``, Series and Index callers return DataFrame and</span>
<span class="s2">    MultiIndex objects, respectively.</span>
<span class="s2">    </span><span class="si">%(regex_pat_note)s</span>
<span class="s2">    Examples</span>
<span class="s2">    --------</span>
<span class="s2">    &gt;&gt;&gt; s = pd.Series(</span>
<span class="s2">    ...     [</span>
<span class="s2">    ...         &quot;this is a regular sentence&quot;,</span>
<span class="s2">    ...         &quot;https://docs.python.org/3/tutorial/index.html&quot;,</span>
<span class="s2">    ...         np.nan</span>
<span class="s2">    ...     ]</span>
<span class="s2">    ... )</span>
<span class="s2">    &gt;&gt;&gt; s</span>
<span class="s2">    0                       this is a regular sentence</span>
<span class="s2">    1    https://docs.python.org/3/tutorial/index.html</span>
<span class="s2">    2                                              NaN</span>
<span class="s2">    dtype: object</span>

<span class="s2">    In the default setting, the string is split by whitespace.</span>

<span class="s2">    &gt;&gt;&gt; s.str.split()</span>
<span class="s2">    0                   [this, is, a, regular, sentence]</span>
<span class="s2">    1    [https://docs.python.org/3/tutorial/index.html]</span>
<span class="s2">    2                                                NaN</span>
<span class="s2">    dtype: object</span>

<span class="s2">    Without the `n` parameter, the outputs of `rsplit` and `split`</span>
<span class="s2">    are identical.</span>

<span class="s2">    &gt;&gt;&gt; s.str.rsplit()</span>
<span class="s2">    0                   [this, is, a, regular, sentence]</span>
<span class="s2">    1    [https://docs.python.org/3/tutorial/index.html]</span>
<span class="s2">    2                                                NaN</span>
<span class="s2">    dtype: object</span>

<span class="s2">    The `n` parameter can be used to limit the number of splits on the</span>
<span class="s2">    delimiter. The outputs of `split` and `rsplit` are different.</span>

<span class="s2">    &gt;&gt;&gt; s.str.split(n=2)</span>
<span class="s2">    0                     [this, is, a regular sentence]</span>
<span class="s2">    1    [https://docs.python.org/3/tutorial/index.html]</span>
<span class="s2">    2                                                NaN</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.rsplit(n=2)</span>
<span class="s2">    0                     [this is a, regular, sentence]</span>
<span class="s2">    1    [https://docs.python.org/3/tutorial/index.html]</span>
<span class="s2">    2                                                NaN</span>
<span class="s2">    dtype: object</span>

<span class="s2">    The `pat` parameter can be used to split by other characters.</span>

<span class="s2">    &gt;&gt;&gt; s.str.split(pat=&quot;/&quot;)</span>
<span class="s2">    0                         [this is a regular sentence]</span>
<span class="s2">    1    [https:, , docs.python.org, 3, tutorial, index...</span>
<span class="s2">    2                                                  NaN</span>
<span class="s2">    dtype: object</span>

<span class="s2">    When using ``expand=True``, the split elements will expand out into</span>
<span class="s2">    separate columns. If NaN is present, it is propagated throughout</span>
<span class="s2">    the columns during the split.</span>

<span class="s2">    &gt;&gt;&gt; s.str.split(expand=True)</span>
<span class="s2">                                                   0     1     2        3         4</span>
<span class="s2">    0                                           this    is     a  regular  sentence</span>
<span class="s2">    1  https://docs.python.org/3/tutorial/index.html  None  None     None      None</span>
<span class="s2">    2                                            NaN   NaN   NaN      NaN       NaN</span>

<span class="s2">    For slightly more complex use cases like splitting the html document name</span>
<span class="s2">    from a url, a combination of parameter settings can be used.</span>

<span class="s2">    &gt;&gt;&gt; s.str.rsplit(&quot;/&quot;, n=1, expand=True)</span>
<span class="s2">                                        0           1</span>
<span class="s2">    0          this is a regular sentence        None</span>
<span class="s2">    1  https://docs.python.org/3/tutorial  index.html</span>
<span class="s2">    2                                 NaN         NaN</span>
<span class="s2">    </span><span class="si">%(regex_examples)s</span><span class="s2">&quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_split&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;beginning&quot;</span><span class="p">,</span>
            <span class="s2">&quot;pat_regex&quot;</span><span class="p">:</span> <span class="s2">&quot; or compiled regex&quot;</span><span class="p">,</span>
            <span class="s2">&quot;pat_description&quot;</span><span class="p">:</span> <span class="s2">&quot;String or regular expression to split on&quot;</span><span class="p">,</span>
            <span class="s2">&quot;regex_argument&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    regex : bool, default None</span>
<span class="s2">        Determines if the passed-in pattern is a regular expression:</span>

<span class="s2">        - If ``True``, assumes the passed-in pattern is a regular expression</span>
<span class="s2">        - If ``False``, treats the pattern as a literal string.</span>
<span class="s2">        - If ``None`` and `pat` length is 1, treats `pat` as a literal string.</span>
<span class="s2">        - If ``None`` and `pat` length is not 1, treats `pat` as a regular expression.</span>
<span class="s2">        - Cannot be set to False if `pat` is a compiled regex</span>

<span class="s2">        .. versionadded:: 1.4.0</span>
<span class="s2">         &quot;&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;raises_split&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                      Raises</span>
<span class="s2">                      ------</span>
<span class="s2">                      ValueError</span>
<span class="s2">                          * if `regex` is False and `pat` is a compiled regex</span>
<span class="s2">                      &quot;&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;regex_pat_note&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Use of `regex =False` with a `pat` as a compiled regex will raise an error.</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;split&quot;</span><span class="p">,</span>
            <span class="s2">&quot;regex_examples&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Remember to escape special characters when explicitly using regular expressions.</span>

<span class="s2">    &gt;&gt;&gt; s = pd.Series([&quot;foo and bar plus baz&quot;])</span>
<span class="s2">    &gt;&gt;&gt; s.str.split(r&quot;and|plus&quot;, expand=True)</span>
<span class="s2">        0   1   2</span>
<span class="s2">    0 foo bar baz</span>

<span class="s2">    Regular expressions can be used to handle urls or file names.</span>
<span class="s2">    When `pat` is a string and ``regex=None`` (the default), the given `pat` is compiled</span>
<span class="s2">    as a regex only if ``len(pat) != 1``.</span>

<span class="s2">    &gt;&gt;&gt; s = pd.Series([&#39;foojpgbar.jpg&#39;])</span>
<span class="s2">    &gt;&gt;&gt; s.str.split(r&quot;.&quot;, expand=True)</span>
<span class="s2">               0    1</span>
<span class="s2">    0  foojpgbar  jpg</span>

<span class="s2">    &gt;&gt;&gt; s.str.split(r&quot;\.jpg&quot;, expand=True)</span>
<span class="s2">               0 1</span>
<span class="s2">    0  foojpgbar</span>

<span class="s2">    When ``regex=True``, `pat` is interpreted as a regex</span>

<span class="s2">    &gt;&gt;&gt; s.str.split(r&quot;\.jpg&quot;, regex=True, expand=True)</span>
<span class="s2">               0 1</span>
<span class="s2">    0  foojpgbar</span>

<span class="s2">    A compiled regex can be passed as `pat`</span>

<span class="s2">    &gt;&gt;&gt; import re</span>
<span class="s2">    &gt;&gt;&gt; s.str.split(re.compile(r&quot;\.jpg&quot;), expand=True)</span>
<span class="s2">               0 1</span>
<span class="s2">    0  foojpgbar</span>

<span class="s2">    When ``regex=False``, `pat` is interpreted as the string itself</span>

<span class="s2">    &gt;&gt;&gt; s.str.split(r&quot;\.jpg&quot;, regex=False, expand=True)</span>
<span class="s2">                   0</span>
<span class="s2">    0  foojpgbar.jpg</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pat</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">n</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">expand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">regex</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">is_re</span><span class="p">(</span><span class="n">pat</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use a compiled regex as replacement pattern with regex=False&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">is_re</span><span class="p">(</span><span class="n">pat</span><span class="p">):</span>
            <span class="n">regex</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_split</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">expand</span><span class="p">,</span> <span class="n">regex</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="n">expand</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="n">expand</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_split&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;end&quot;</span><span class="p">,</span>
            <span class="s2">&quot;pat_regex&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;pat_description&quot;</span><span class="p">:</span> <span class="s2">&quot;String to split on&quot;</span><span class="p">,</span>
            <span class="s2">&quot;regex_argument&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;raises_split&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;regex_pat_note&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;rsplit&quot;</span><span class="p">,</span>
            <span class="s2">&quot;regex_examples&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">rsplit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">n</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">expand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_rsplit</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="n">expand</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="n">expand</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;str_partition&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Split the string at the </span><span class="si">%(side)s</span><span class="s2"> occurrence of `sep`.</span>

<span class="s2">    This method splits the string at the </span><span class="si">%(side)s</span><span class="s2"> occurrence of `sep`,</span>
<span class="s2">    and returns 3 elements containing the part before the separator,</span>
<span class="s2">    the separator itself, and the part after the separator.</span>
<span class="s2">    If the separator is not found, return </span><span class="si">%(return)s</span><span class="s2">.</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    sep : str, default whitespace</span>
<span class="s2">        String to split on.</span>
<span class="s2">    expand : bool, default True</span>
<span class="s2">        If True, return DataFrame/MultiIndex expanding dimensionality.</span>
<span class="s2">        If False, return Series/Index.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    DataFrame/MultiIndex or Series/Index of objects</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    </span><span class="si">%(also)s</span>
<span class="s2">    Series.str.split : Split strings around given separators.</span>
<span class="s2">    str.partition : Standard library version.</span>

<span class="s2">    Examples</span>
<span class="s2">    --------</span>

<span class="s2">    &gt;&gt;&gt; s = pd.Series([&#39;Linda van der Berg&#39;, &#39;George Pitt-Rivers&#39;])</span>
<span class="s2">    &gt;&gt;&gt; s</span>
<span class="s2">    0    Linda van der Berg</span>
<span class="s2">    1    George Pitt-Rivers</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.partition()</span>
<span class="s2">            0  1             2</span>
<span class="s2">    0   Linda     van der Berg</span>
<span class="s2">    1  George      Pitt-Rivers</span>

<span class="s2">    To partition by the last space instead of the first one:</span>

<span class="s2">    &gt;&gt;&gt; s.str.rpartition()</span>
<span class="s2">                   0  1            2</span>
<span class="s2">    0  Linda van der            Berg</span>
<span class="s2">    1         George     Pitt-Rivers</span>

<span class="s2">    To partition by something different than a space:</span>

<span class="s2">    &gt;&gt;&gt; s.str.partition(&#39;-&#39;)</span>
<span class="s2">                        0  1       2</span>
<span class="s2">    0  Linda van der Berg</span>
<span class="s2">    1         George Pitt  -  Rivers</span>

<span class="s2">    To return a Series containing tuples instead of a DataFrame:</span>

<span class="s2">    &gt;&gt;&gt; s.str.partition(&#39;-&#39;, expand=False)</span>
<span class="s2">    0    (Linda van der Berg, , )</span>
<span class="s2">    1    (George Pitt, -, Rivers)</span>
<span class="s2">    dtype: object</span>

<span class="s2">    Also available on indices:</span>

<span class="s2">    &gt;&gt;&gt; idx = pd.Index([&#39;X 123&#39;, &#39;Y 999&#39;])</span>
<span class="s2">    &gt;&gt;&gt; idx</span>
<span class="s2">    Index([&#39;X 123&#39;, &#39;Y 999&#39;], dtype=&#39;object&#39;)</span>

<span class="s2">    Which will create a MultiIndex:</span>

<span class="s2">    &gt;&gt;&gt; idx.str.partition()</span>
<span class="s2">    MultiIndex([(&#39;X&#39;, &#39; &#39;, &#39;123&#39;),</span>
<span class="s2">                (&#39;Y&#39;, &#39; &#39;, &#39;999&#39;)],</span>
<span class="s2">               )</span>

<span class="s2">    Or an index with tuples with ``expand=False``:</span>

<span class="s2">    &gt;&gt;&gt; idx.str.partition(expand=False)</span>
<span class="s2">    Index([(&#39;X&#39;, &#39; &#39;, &#39;123&#39;), (&#39;Y&#39;, &#39; &#39;, &#39;999&#39;)], dtype=&#39;object&#39;)</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_partition&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
            <span class="s2">&quot;return&quot;</span><span class="p">:</span> <span class="s2">&quot;3 elements containing the string itself, followed by two &quot;</span>
            <span class="s2">&quot;empty strings&quot;</span><span class="p">,</span>
            <span class="s2">&quot;also&quot;</span><span class="p">:</span> <span class="s2">&quot;rpartition : Split the string at the last occurrence of `sep`.&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">expand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_partition</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">expand</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="n">expand</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="n">expand</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_partition&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span>
            <span class="s2">&quot;return&quot;</span><span class="p">:</span> <span class="s2">&quot;3 elements containing two empty strings, followed by the &quot;</span>
            <span class="s2">&quot;string itself&quot;</span><span class="p">,</span>
            <span class="s2">&quot;also&quot;</span><span class="p">:</span> <span class="s2">&quot;partition : Split the string at the first occurrence of `sep`.&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">rpartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">expand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_rpartition</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">expand</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="n">expand</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="n">expand</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract element from each component at specified position or with specified key.</span>

<span class="sd">        Extract element from lists, tuples, dict, or strings in each element in the</span>
<span class="sd">        Series/Index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int or hashable dict label</span>
<span class="sd">            Position or key of element to extract.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&quot;String&quot;,</span>
<span class="sd">        ...               (1, 2, 3),</span>
<span class="sd">        ...               [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],</span>
<span class="sd">        ...               123,</span>
<span class="sd">        ...               -456,</span>
<span class="sd">        ...               {1: &quot;Hello&quot;, &quot;2&quot;: &quot;World&quot;}])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0                        String</span>
<span class="sd">        1                     (1, 2, 3)</span>
<span class="sd">        2                     [a, b, c]</span>
<span class="sd">        3                           123</span>
<span class="sd">        4                          -456</span>
<span class="sd">        5    {1: &#39;Hello&#39;, &#39;2&#39;: &#39;World&#39;}</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.get(1)</span>
<span class="sd">        0        t</span>
<span class="sd">        1        2</span>
<span class="sd">        2        b</span>
<span class="sd">        3      NaN</span>
<span class="sd">        4      NaN</span>
<span class="sd">        5    Hello</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.get(-1)</span>
<span class="sd">        0      g</span>
<span class="sd">        1      3</span>
<span class="sd">        2      c</span>
<span class="sd">        3    NaN</span>
<span class="sd">        4    NaN</span>
<span class="sd">        5    None</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Return element with given key</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([{&quot;name&quot;: &quot;Hello&quot;, &quot;value&quot;: &quot;World&quot;},</span>
<span class="sd">        ...               {&quot;name&quot;: &quot;Goodbye&quot;, &quot;value&quot;: &quot;Planet&quot;}])</span>
<span class="sd">        &gt;&gt;&gt; s.str.get(&#39;name&#39;)</span>
<span class="sd">        0      Hello</span>
<span class="sd">        1    Goodbye</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join lists contained as elements in the Series/Index with passed delimiter.</span>

<span class="sd">        If the elements of a Series are lists themselves, join the content of these</span>
<span class="sd">        lists using the delimiter passed to the function.</span>
<span class="sd">        This function is an equivalent to :meth:`str.join`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sep : str</span>
<span class="sd">            Delimiter to use between list entries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series/Index: object</span>
<span class="sd">            The list entries concatenated by intervening occurrences of the</span>
<span class="sd">            delimiter.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If the supplied Series contains neither strings nor lists.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        str.join : Standard library version of this method.</span>
<span class="sd">        Series.str.split : Split strings around given separator/delimiter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If any of the list items is not a string object, the result of the join</span>
<span class="sd">        will be `NaN`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Example with a list that contains non-string elements.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([[&#39;lion&#39;, &#39;elephant&#39;, &#39;zebra&#39;],</span>
<span class="sd">        ...                [1.1, 2.2, 3.3],</span>
<span class="sd">        ...                [&#39;cat&#39;, np.nan, &#39;dog&#39;],</span>
<span class="sd">        ...                [&#39;cow&#39;, 4.5, &#39;goat&#39;],</span>
<span class="sd">        ...                [&#39;duck&#39;, [&#39;swan&#39;, &#39;fish&#39;], &#39;guppy&#39;]])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0        [lion, elephant, zebra]</span>
<span class="sd">        1                [1.1, 2.2, 3.3]</span>
<span class="sd">        2                [cat, nan, dog]</span>
<span class="sd">        3               [cow, 4.5, goat]</span>
<span class="sd">        4    [duck, [swan, fish], guppy]</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Join all lists using a &#39;-&#39;. The lists containing object(s) of types other</span>
<span class="sd">        than str will produce a NaN.</span>

<span class="sd">        &gt;&gt;&gt; s.str.join(&#39;-&#39;)</span>
<span class="sd">        0    lion-elephant-zebra</span>
<span class="sd">        1                    NaN</span>
<span class="sd">        2                    NaN</span>
<span class="sd">        3                    NaN</span>
<span class="sd">        4                    NaN</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_join</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">case</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if pattern or regex is contained within a string of a Series or Index.</span>

<span class="sd">        Return boolean Series or Index based on whether a given pattern or regex is</span>
<span class="sd">        contained within a string of a Series or Index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pat : str</span>
<span class="sd">            Character sequence or regular expression.</span>
<span class="sd">        case : bool, default True</span>
<span class="sd">            If True, case sensitive.</span>
<span class="sd">        flags : int, default 0 (no flags)</span>
<span class="sd">            Flags to pass through to the re module, e.g. re.IGNORECASE.</span>
<span class="sd">        na : scalar, optional</span>
<span class="sd">            Fill value for missing values. The default depends on dtype of the</span>
<span class="sd">            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,</span>
<span class="sd">            ``pandas.NA`` is used.</span>
<span class="sd">        regex : bool, default True</span>
<span class="sd">            If True, assumes the pat is a regular expression.</span>

<span class="sd">            If False, treats the pat as a literal string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index of boolean values</span>
<span class="sd">            A Series or Index of boolean values indicating whether the</span>
<span class="sd">            given pattern is contained within the string of each element</span>
<span class="sd">            of the Series or Index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        match : Analogous, but stricter, relying on re.match instead of re.search.</span>
<span class="sd">        Series.str.startswith : Test if the start of each string element matches a</span>
<span class="sd">            pattern.</span>
<span class="sd">        Series.str.endswith : Same as startswith, but tests the end of string.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Returning a Series of booleans using only a literal pattern.</span>

<span class="sd">        &gt;&gt;&gt; s1 = pd.Series([&#39;Mouse&#39;, &#39;dog&#39;, &#39;house and parrot&#39;, &#39;23&#39;, np.NaN])</span>
<span class="sd">        &gt;&gt;&gt; s1.str.contains(&#39;og&#39;, regex=False)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4      NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Returning an Index of booleans using only a literal pattern.</span>

<span class="sd">        &gt;&gt;&gt; ind = pd.Index([&#39;Mouse&#39;, &#39;dog&#39;, &#39;house and parrot&#39;, &#39;23.0&#39;, np.NaN])</span>
<span class="sd">        &gt;&gt;&gt; ind.str.contains(&#39;23&#39;, regex=False)</span>
<span class="sd">        Index([False, False, False, True, nan], dtype=&#39;object&#39;)</span>

<span class="sd">        Specifying case sensitivity using `case`.</span>

<span class="sd">        &gt;&gt;&gt; s1.str.contains(&#39;oG&#39;, case=True, regex=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4      NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Specifying `na` to be `False` instead of `NaN` replaces NaN values</span>
<span class="sd">        with `False`. If Series or Index does not contain NaN values</span>
<span class="sd">        the resultant dtype will be `bool`, otherwise, an `object` dtype.</span>

<span class="sd">        &gt;&gt;&gt; s1.str.contains(&#39;og&#39;, na=False, regex=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Returning &#39;house&#39; or &#39;dog&#39; when either expression occurs in a string.</span>

<span class="sd">        &gt;&gt;&gt; s1.str.contains(&#39;house|dog&#39;, regex=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4      NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Ignoring case sensitivity using `flags` with regex.</span>

<span class="sd">        &gt;&gt;&gt; import re</span>
<span class="sd">        &gt;&gt;&gt; s1.str.contains(&#39;PARROT&#39;, flags=re.IGNORECASE, regex=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4      NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Returning any digit using regular expression.</span>

<span class="sd">        &gt;&gt;&gt; s1.str.contains(&#39;\\d&#39;, regex=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3     True</span>
<span class="sd">        4      NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Ensure `pat` is a not a literal pattern when `regex` is set to True.</span>
<span class="sd">        Note in the following example one might expect only `s2[1]` and `s2[3]` to</span>
<span class="sd">        return `True`. However, &#39;.0&#39; as a regex matches any character</span>
<span class="sd">        followed by a 0.</span>

<span class="sd">        &gt;&gt;&gt; s2 = pd.Series([&#39;40&#39;, &#39;40.0&#39;, &#39;41&#39;, &#39;41.0&#39;, &#39;35&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s2.str.contains(&#39;.0&#39;, regex=True)</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3     True</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regex</span> <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;This pattern is interpreted as a regular expression, and has &quot;</span>
                <span class="s2">&quot;match groups. To actually get the groups, use str.extract.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
            <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_contains</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">case</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">regex</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">na</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">case</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if each string starts with a match of a regular expression.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pat : str</span>
<span class="sd">            Character sequence or regular expression.</span>
<span class="sd">        case : bool, default True</span>
<span class="sd">            If True, case sensitive.</span>
<span class="sd">        flags : int, default 0 (no flags)</span>
<span class="sd">            Regex module flags, e.g. re.IGNORECASE.</span>
<span class="sd">        na : scalar, optional</span>
<span class="sd">            Fill value for missing values. The default depends on dtype of the</span>
<span class="sd">            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,</span>
<span class="sd">            ``pandas.NA`` is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series/Index/array of boolean values</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fullmatch : Stricter matching that requires the entire string to match.</span>
<span class="sd">        contains : Analogous, but less strict, relying on re.search instead of</span>
<span class="sd">            re.match.</span>
<span class="sd">        extract : Extract matched groups.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_match</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="n">case</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="n">na</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">na</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">fullmatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">case</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if each string entirely matches a regular expression.</span>

<span class="sd">        .. versionadded:: 1.1.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pat : str</span>
<span class="sd">            Character sequence or regular expression.</span>
<span class="sd">        case : bool, default True</span>
<span class="sd">            If True, case sensitive.</span>
<span class="sd">        flags : int, default 0 (no flags)</span>
<span class="sd">            Regex module flags, e.g. re.IGNORECASE.</span>
<span class="sd">        na : scalar, optional</span>
<span class="sd">            Fill value for missing values. The default depends on dtype of the</span>
<span class="sd">            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,</span>
<span class="sd">            ``pandas.NA`` is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series/Index/array of boolean values</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        match : Similar, but also returns `True` when only a *prefix* of the string</span>
<span class="sd">            matches the regular expression.</span>
<span class="sd">        extract : Extract matched groups.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_fullmatch</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="n">case</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="n">na</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">na</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pat</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">,</span>
        <span class="n">repl</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">case</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace each occurrence of pattern/regex in the Series/Index.</span>

<span class="sd">        Equivalent to :meth:`str.replace` or :func:`re.sub`, depending on</span>
<span class="sd">        the regex value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pat : str or compiled regex</span>
<span class="sd">            String can be a character sequence or regular expression.</span>
<span class="sd">        repl : str or callable</span>
<span class="sd">            Replacement string or a callable. The callable is passed the regex</span>
<span class="sd">            match object and must return a replacement string to be used.</span>
<span class="sd">            See :func:`re.sub`.</span>
<span class="sd">        n : int, default -1 (all)</span>
<span class="sd">            Number of replacements to make from start.</span>
<span class="sd">        case : bool, default None</span>
<span class="sd">            Determines if replace is case sensitive:</span>

<span class="sd">            - If True, case sensitive (the default if `pat` is a string)</span>
<span class="sd">            - Set to False for case insensitive</span>
<span class="sd">            - Cannot be set if `pat` is a compiled regex.</span>

<span class="sd">        flags : int, default 0 (no flags)</span>
<span class="sd">            Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled</span>
<span class="sd">            regex.</span>
<span class="sd">        regex : bool, default False</span>
<span class="sd">            Determines if the passed-in pattern is a regular expression:</span>

<span class="sd">            - If True, assumes the passed-in pattern is a regular expression.</span>
<span class="sd">            - If False, treats the pattern as a literal string</span>
<span class="sd">            - Cannot be set to False if `pat` is a compiled regex or `repl` is</span>
<span class="sd">              a callable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index of object</span>
<span class="sd">            A copy of the object with all matching occurrences of `pat` replaced by</span>
<span class="sd">            `repl`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * if `regex` is False and `repl` is a callable or `pat` is a compiled</span>
<span class="sd">              regex</span>
<span class="sd">            * if `pat` is a compiled regex and `case` or `flags` is set</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When `pat` is a compiled regex, all flags should be included in the</span>
<span class="sd">        compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled</span>
<span class="sd">        regex will raise an error.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        When `pat` is a string and `regex` is True (the default), the given `pat`</span>
<span class="sd">        is compiled as a regex. When `repl` is a string, it replaces matching</span>
<span class="sd">        regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are</span>
<span class="sd">        left as is:</span>

<span class="sd">        &gt;&gt;&gt; pd.Series([&#39;foo&#39;, &#39;fuz&#39;, np.nan]).str.replace(&#39;f.&#39;, &#39;ba&#39;, regex=True)</span>
<span class="sd">        0    bao</span>
<span class="sd">        1    baz</span>
<span class="sd">        2    NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        When `pat` is a string and `regex` is False, every `pat` is replaced with</span>
<span class="sd">        `repl` as with :meth:`str.replace`:</span>

<span class="sd">        &gt;&gt;&gt; pd.Series([&#39;f.o&#39;, &#39;fuz&#39;, np.nan]).str.replace(&#39;f.&#39;, &#39;ba&#39;, regex=False)</span>
<span class="sd">        0    bao</span>
<span class="sd">        1    fuz</span>
<span class="sd">        2    NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        When `repl` is a callable, it is called on every `pat` using</span>
<span class="sd">        :func:`re.sub`. The callable should expect one positional argument</span>
<span class="sd">        (a regex object) and return a string.</span>

<span class="sd">        To get the idea:</span>

<span class="sd">        &gt;&gt;&gt; pd.Series([&#39;foo&#39;, &#39;fuz&#39;, np.nan]).str.replace(&#39;f&#39;, repr, regex=True)</span>
<span class="sd">        0    &lt;re.Match object; span=(0, 1), match=&#39;f&#39;&gt;oo</span>
<span class="sd">        1    &lt;re.Match object; span=(0, 1), match=&#39;f&#39;&gt;uz</span>
<span class="sd">        2                                            NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Reverse every lowercase alphabetic word:</span>

<span class="sd">        &gt;&gt;&gt; repl = lambda m: m.group(0)[::-1]</span>
<span class="sd">        &gt;&gt;&gt; ser = pd.Series([&#39;foo 123&#39;, &#39;bar baz&#39;, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; ser.str.replace(r&#39;[a-z]+&#39;, repl, regex=True)</span>
<span class="sd">        0    oof 123</span>
<span class="sd">        1    rab zab</span>
<span class="sd">        2        NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Using regex groups (extract second group and swap case):</span>

<span class="sd">        &gt;&gt;&gt; pat = r&quot;(?P&lt;one&gt;\w+) (?P&lt;two&gt;\w+) (?P&lt;three&gt;\w+)&quot;</span>
<span class="sd">        &gt;&gt;&gt; repl = lambda m: m.group(&#39;two&#39;).swapcase()</span>
<span class="sd">        &gt;&gt;&gt; ser = pd.Series([&#39;One Two Three&#39;, &#39;Foo Bar Baz&#39;])</span>
<span class="sd">        &gt;&gt;&gt; ser.str.replace(pat, repl, regex=True)</span>
<span class="sd">        0    tWO</span>
<span class="sd">        1    bAR</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Using a compiled regex with flags</span>

<span class="sd">        &gt;&gt;&gt; import re</span>
<span class="sd">        &gt;&gt;&gt; regex_pat = re.compile(r&#39;FUZ&#39;, flags=re.IGNORECASE)</span>
<span class="sd">        &gt;&gt;&gt; pd.Series([&#39;foo&#39;, &#39;fuz&#39;, np.nan]).str.replace(regex_pat, &#39;bar&#39;, regex=True)</span>
<span class="sd">        0    foo</span>
<span class="sd">        1    bar</span>
<span class="sd">        2    NaN</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check whether repl is valid (GH 13438, GH 15055)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">repl</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">callable</span><span class="p">(</span><span class="n">repl</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;repl must be a string or callable&quot;</span><span class="p">)</span>

        <span class="n">is_compiled_re</span> <span class="o">=</span> <span class="n">is_re</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">regex</span> <span class="ow">or</span> <span class="n">regex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_compiled_re</span> <span class="ow">and</span> <span class="p">(</span><span class="n">case</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">flags</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;case and flags cannot be set when pat is a compiled regex&quot;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_compiled_re</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use a compiled regex as replacement pattern with regex=False&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">repl</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use a callable replacement when regex=False&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">case</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">case</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_replace</span><span class="p">(</span>
            <span class="n">pat</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="n">case</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Duplicate each string in the Series or Index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        repeats : int or sequence of int</span>
<span class="sd">            Same value for all (int) or different value per (sequence).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or pandas.Index</span>
<span class="sd">            Series or Index of repeated string objects specified by</span>
<span class="sd">            input parameter repeats.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    a</span>
<span class="sd">        1    b</span>
<span class="sd">        2    c</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Single int repeats string in Series</span>

<span class="sd">        &gt;&gt;&gt; s.str.repeat(repeats=2)</span>
<span class="sd">        0    aa</span>
<span class="sd">        1    bb</span>
<span class="sd">        2    cc</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Sequence of int repeats corresponding string in Series</span>

<span class="sd">        &gt;&gt;&gt; s.str.repeat(repeats=[1, 2, 3])</span>
<span class="sd">        0      a</span>
<span class="sd">        1     bb</span>
<span class="sd">        2    ccc</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_repeat</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">width</span><span class="p">,</span>
        <span class="n">side</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">fillchar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pad strings in the Series/Index up to width.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        width : int</span>
<span class="sd">            Minimum width of resulting string; additional characters will be filled</span>
<span class="sd">            with character defined in `fillchar`.</span>
<span class="sd">        side : {&#39;left&#39;, &#39;right&#39;, &#39;both&#39;}, default &#39;left&#39;</span>
<span class="sd">            Side from which to fill resulting string.</span>
<span class="sd">        fillchar : str, default &#39; &#39;</span>
<span class="sd">            Additional character for filling, default is whitespace.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index of object</span>
<span class="sd">            Returns Series or Index with minimum number of char in object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.str.rjust : Fills the left side of strings with an arbitrary</span>
<span class="sd">            character. Equivalent to ``Series.str.pad(side=&#39;left&#39;)``.</span>
<span class="sd">        Series.str.ljust : Fills the right side of strings with an arbitrary</span>
<span class="sd">            character. Equivalent to ``Series.str.pad(side=&#39;right&#39;)``.</span>
<span class="sd">        Series.str.center : Fills both sides of strings with an arbitrary</span>
<span class="sd">            character. Equivalent to ``Series.str.pad(side=&#39;both&#39;)``.</span>
<span class="sd">        Series.str.zfill : Pad strings in the Series/Index by prepending &#39;0&#39;</span>
<span class="sd">            character. Equivalent to ``Series.str.pad(side=&#39;left&#39;, fillchar=&#39;0&#39;)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&quot;caribou&quot;, &quot;tiger&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    caribou</span>
<span class="sd">        1      tiger</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.pad(width=10)</span>
<span class="sd">        0       caribou</span>
<span class="sd">        1         tiger</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.pad(width=10, side=&#39;right&#39;, fillchar=&#39;-&#39;)</span>
<span class="sd">        0    caribou---</span>
<span class="sd">        1    tiger-----</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.pad(width=10, side=&#39;both&#39;, fillchar=&#39;-&#39;)</span>
<span class="sd">        0    -caribou--</span>
<span class="sd">        1    --tiger---</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fillchar</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;fillchar must be a character, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">fillchar</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fillchar</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fillchar must be a character, not str&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;width must be of integer type, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">width</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_pad</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="n">fillchar</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;str_pad&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Pad </span><span class="si">%(side)s</span><span class="s2"> side of strings in the Series/Index.</span>

<span class="s2">    Equivalent to :meth:`str.</span><span class="si">%(method)s</span><span class="s2">`.</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    width : int</span>
<span class="s2">        Minimum width of resulting string; additional characters will be filled</span>
<span class="s2">        with ``fillchar``.</span>
<span class="s2">    fillchar : str</span>
<span class="s2">        Additional character for filling, default is whitespace.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    Series/Index of objects.</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_pad&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;left and right&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;center&quot;</span><span class="p">})</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">fillchar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="n">fillchar</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_pad&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;ljust&quot;</span><span class="p">})</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">ljust</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">fillchar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="n">fillchar</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_pad&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;rjust&quot;</span><span class="p">})</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">rjust</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">fillchar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="n">fillchar</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">zfill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pad strings in the Series/Index by prepending &#39;0&#39; characters.</span>

<span class="sd">        Strings in the Series/Index are padded with &#39;0&#39; characters on the</span>
<span class="sd">        left of the string to reach a total string length  `width`. Strings</span>
<span class="sd">        in the Series/Index with length greater or equal to `width` are</span>
<span class="sd">        unchanged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        width : int</span>
<span class="sd">            Minimum length of resulting string; strings with length less</span>
<span class="sd">            than `width` be prepended with &#39;0&#39; characters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series/Index of objects.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.str.rjust : Fills the left side of strings with an arbitrary</span>
<span class="sd">            character.</span>
<span class="sd">        Series.str.ljust : Fills the right side of strings with an arbitrary</span>
<span class="sd">            character.</span>
<span class="sd">        Series.str.pad : Fills the specified sides of strings with an arbitrary</span>
<span class="sd">            character.</span>
<span class="sd">        Series.str.center : Fills both sides of strings with an arbitrary</span>
<span class="sd">            character.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Differs from :meth:`str.zfill` which has special handling</span>
<span class="sd">        for &#39;+&#39;/&#39;-&#39; in the string.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;-1&#39;, &#39;1&#39;, &#39;1000&#39;, 10, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0      -1</span>
<span class="sd">        1       1</span>
<span class="sd">        2    1000</span>
<span class="sd">        3      10</span>
<span class="sd">        4     NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Note that ``10`` and ``NaN`` are not strings, therefore they are</span>
<span class="sd">        converted to ``NaN``. The minus sign in ``&#39;-1&#39;`` is treated as a</span>
<span class="sd">        special character and the zero is added to the right of it</span>
<span class="sd">        (:meth:`str.zfill` would have moved it to the left). ``1000``</span>
<span class="sd">        remains unchanged as it is longer than `width`.</span>

<span class="sd">        &gt;&gt;&gt; s.str.zfill(3)</span>
<span class="sd">        0     -01</span>
<span class="sd">        1     001</span>
<span class="sd">        2    1000</span>
<span class="sd">        3     NaN</span>
<span class="sd">        4     NaN</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;width must be of integer type, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">width</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slice substrings from each element in the Series or Index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Start position for slice operation.</span>
<span class="sd">        stop : int, optional</span>
<span class="sd">            Stop position for slice operation.</span>
<span class="sd">        step : int, optional</span>
<span class="sd">            Step size for slice operation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index of object</span>
<span class="sd">            Series or Index from sliced substring from original string object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.str.slice_replace : Replace a slice with a string.</span>
<span class="sd">        Series.str.get : Return element at position.</span>
<span class="sd">            Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`</span>
<span class="sd">            being the position.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&quot;koala&quot;, &quot;dog&quot;, &quot;chameleon&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0        koala</span>
<span class="sd">        1          dog</span>
<span class="sd">        2    chameleon</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.slice(start=1)</span>
<span class="sd">        0        oala</span>
<span class="sd">        1          og</span>
<span class="sd">        2    hameleon</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.slice(start=-1)</span>
<span class="sd">        0           a</span>
<span class="sd">        1           g</span>
<span class="sd">        2           n</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.slice(stop=2)</span>
<span class="sd">        0    ko</span>
<span class="sd">        1    do</span>
<span class="sd">        2    ch</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.slice(step=2)</span>
<span class="sd">        0      kaa</span>
<span class="sd">        1       dg</span>
<span class="sd">        2    caeen</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.slice(start=0, stop=5, step=3)</span>
<span class="sd">        0    kl</span>
<span class="sd">        1     d</span>
<span class="sd">        2    cm</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Equivalent behaviour to:</span>

<span class="sd">        &gt;&gt;&gt; s.str[0:5:3]</span>
<span class="sd">        0    kl</span>
<span class="sd">        1     d</span>
<span class="sd">        2    cm</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">slice_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repl</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace a positional slice of a string with another value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Left index position to use for the slice. If not specified (None),</span>
<span class="sd">            the slice is unbounded on the left, i.e. slice from the start</span>
<span class="sd">            of the string.</span>
<span class="sd">        stop : int, optional</span>
<span class="sd">            Right index position to use for the slice. If not specified (None),</span>
<span class="sd">            the slice is unbounded on the right, i.e. slice until the</span>
<span class="sd">            end of the string.</span>
<span class="sd">        repl : str, optional</span>
<span class="sd">            String for replacement. If not specified (None), the sliced region</span>
<span class="sd">            is replaced with an empty string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index</span>
<span class="sd">            Same type as the original object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.str.slice : Just slicing without replacement.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;ab&#39;, &#39;abc&#39;, &#39;abdc&#39;, &#39;abcde&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0        a</span>
<span class="sd">        1       ab</span>
<span class="sd">        2      abc</span>
<span class="sd">        3     abdc</span>
<span class="sd">        4    abcde</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Specify just `start`, meaning replace `start` until the end of the</span>
<span class="sd">        string with `repl`.</span>

<span class="sd">        &gt;&gt;&gt; s.str.slice_replace(1, repl=&#39;X&#39;)</span>
<span class="sd">        0    aX</span>
<span class="sd">        1    aX</span>
<span class="sd">        2    aX</span>
<span class="sd">        3    aX</span>
<span class="sd">        4    aX</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Specify just `stop`, meaning the start of the string to `stop` is replaced</span>
<span class="sd">        with `repl`, and the rest of the string is included.</span>

<span class="sd">        &gt;&gt;&gt; s.str.slice_replace(stop=2, repl=&#39;X&#39;)</span>
<span class="sd">        0       X</span>
<span class="sd">        1       X</span>
<span class="sd">        2      Xc</span>
<span class="sd">        3     Xdc</span>
<span class="sd">        4    Xcde</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Specify `start` and `stop`, meaning the slice from `start` to `stop` is</span>
<span class="sd">        replaced with `repl`. Everything before or after `start` and `stop` is</span>
<span class="sd">        included as is.</span>

<span class="sd">        &gt;&gt;&gt; s.str.slice_replace(start=1, stop=3, repl=&#39;X&#39;)</span>
<span class="sd">        0      aX</span>
<span class="sd">        1      aX</span>
<span class="sd">        2      aX</span>
<span class="sd">        3     aXc</span>
<span class="sd">        4    aXde</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_slice_replace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;strict&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decode character string in the Series/Index using indicated encoding.</span>

<span class="sd">        Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in</span>
<span class="sd">        python3.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        encoding : str</span>
<span class="sd">        errors : str, optional</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add a similar _bytes interface.</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">_cpython_optimized_decoders</span><span class="p">:</span>
            <span class="c1"># CPython optimized implementation</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">decoder</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getdecoder</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">decoder</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">errors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span>
        <span class="c1"># assert isinstance(arr, (StringArray,))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">_str_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;strict&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encode character string in the Series/Index using indicated encoding.</span>

<span class="sd">        Equivalent to :meth:`str.encode`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        encoding : str</span>
<span class="sd">        errors : str, optional</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series/Index of objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;str_strip&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Remove </span><span class="si">%(position)s</span><span class="s2"> characters.</span>

<span class="s2">    Strip whitespaces (including newlines) or a set of specified characters</span>
<span class="s2">    from each string in the Series/Index from </span><span class="si">%(side)s</span><span class="s2">.</span>
<span class="s2">    Replaces any non-strings in Series with NaNs.</span>
<span class="s2">    Equivalent to :meth:`str.</span><span class="si">%(method)s</span><span class="s2">`.</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    to_strip : str or None, default None</span>
<span class="s2">        Specifying the set of characters to be removed.</span>
<span class="s2">        All combinations of this set of characters will be stripped.</span>
<span class="s2">        If None then whitespaces are removed.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    Series or Index of object</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    Series.str.strip : Remove leading and trailing characters in Series/Index.</span>
<span class="s2">    Series.str.lstrip : Remove leading characters in Series/Index.</span>
<span class="s2">    Series.str.rstrip : Remove trailing characters in Series/Index.</span>

<span class="s2">    Examples</span>
<span class="s2">    --------</span>
<span class="s2">    &gt;&gt;&gt; s = pd.Series([&#39;1. Ant.  &#39;, &#39;2. Bee!\n&#39;, &#39;3. Cat?\t&#39;, np.nan, 10, True])</span>
<span class="s2">    &gt;&gt;&gt; s</span>
<span class="s2">    0    1. Ant.</span>
<span class="s2">    1    2. Bee!\n</span>
<span class="s2">    2    3. Cat?\t</span>
<span class="s2">    3          NaN</span>
<span class="s2">    4           10</span>
<span class="s2">    5         True</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.strip()</span>
<span class="s2">    0    1. Ant.</span>
<span class="s2">    1    2. Bee!</span>
<span class="s2">    2    3. Cat?</span>
<span class="s2">    3        NaN</span>
<span class="s2">    4        NaN</span>
<span class="s2">    5        NaN</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.lstrip(&#39;123.&#39;)</span>
<span class="s2">    0    Ant.</span>
<span class="s2">    1    Bee!\n</span>
<span class="s2">    2    Cat?\t</span>
<span class="s2">    3       NaN</span>
<span class="s2">    4       NaN</span>
<span class="s2">    5       NaN</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.rstrip(&#39;.!? \n\t&#39;)</span>
<span class="s2">    0    1. Ant</span>
<span class="s2">    1    2. Bee</span>
<span class="s2">    2    3. Cat</span>
<span class="s2">    3       NaN</span>
<span class="s2">    4       NaN</span>
<span class="s2">    5       NaN</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.strip(&#39;123.!? \n\t&#39;)</span>
<span class="s2">    0    Ant</span>
<span class="s2">    1    Bee</span>
<span class="s2">    2    Cat</span>
<span class="s2">    3    NaN</span>
<span class="s2">    4    NaN</span>
<span class="s2">    5    NaN</span>
<span class="s2">    dtype: object</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_strip&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;left and right sides&quot;</span><span class="p">,</span>
            <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;strip&quot;</span><span class="p">,</span>
            <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="s2">&quot;leading and trailing&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_strip</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_strip</span><span class="p">(</span><span class="n">to_strip</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_strip&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;left side&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;lstrip&quot;</span><span class="p">,</span> <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">lstrip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_strip</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_lstrip</span><span class="p">(</span><span class="n">to_strip</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_strip&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;right side&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;rstrip&quot;</span><span class="p">,</span> <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">rstrip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_strip</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_rstrip</span><span class="p">(</span><span class="n">to_strip</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;str_removefix&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Remove a </span><span class="si">%(side)s</span><span class="s2"> from an object series.</span>

<span class="s2">    If the </span><span class="si">%(side)s</span><span class="s2"> is not present, the original string will be returned.</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    </span><span class="si">%(side)s</span><span class="s2"> : str</span>
<span class="s2">        Remove the </span><span class="si">%(side)s</span><span class="s2"> of the string.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    Series/Index: object</span>
<span class="s2">        The Series or Index with given </span><span class="si">%(side)s</span><span class="s2"> removed.</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    Series.str.remove</span><span class="si">%(other_side)s</span><span class="s2"> : Remove a </span><span class="si">%(other_side)s</span><span class="s2"> from an object series.</span>

<span class="s2">    Examples</span>
<span class="s2">    --------</span>
<span class="s2">    &gt;&gt;&gt; s = pd.Series([&quot;str_foo&quot;, &quot;str_bar&quot;, &quot;no_prefix&quot;])</span>
<span class="s2">    &gt;&gt;&gt; s</span>
<span class="s2">    0    str_foo</span>
<span class="s2">    1    str_bar</span>
<span class="s2">    2    no_prefix</span>
<span class="s2">    dtype: object</span>
<span class="s2">    &gt;&gt;&gt; s.str.removeprefix(&quot;str_&quot;)</span>
<span class="s2">    0    foo</span>
<span class="s2">    1    bar</span>
<span class="s2">    2    no_prefix</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s = pd.Series([&quot;foo_str&quot;, &quot;bar_str&quot;, &quot;no_suffix&quot;])</span>
<span class="s2">    &gt;&gt;&gt; s</span>
<span class="s2">    0    foo_str</span>
<span class="s2">    1    bar_str</span>
<span class="s2">    2    no_suffix</span>
<span class="s2">    dtype: object</span>
<span class="s2">    &gt;&gt;&gt; s.str.removesuffix(&quot;_str&quot;)</span>
<span class="s2">    0    foo</span>
<span class="s2">    1    bar</span>
<span class="s2">    2    no_suffix</span>
<span class="s2">    dtype: object</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_removefix&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;prefix&quot;</span><span class="p">,</span> <span class="s2">&quot;other_side&quot;</span><span class="p">:</span> <span class="s2">&quot;suffix&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">removeprefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_removeprefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;str_removefix&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;suffix&quot;</span><span class="p">,</span> <span class="s2">&quot;other_side&quot;</span><span class="p">:</span> <span class="s2">&quot;prefix&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">removesuffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_removesuffix</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap strings in Series/Index at specified line width.</span>

<span class="sd">        This method has the same keyword parameters and defaults as</span>
<span class="sd">        :class:`textwrap.TextWrapper`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        width : int</span>
<span class="sd">            Maximum line width.</span>
<span class="sd">        expand_tabs : bool, optional</span>
<span class="sd">            If True, tab characters will be expanded to spaces (default: True).</span>
<span class="sd">        replace_whitespace : bool, optional</span>
<span class="sd">            If True, each whitespace character (as defined by string.whitespace)</span>
<span class="sd">            remaining after tab expansion will be replaced by a single space</span>
<span class="sd">            (default: True).</span>
<span class="sd">        drop_whitespace : bool, optional</span>
<span class="sd">            If True, whitespace that, after wrapping, happens to end up at the</span>
<span class="sd">            beginning or end of a line is dropped (default: True).</span>
<span class="sd">        break_long_words : bool, optional</span>
<span class="sd">            If True, then words longer than width will be broken in order to ensure</span>
<span class="sd">            that no lines are longer than width. If it is false, long words will</span>
<span class="sd">            not be broken, and some lines may be longer than width (default: True).</span>
<span class="sd">        break_on_hyphens : bool, optional</span>
<span class="sd">            If True, wrapping will occur preferably on whitespace and right after</span>
<span class="sd">            hyphens in compound words, as it is customary in English. If false,</span>
<span class="sd">            only whitespaces will be considered as potentially good places for line</span>
<span class="sd">            breaks, but you need to set break_long_words to false if you want truly</span>
<span class="sd">            insecable words (default: True).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Internally, this method uses a :class:`textwrap.TextWrapper` instance with</span>
<span class="sd">        default settings. To achieve behavior matching R&#39;s stringr library str_wrap</span>
<span class="sd">        function, use the arguments:</span>

<span class="sd">        - expand_tabs = False</span>
<span class="sd">        - replace_whitespace = True</span>
<span class="sd">        - drop_whitespace = True</span>
<span class="sd">        - break_long_words = False</span>
<span class="sd">        - break_on_hyphens = False</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;line to be wrapped&#39;, &#39;another line to be wrapped&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s.str.wrap(12)</span>
<span class="sd">        0             line to be\nwrapped</span>
<span class="sd">        1    another line\nto be\nwrapped</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_wrap</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">get_dummies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return DataFrame of dummy/indicator variables for Series.</span>

<span class="sd">        Each string in Series is split by sep and returned as a DataFrame</span>
<span class="sd">        of dummy/indicator variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sep : str, default &quot;|&quot;</span>
<span class="sd">            String to split on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Dummy variables corresponding to values of the Series.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_dummies : Convert categorical variable into dummy/indicator</span>
<span class="sd">            variables.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pd.Series([&#39;a|b&#39;, &#39;a&#39;, &#39;a|c&#39;]).str.get_dummies()</span>
<span class="sd">           a  b  c</span>
<span class="sd">        0  1  1  0</span>
<span class="sd">        1  1  0  0</span>
<span class="sd">        2  1  0  1</span>

<span class="sd">        &gt;&gt;&gt; pd.Series([&#39;a|b&#39;, np.nan, &#39;a|c&#39;]).str.get_dummies()</span>
<span class="sd">           a  b  c</span>
<span class="sd">        0  1  1  0</span>
<span class="sd">        1  0  0  0</span>
<span class="sd">        2  1  0  1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we need to cast to Series of strings as only that has all</span>
        <span class="c1"># methods available for making the dummies...</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_get_dummies</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span>
            <span class="n">result</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map all characters in the string through the given mapping table.</span>

<span class="sd">        Equivalent to standard :meth:`str.translate`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        table : dict</span>
<span class="sd">            Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or</span>
<span class="sd">            None. Unmapped characters are left untouched.</span>
<span class="sd">            Characters mapped to None are deleted. :meth:`str.maketrans` is a</span>
<span class="sd">            helper function for making translation tables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_translate</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count occurrences of pattern in each string of the Series/Index.</span>

<span class="sd">        This function is used to count the number of times a particular regex</span>
<span class="sd">        pattern is repeated in each of the string elements of the</span>
<span class="sd">        :class:`~pandas.Series`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pat : str</span>
<span class="sd">            Valid regular expression.</span>
<span class="sd">        flags : int, default 0, meaning no flags</span>
<span class="sd">            Flags for the `re` module. For a complete list, `see here</span>
<span class="sd">            &lt;https://docs.python.org/3/howto/regex.html#compilation-flags&gt;`_.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            For compatibility with other string methods. Not used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index</span>
<span class="sd">            Same type as the calling object containing the integer counts.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        re : Standard library module for regular expressions.</span>
<span class="sd">        str.count : Standard library version, without regular expression support.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Some characters need to be escaped when passing in `pat`.</span>
<span class="sd">        eg. ``&#39;$&#39;`` has a special meaning in regex and must be escaped when</span>
<span class="sd">        finding this literal character.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;A&#39;, &#39;B&#39;, &#39;Aaba&#39;, &#39;Baca&#39;, np.nan, &#39;CABA&#39;, &#39;cat&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s.str.count(&#39;a&#39;)</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1    0.0</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    2.0</span>
<span class="sd">        4    NaN</span>
<span class="sd">        5    0.0</span>
<span class="sd">        6    1.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Escape ``&#39;$&#39;`` to find the literal dollar sign.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;$&#39;, &#39;B&#39;, &#39;Aab$&#39;, &#39;$$ca&#39;, &#39;C$B$&#39;, &#39;cat&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s.str.count(&#39;\\$&#39;)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    0</span>
<span class="sd">        2    1</span>
<span class="sd">        3    2</span>
<span class="sd">        4    2</span>
<span class="sd">        5    0</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        This is also available on Index</span>

<span class="sd">        &gt;&gt;&gt; pd.Index([&#39;A&#39;, &#39;A&#39;, &#39;Aaba&#39;, &#39;cat&#39;]).str.count(&#39;a&#39;)</span>
<span class="sd">        Index([0, 0, 2, 1], dtype=&#39;int64&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_count</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">startswith</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">na</span><span class="p">:</span> <span class="n">Scalar</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if the start of each string element matches a pattern.</span>

<span class="sd">        Equivalent to :meth:`str.startswith`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pat : str or tuple[str, ...]</span>
<span class="sd">            Character sequence or tuple of strings. Regular expressions are not</span>
<span class="sd">            accepted.</span>
<span class="sd">        na : object, default NaN</span>
<span class="sd">            Object shown if element tested is not a string. The default depends</span>
<span class="sd">            on dtype of the array. For object-dtype, ``numpy.nan`` is used.</span>
<span class="sd">            For ``StringDtype``, ``pandas.NA`` is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index of bool</span>
<span class="sd">            A Series of booleans indicating whether the given pattern matches</span>
<span class="sd">            the start of each string element.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        str.startswith : Python standard library string method.</span>
<span class="sd">        Series.str.endswith : Same as startswith, but tests the end of string.</span>
<span class="sd">        Series.str.contains : Tests if string element contains a pattern.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;bat&#39;, &#39;Bear&#39;, &#39;cat&#39;, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0     bat</span>
<span class="sd">        1    Bear</span>
<span class="sd">        2     cat</span>
<span class="sd">        3     NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.startswith(&#39;b&#39;)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3      NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.startswith((&#39;b&#39;, &#39;B&#39;))</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3      NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Specifying `na` to be `False` instead of `NaN`.</span>

<span class="sd">        &gt;&gt;&gt; s.str.startswith(&#39;b&#39;, na=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;expected a string or tuple, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_startswith</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="n">na</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">endswith</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">na</span><span class="p">:</span> <span class="n">Scalar</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if the end of each string element matches a pattern.</span>

<span class="sd">        Equivalent to :meth:`str.endswith`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pat : str or tuple[str, ...]</span>
<span class="sd">            Character sequence or tuple of strings. Regular expressions are not</span>
<span class="sd">            accepted.</span>
<span class="sd">        na : object, default NaN</span>
<span class="sd">            Object shown if element tested is not a string. The default depends</span>
<span class="sd">            on dtype of the array. For object-dtype, ``numpy.nan`` is used.</span>
<span class="sd">            For ``StringDtype``, ``pandas.NA`` is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index of bool</span>
<span class="sd">            A Series of booleans indicating whether the given pattern matches</span>
<span class="sd">            the end of each string element.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        str.endswith : Python standard library string method.</span>
<span class="sd">        Series.str.startswith : Same as endswith, but tests the start of string.</span>
<span class="sd">        Series.str.contains : Tests if string element contains a pattern.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;bat&#39;, &#39;bear&#39;, &#39;caT&#39;, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0     bat</span>
<span class="sd">        1    bear</span>
<span class="sd">        2     caT</span>
<span class="sd">        3     NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.endswith(&#39;t&#39;)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3      NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.str.endswith((&#39;t&#39;, &#39;T&#39;))</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3      NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Specifying `na` to be `False` instead of `NaN`.</span>

<span class="sd">        &gt;&gt;&gt; s.str.endswith(&#39;t&#39;, na=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;expected a string or tuple, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_endswith</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="n">na</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">findall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all occurrences of pattern or regular expression in the Series/Index.</span>

<span class="sd">        Equivalent to applying :func:`re.findall` to all the elements in the</span>
<span class="sd">        Series/Index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pat : str</span>
<span class="sd">            Pattern or regular expression.</span>
<span class="sd">        flags : int, default 0</span>
<span class="sd">            Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which</span>
<span class="sd">            means no flags).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series/Index of lists of strings</span>
<span class="sd">            All non-overlapping matches of pattern or regular expression in each</span>
<span class="sd">            string of this Series/Index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        count : Count occurrences of pattern or regular expression in each string</span>
<span class="sd">            of the Series/Index.</span>
<span class="sd">        extractall : For each string in the Series, extract groups from all matches</span>
<span class="sd">            of regular expression and return a DataFrame with one row for each</span>
<span class="sd">            match and one column for each group.</span>
<span class="sd">        re.findall : The equivalent ``re`` function to all non-overlapping matches</span>
<span class="sd">            of pattern or regular expression in string, as a list of strings.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;Lion&#39;, &#39;Monkey&#39;, &#39;Rabbit&#39;])</span>

<span class="sd">        The search for the pattern &#39;Monkey&#39; returns one match:</span>

<span class="sd">        &gt;&gt;&gt; s.str.findall(&#39;Monkey&#39;)</span>
<span class="sd">        0          []</span>
<span class="sd">        1    [Monkey]</span>
<span class="sd">        2          []</span>
<span class="sd">        dtype: object</span>

<span class="sd">        On the other hand, the search for the pattern &#39;MONKEY&#39; doesn&#39;t return any</span>
<span class="sd">        match:</span>

<span class="sd">        &gt;&gt;&gt; s.str.findall(&#39;MONKEY&#39;)</span>
<span class="sd">        0    []</span>
<span class="sd">        1    []</span>
<span class="sd">        2    []</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Flags can be added to the pattern or regular expression. For instance,</span>
<span class="sd">        to find the pattern &#39;MONKEY&#39; ignoring the case:</span>

<span class="sd">        &gt;&gt;&gt; import re</span>
<span class="sd">        &gt;&gt;&gt; s.str.findall(&#39;MONKEY&#39;, flags=re.IGNORECASE)</span>
<span class="sd">        0          []</span>
<span class="sd">        1    [Monkey]</span>
<span class="sd">        2          []</span>
<span class="sd">        dtype: object</span>

<span class="sd">        When the pattern matches more than one string in the Series, all matches</span>
<span class="sd">        are returned:</span>

<span class="sd">        &gt;&gt;&gt; s.str.findall(&#39;on&#39;)</span>
<span class="sd">        0    [on]</span>
<span class="sd">        1    [on]</span>
<span class="sd">        2      []</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Regular expressions are supported too. For instance, the search for all the</span>
<span class="sd">        strings ending with the word &#39;on&#39; is shown next:</span>

<span class="sd">        &gt;&gt;&gt; s.str.findall(&#39;on$&#39;)</span>
<span class="sd">        0    [on]</span>
<span class="sd">        1      []</span>
<span class="sd">        2      []</span>
<span class="sd">        dtype: object</span>

<span class="sd">        If the pattern is found more than once in the same string, then a list of</span>
<span class="sd">        multiple strings is returned:</span>

<span class="sd">        &gt;&gt;&gt; s.str.findall(&#39;b&#39;)</span>
<span class="sd">        0        []</span>
<span class="sd">        1        []</span>
<span class="sd">        2    [b, b]</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_findall</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">expand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract capture groups in the regex `pat` as columns in a DataFrame.</span>

<span class="sd">        For each subject string in the Series, extract groups from the</span>
<span class="sd">        first match of regular expression `pat`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pat : str</span>
<span class="sd">            Regular expression pattern with capturing groups.</span>
<span class="sd">        flags : int, default 0 (no flags)</span>
<span class="sd">            Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that</span>
<span class="sd">            modify regular expression matching for things like case,</span>
<span class="sd">            spaces, etc. For more details, see :mod:`re`.</span>
<span class="sd">        expand : bool, default True</span>
<span class="sd">            If True, return DataFrame with one column per capture group.</span>
<span class="sd">            If False, return a Series/Index if there is one capture group</span>
<span class="sd">            or DataFrame if there are multiple capture groups.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or Series or Index</span>
<span class="sd">            A DataFrame with one row for each subject string, and one</span>
<span class="sd">            column for each group. Any capture group names in regular</span>
<span class="sd">            expression pat will be used for column names; otherwise</span>
<span class="sd">            capture group numbers will be used. The dtype of each result</span>
<span class="sd">            column is always object, even when no match is found. If</span>
<span class="sd">            ``expand=False`` and pat has only one capture group, then</span>
<span class="sd">            return a Series (if subject is a Series) or Index (if subject</span>
<span class="sd">            is an Index).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        extractall : Returns all matches (not just the first match).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        A pattern with two groups will return a DataFrame with two columns.</span>
<span class="sd">        Non-matches will be NaN.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;a1&#39;, &#39;b2&#39;, &#39;c3&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s.str.extract(r&#39;([ab])(\d)&#39;)</span>
<span class="sd">            0    1</span>
<span class="sd">        0    a    1</span>
<span class="sd">        1    b    2</span>
<span class="sd">        2  NaN  NaN</span>

<span class="sd">        A pattern may contain optional groups.</span>

<span class="sd">        &gt;&gt;&gt; s.str.extract(r&#39;([ab])?(\d)&#39;)</span>
<span class="sd">            0  1</span>
<span class="sd">        0    a  1</span>
<span class="sd">        1    b  2</span>
<span class="sd">        2  NaN  3</span>

<span class="sd">        Named groups will become column names in the result.</span>

<span class="sd">        &gt;&gt;&gt; s.str.extract(r&#39;(?P&lt;letter&gt;[ab])(?P&lt;digit&gt;\d)&#39;)</span>
<span class="sd">        letter digit</span>
<span class="sd">        0      a     1</span>
<span class="sd">        1      b     2</span>
<span class="sd">        2    NaN   NaN</span>

<span class="sd">        A pattern with one group will return a DataFrame with one column</span>
<span class="sd">        if expand=True.</span>

<span class="sd">        &gt;&gt;&gt; s.str.extract(r&#39;[ab](\d)&#39;, expand=True)</span>
<span class="sd">            0</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2  NaN</span>

<span class="sd">        A pattern with one group will return a Series if expand=False.</span>

<span class="sd">        &gt;&gt;&gt; s.str.extract(r&#39;[ab](\d)&#39;, expand=False)</span>
<span class="sd">        0      1</span>
<span class="sd">        1      2</span>
<span class="sd">        2    NaN</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expand</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expand must be True or False&quot;</span><span class="p">)</span>

        <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">regex</span><span class="o">.</span><span class="n">groups</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pattern contains no capture groups&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">expand</span> <span class="ow">and</span> <span class="n">regex</span><span class="o">.</span><span class="n">groups</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only one regex group is supported with Index&quot;</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">result_dtype</span> <span class="o">=</span> <span class="n">_result_dtype</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="n">returns_df</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">groups</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">expand</span>

        <span class="k">if</span> <span class="n">returns_df</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">_get_group_names</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_dtype</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">result_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_extract</span><span class="p">(</span>
                    <span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="n">returns_df</span>
                <span class="p">)</span>

                <span class="n">result_index</span><span class="p">:</span> <span class="n">Index</span> <span class="o">|</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
                    <span class="n">result_index</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">index</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_index</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">result</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">result_list</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">result_index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_dtype</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">_get_single_group_name</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_extract</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="n">returns_df</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">extractall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract capture groups in the regex `pat` as columns in DataFrame.</span>

<span class="sd">        For each subject string in the Series, extract groups from all</span>
<span class="sd">        matches of regular expression pat. When each subject string in the</span>
<span class="sd">        Series has exactly one match, extractall(pat).xs(0, level=&#39;match&#39;)</span>
<span class="sd">        is the same as extract(pat).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pat : str</span>
<span class="sd">            Regular expression pattern with capturing groups.</span>
<span class="sd">        flags : int, default 0 (no flags)</span>
<span class="sd">            A ``re`` module flag, for example ``re.IGNORECASE``. These allow</span>
<span class="sd">            to modify regular expression matching for things like case, spaces,</span>
<span class="sd">            etc. Multiple flags can be combined with the bitwise OR operator,</span>
<span class="sd">            for example ``re.IGNORECASE | re.MULTILINE``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A ``DataFrame`` with one row for each match, and one column for each</span>
<span class="sd">            group. Its rows have a ``MultiIndex`` with first levels that come from</span>
<span class="sd">            the subject ``Series``. The last level is named &#39;match&#39; and indexes the</span>
<span class="sd">            matches in each item of the ``Series``. Any capture group names in</span>
<span class="sd">            regular expression pat will be used for column names; otherwise capture</span>
<span class="sd">            group numbers will be used.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        extract : Returns first match only (not all matches).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        A pattern with one group will return a DataFrame with one column.</span>
<span class="sd">        Indices with no matches will not appear in the result.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&quot;a1a2&quot;, &quot;b1&quot;, &quot;c1&quot;], index=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.str.extractall(r&quot;[ab](\d)&quot;)</span>
<span class="sd">                0</span>
<span class="sd">        match</span>
<span class="sd">        A 0      1</span>
<span class="sd">          1      2</span>
<span class="sd">        B 0      1</span>

<span class="sd">        Capture group names are used for column names of the result.</span>

<span class="sd">        &gt;&gt;&gt; s.str.extractall(r&quot;[ab](?P&lt;digit&gt;\d)&quot;)</span>
<span class="sd">                digit</span>
<span class="sd">        match</span>
<span class="sd">        A 0         1</span>
<span class="sd">          1         2</span>
<span class="sd">        B 0         1</span>

<span class="sd">        A pattern with two groups will return a DataFrame with two columns.</span>

<span class="sd">        &gt;&gt;&gt; s.str.extractall(r&quot;(?P&lt;letter&gt;[ab])(?P&lt;digit&gt;\d)&quot;)</span>
<span class="sd">                letter digit</span>
<span class="sd">        match</span>
<span class="sd">        A 0          a     1</span>
<span class="sd">          1          a     2</span>
<span class="sd">        B 0          b     1</span>

<span class="sd">        Optional groups that do not match are NaN in the result.</span>

<span class="sd">        &gt;&gt;&gt; s.str.extractall(r&quot;(?P&lt;letter&gt;[ab])?(?P&lt;digit&gt;\d)&quot;)</span>
<span class="sd">                letter digit</span>
<span class="sd">        match</span>
<span class="sd">        A 0          a     1</span>
<span class="sd">          1          a     2</span>
<span class="sd">        B 0          b     1</span>
<span class="sd">        C 0        NaN     1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: dispatch</span>
        <span class="k">return</span> <span class="n">str_extractall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;find&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Return </span><span class="si">%(side)s</span><span class="s2"> indexes in each strings in the Series/Index.</span>

<span class="s2">    Each of returned indexes corresponds to the position where the</span>
<span class="s2">    substring is fully contained between [start:end]. Return -1 on</span>
<span class="s2">    failure. Equivalent to standard :meth:`str.</span><span class="si">%(method)s</span><span class="s2">`.</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    sub : str</span>
<span class="s2">        Substring being searched.</span>
<span class="s2">    start : int</span>
<span class="s2">        Left edge index.</span>
<span class="s2">    end : int</span>
<span class="s2">        Right edge index.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    Series or Index of int.</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    </span><span class="si">%(also)s</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;find&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;lowest&quot;</span><span class="p">,</span>
            <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;find&quot;</span><span class="p">,</span>
            <span class="s2">&quot;also&quot;</span><span class="p">:</span> <span class="s2">&quot;rfind : Return highest indexes in each strings.&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;expected a string object, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_find</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;find&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;highest&quot;</span><span class="p">,</span>
            <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;rfind&quot;</span><span class="p">,</span>
            <span class="s2">&quot;also&quot;</span><span class="p">:</span> <span class="s2">&quot;find : Return lowest indexes in each strings.&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">rfind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;expected a string object, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_rfind</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Unicode normal form for the strings in the Series/Index.</span>

<span class="sd">        For more information on the forms, see the</span>
<span class="sd">        :func:`unicodedata.normalize`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        form : {&#39;NFC&#39;, &#39;NFKC&#39;, &#39;NFD&#39;, &#39;NFKD&#39;}</span>
<span class="sd">            Unicode form.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series/Index of objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_normalize</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;index&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Return </span><span class="si">%(side)s</span><span class="s2"> indexes in each string in Series/Index.</span>

<span class="s2">    Each of the returned indexes corresponds to the position where the</span>
<span class="s2">    substring is fully contained between [start:end]. This is the same</span>
<span class="s2">    as ``str.</span><span class="si">%(similar)s</span><span class="s2">`` except instead of returning -1, it raises a</span>
<span class="s2">    ValueError when the substring is not found. Equivalent to standard</span>
<span class="s2">    ``str.</span><span class="si">%(method)s</span><span class="s2">``.</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    sub : str</span>
<span class="s2">        Substring being searched.</span>
<span class="s2">    start : int</span>
<span class="s2">        Left edge index.</span>
<span class="s2">    end : int</span>
<span class="s2">        Right edge index.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    Series or Index of object</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    </span><span class="si">%(also)s</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;lowest&quot;</span><span class="p">,</span>
            <span class="s2">&quot;similar&quot;</span><span class="p">:</span> <span class="s2">&quot;find&quot;</span><span class="p">,</span>
            <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;index&quot;</span><span class="p">,</span>
            <span class="s2">&quot;also&quot;</span><span class="p">:</span> <span class="s2">&quot;rindex : Return highest indexes in each strings.&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;expected a string object, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_index</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="s2">&quot;highest&quot;</span><span class="p">,</span>
            <span class="s2">&quot;similar&quot;</span><span class="p">:</span> <span class="s2">&quot;rfind&quot;</span><span class="p">,</span>
            <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;rindex&quot;</span><span class="p">,</span>
            <span class="s2">&quot;also&quot;</span><span class="p">:</span> <span class="s2">&quot;index : Return lowest indexes in each strings.&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">rindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;expected a string object, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_rindex</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the length of each element in the Series/Index.</span>

<span class="sd">        The element may be a sequence (such as a string, tuple or list) or a collection</span>
<span class="sd">        (such as a dictionary).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index of int</span>
<span class="sd">            A Series or Index of integer values indicating the length of each</span>
<span class="sd">            element in the Series or Index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        str.len : Python built-in function returning the length of an object.</span>
<span class="sd">        Series.size : Returns the length of the Series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Returns the length (number of characters) in a string. Returns the</span>
<span class="sd">        number of entries for dictionaries, lists or tuples.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;dog&#39;,</span>
<span class="sd">        ...                 &#39;&#39;,</span>
<span class="sd">        ...                 5,</span>
<span class="sd">        ...                 {&#39;foo&#39; : &#39;bar&#39;},</span>
<span class="sd">        ...                 [2, 3, 5, 7],</span>
<span class="sd">        ...                 (&#39;one&#39;, &#39;two&#39;, &#39;three&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0                  dog</span>
<span class="sd">        1</span>
<span class="sd">        2                    5</span>
<span class="sd">        3       {&#39;foo&#39;: &#39;bar&#39;}</span>
<span class="sd">        4         [2, 3, 5, 7]</span>
<span class="sd">        5    (one, two, three)</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; s.str.len()</span>
<span class="sd">        0    3.0</span>
<span class="sd">        1    0.0</span>
<span class="sd">        2    NaN</span>
<span class="sd">        3    1.0</span>
<span class="sd">        4    4.0</span>
<span class="sd">        5    3.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_len</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">returns_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;casemethods&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Convert strings in the Series/Index to </span><span class="si">%(type)s</span><span class="s2">.</span>
<span class="s2">    </span><span class="si">%(version)s</span>
<span class="s2">    Equivalent to :meth:`str.</span><span class="si">%(method)s</span><span class="s2">`.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    Series or Index of object</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    Series.str.lower : Converts all characters to lowercase.</span>
<span class="s2">    Series.str.upper : Converts all characters to uppercase.</span>
<span class="s2">    Series.str.title : Converts first character of each word to uppercase and</span>
<span class="s2">        remaining to lowercase.</span>
<span class="s2">    Series.str.capitalize : Converts first character to uppercase and</span>
<span class="s2">        remaining to lowercase.</span>
<span class="s2">    Series.str.swapcase : Converts uppercase to lowercase and lowercase to</span>
<span class="s2">        uppercase.</span>
<span class="s2">    Series.str.casefold: Removes all case distinctions in the string.</span>

<span class="s2">    Examples</span>
<span class="s2">    --------</span>
<span class="s2">    &gt;&gt;&gt; s = pd.Series([&#39;lower&#39;, &#39;CAPITALS&#39;, &#39;this is a sentence&#39;, &#39;SwApCaSe&#39;])</span>
<span class="s2">    &gt;&gt;&gt; s</span>
<span class="s2">    0                 lower</span>
<span class="s2">    1              CAPITALS</span>
<span class="s2">    2    this is a sentence</span>
<span class="s2">    3              SwApCaSe</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.lower()</span>
<span class="s2">    0                 lower</span>
<span class="s2">    1              capitals</span>
<span class="s2">    2    this is a sentence</span>
<span class="s2">    3              swapcase</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.upper()</span>
<span class="s2">    0                 LOWER</span>
<span class="s2">    1              CAPITALS</span>
<span class="s2">    2    THIS IS A SENTENCE</span>
<span class="s2">    3              SWAPCASE</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.title()</span>
<span class="s2">    0                 Lower</span>
<span class="s2">    1              Capitals</span>
<span class="s2">    2    This Is A Sentence</span>
<span class="s2">    3              Swapcase</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.capitalize()</span>
<span class="s2">    0                 Lower</span>
<span class="s2">    1              Capitals</span>
<span class="s2">    2    This is a sentence</span>
<span class="s2">    3              Swapcase</span>
<span class="s2">    dtype: object</span>

<span class="s2">    &gt;&gt;&gt; s.str.swapcase()</span>
<span class="s2">    0                 LOWER</span>
<span class="s2">    1              capitals</span>
<span class="s2">    2    THIS IS A SENTENCE</span>
<span class="s2">    3              sWaPcAsE</span>
<span class="s2">    dtype: object</span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="c1"># Types:</span>
    <span class="c1">#   cases:</span>
    <span class="c1">#       upper, lower, title, capitalize, swapcase, casefold</span>
    <span class="c1">#   boolean:</span>
    <span class="c1">#     isalpha, isnumeric isalnum isdigit isdecimal isspace islower isupper istitle</span>
    <span class="c1"># _doc_args holds dict of strings to use in substituting casemethod docs</span>
    <span class="n">_doc_args</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;lowercase&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;upper&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;uppercase&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;titlecase&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;capitalize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;be capitalized&quot;</span><span class="p">,</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;capitalize&quot;</span><span class="p">,</span>
        <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;swapcase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;be swapcased&quot;</span><span class="p">,</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;swapcase&quot;</span><span class="p">,</span>
        <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;casefold&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;be casefolded&quot;</span><span class="p">,</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;casefold&quot;</span><span class="p">,</span>
        <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;casemethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">])</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_lower</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;casemethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;upper&quot;</span><span class="p">])</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_upper</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;casemethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">])</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">title</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_title</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;casemethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;capitalize&quot;</span><span class="p">])</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">capitalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_capitalize</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;casemethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;swapcase&quot;</span><span class="p">])</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">swapcase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_swapcase</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;casemethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;casefold&quot;</span><span class="p">])</span>
    <span class="nd">@forbid_nonstring_types</span><span class="p">([</span><span class="s2">&quot;bytes&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">casefold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">_str_casefold</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;ismethods&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Check whether all characters in each string are </span><span class="si">%(type)s</span><span class="s2">.</span>

<span class="s2">    This is equivalent to running the Python string method</span>
<span class="s2">    :meth:`str.</span><span class="si">%(method)s</span><span class="s2">` for each element of the Series/Index. If a string</span>
<span class="s2">    has zero characters, ``False`` is returned for that check.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    Series or Index of bool</span>
<span class="s2">        Series or Index of boolean values with the same length as the original</span>
<span class="s2">        Series/Index.</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    Series.str.isalpha : Check whether all characters are alphabetic.</span>
<span class="s2">    Series.str.isnumeric : Check whether all characters are numeric.</span>
<span class="s2">    Series.str.isalnum : Check whether all characters are alphanumeric.</span>
<span class="s2">    Series.str.isdigit : Check whether all characters are digits.</span>
<span class="s2">    Series.str.isdecimal : Check whether all characters are decimal.</span>
<span class="s2">    Series.str.isspace : Check whether all characters are whitespace.</span>
<span class="s2">    Series.str.islower : Check whether all characters are lowercase.</span>
<span class="s2">    Series.str.isupper : Check whether all characters are uppercase.</span>
<span class="s2">    Series.str.istitle : Check whether all characters are titlecase.</span>

<span class="s2">    Examples</span>
<span class="s2">    --------</span>
<span class="s2">    **Checks for Alphabetic and Numeric Characters**</span>

<span class="s2">    &gt;&gt;&gt; s1 = pd.Series([&#39;one&#39;, &#39;one1&#39;, &#39;1&#39;, &#39;&#39;])</span>

<span class="s2">    &gt;&gt;&gt; s1.str.isalpha()</span>
<span class="s2">    0     True</span>
<span class="s2">    1    False</span>
<span class="s2">    2    False</span>
<span class="s2">    3    False</span>
<span class="s2">    dtype: bool</span>

<span class="s2">    &gt;&gt;&gt; s1.str.isnumeric()</span>
<span class="s2">    0    False</span>
<span class="s2">    1    False</span>
<span class="s2">    2     True</span>
<span class="s2">    3    False</span>
<span class="s2">    dtype: bool</span>

<span class="s2">    &gt;&gt;&gt; s1.str.isalnum()</span>
<span class="s2">    0     True</span>
<span class="s2">    1     True</span>
<span class="s2">    2     True</span>
<span class="s2">    3    False</span>
<span class="s2">    dtype: bool</span>

<span class="s2">    Note that checks against characters mixed with any additional punctuation</span>
<span class="s2">    or whitespace will evaluate to false for an alphanumeric check.</span>

<span class="s2">    &gt;&gt;&gt; s2 = pd.Series([&#39;A B&#39;, &#39;1.5&#39;, &#39;3,000&#39;])</span>
<span class="s2">    &gt;&gt;&gt; s2.str.isalnum()</span>
<span class="s2">    0    False</span>
<span class="s2">    1    False</span>
<span class="s2">    2    False</span>
<span class="s2">    dtype: bool</span>

<span class="s2">    **More Detailed Checks for Numeric Characters**</span>

<span class="s2">    There are several different but overlapping sets of numeric characters that</span>
<span class="s2">    can be checked for.</span>

<span class="s2">    &gt;&gt;&gt; s3 = pd.Series([&#39;23&#39;, &#39;³&#39;, &#39;⅕&#39;, &#39;&#39;])</span>

<span class="s2">    The ``s3.str.isdecimal`` method checks for characters used to form numbers</span>
<span class="s2">    in base 10.</span>

<span class="s2">    &gt;&gt;&gt; s3.str.isdecimal()</span>
<span class="s2">    0     True</span>
<span class="s2">    1    False</span>
<span class="s2">    2    False</span>
<span class="s2">    3    False</span>
<span class="s2">    dtype: bool</span>

<span class="s2">    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also</span>
<span class="s2">    includes special digits, like superscripted and subscripted digits in</span>
<span class="s2">    unicode.</span>

<span class="s2">    &gt;&gt;&gt; s3.str.isdigit()</span>
<span class="s2">    0     True</span>
<span class="s2">    1     True</span>
<span class="s2">    2    False</span>
<span class="s2">    3    False</span>
<span class="s2">    dtype: bool</span>

<span class="s2">    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also</span>
<span class="s2">    includes other characters that can represent quantities such as unicode</span>
<span class="s2">    fractions.</span>

<span class="s2">    &gt;&gt;&gt; s3.str.isnumeric()</span>
<span class="s2">    0     True</span>
<span class="s2">    1     True</span>
<span class="s2">    2     True</span>
<span class="s2">    3    False</span>
<span class="s2">    dtype: bool</span>

<span class="s2">    **Checks for Whitespace**</span>

<span class="s2">    &gt;&gt;&gt; s4 = pd.Series([&#39; &#39;, &#39;</span><span class="se">\\</span><span class="s2">t</span><span class="se">\\</span><span class="s2">r</span><span class="se">\\</span><span class="s2">n &#39;, &#39;&#39;])</span>
<span class="s2">    &gt;&gt;&gt; s4.str.isspace()</span>
<span class="s2">    0     True</span>
<span class="s2">    1     True</span>
<span class="s2">    2    False</span>
<span class="s2">    dtype: bool</span>

<span class="s2">    **Checks for Character Case**</span>

<span class="s2">    &gt;&gt;&gt; s5 = pd.Series([&#39;leopard&#39;, &#39;Golden Eagle&#39;, &#39;SNAKE&#39;, &#39;&#39;])</span>

<span class="s2">    &gt;&gt;&gt; s5.str.islower()</span>
<span class="s2">    0     True</span>
<span class="s2">    1    False</span>
<span class="s2">    2    False</span>
<span class="s2">    3    False</span>
<span class="s2">    dtype: bool</span>

<span class="s2">    &gt;&gt;&gt; s5.str.isupper()</span>
<span class="s2">    0    False</span>
<span class="s2">    1    False</span>
<span class="s2">    2     True</span>
<span class="s2">    3    False</span>
<span class="s2">    dtype: bool</span>

<span class="s2">    The ``s5.str.istitle`` method checks for whether all words are in title</span>
<span class="s2">    case (whether only the first letter of each word is capitalized). Words are</span>
<span class="s2">    assumed to be as any sequence of non-numeric characters separated by</span>
<span class="s2">    whitespace characters.</span>

<span class="s2">    &gt;&gt;&gt; s5.str.istitle()</span>
<span class="s2">    0    False</span>
<span class="s2">    1     True</span>
<span class="s2">    2    False</span>
<span class="s2">    3    False</span>
<span class="s2">    dtype: bool</span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isalnum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;alphanumeric&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;isalnum&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isalpha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;alphabetic&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;isalpha&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isdigit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;digits&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;isdigit&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isspace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;whitespace&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;isspace&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;islower&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;lowercase&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;islower&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isupper&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;uppercase&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;isupper&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;istitle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;titlecase&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;istitle&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isnumeric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;numeric&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;isnumeric&quot;</span><span class="p">}</span>
    <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isdecimal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;decimal&quot;</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;isdecimal&quot;</span><span class="p">}</span>
    <span class="c1"># force _noarg_wrapper return type with dtype=np.dtype(bool) (GH 29624)</span>

    <span class="n">isalnum</span> <span class="o">=</span> <span class="n">_map_and_wrap</span><span class="p">(</span>
        <span class="s2">&quot;isalnum&quot;</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;ismethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isalnum&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">isalpha</span> <span class="o">=</span> <span class="n">_map_and_wrap</span><span class="p">(</span>
        <span class="s2">&quot;isalpha&quot;</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;ismethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isalpha&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">isdigit</span> <span class="o">=</span> <span class="n">_map_and_wrap</span><span class="p">(</span>
        <span class="s2">&quot;isdigit&quot;</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;ismethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isdigit&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">isspace</span> <span class="o">=</span> <span class="n">_map_and_wrap</span><span class="p">(</span>
        <span class="s2">&quot;isspace&quot;</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;ismethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isspace&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">islower</span> <span class="o">=</span> <span class="n">_map_and_wrap</span><span class="p">(</span>
        <span class="s2">&quot;islower&quot;</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;ismethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;islower&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">isupper</span> <span class="o">=</span> <span class="n">_map_and_wrap</span><span class="p">(</span>
        <span class="s2">&quot;isupper&quot;</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;ismethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isupper&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">istitle</span> <span class="o">=</span> <span class="n">_map_and_wrap</span><span class="p">(</span>
        <span class="s2">&quot;istitle&quot;</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;ismethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;istitle&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">isnumeric</span> <span class="o">=</span> <span class="n">_map_and_wrap</span><span class="p">(</span>
        <span class="s2">&quot;isnumeric&quot;</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;ismethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isnumeric&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">isdecimal</span> <span class="o">=</span> <span class="n">_map_and_wrap</span><span class="p">(</span>
        <span class="s2">&quot;isdecimal&quot;</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;ismethods&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_doc_args</span><span class="p">[</span><span class="s2">&quot;isdecimal&quot;</span><span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">cat_safe</span><span class="p">(</span><span class="n">list_of_columns</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Auxiliary function for :meth:`str.cat`.</span>

<span class="sd">    Same signature as cat_core, but handles TypeErrors in concatenation, which</span>
<span class="sd">    happen if the arrays in list_of columns have the wrong dtypes or content.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    list_of_columns : list of numpy arrays</span>
<span class="sd">        List of arrays to be concatenated with sep;</span>
<span class="sd">        these arrays may not contain NaNs!</span>
<span class="sd">    sep : string</span>
<span class="sd">        The separator string for concatenating the columns.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nd.array</span>
<span class="sd">        The concatenation of list_of_columns with sep.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cat_core</span><span class="p">(</span><span class="n">list_of_columns</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># if there are any non-string values (wrong dtype or hidden behind</span>
        <span class="c1"># object dtype), np.sum will fail; catch and return with better message</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">list_of_columns</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;empty&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Concatenation requires list-likes containing only &quot;</span>
                    <span class="s2">&quot;strings (or missing values). Offending values found in &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;column </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">cat_core</span><span class="p">(</span><span class="n">list_of_columns</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Auxiliary function for :meth:`str.cat`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    list_of_columns : list of numpy arrays</span>
<span class="sd">        List of arrays to be concatenated with sep;</span>
<span class="sd">        these arrays may not contain NaNs!</span>
<span class="sd">    sep : string</span>
<span class="sd">        The separator string for concatenating the columns.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nd.array</span>
<span class="sd">        The concatenation of list_of_columns with sep.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sep</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="c1"># no need to interleave sep if it is empty</span>
        <span class="n">arr_of_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">list_of_columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr_of_cols</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">list_with_sep</span> <span class="o">=</span> <span class="p">[</span><span class="n">sep</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_columns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">list_with_sep</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_of_columns</span>
    <span class="n">arr_with_sep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">list_with_sep</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr_with_sep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_result_dtype</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="c1"># workaround #27953</span>
    <span class="c1"># ideally we just pass `dtype=arr.dtype` unconditionally, but this fails</span>
    <span class="c1"># when the list of values is empty.</span>
    <span class="kn">from</span> <span class="nn">pandas.core.arrays.string_</span> <span class="kn">import</span> <span class="n">StringDtype</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">StringDtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">object</span>


<span class="k">def</span> <span class="nf">_get_single_group_name</span><span class="p">(</span><span class="n">regex</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hashable</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">regex</span><span class="o">.</span><span class="n">groupindex</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">regex</span><span class="o">.</span><span class="n">groupindex</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_get_group_names</span><span class="p">(</span><span class="n">regex</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get named groups from compiled regex.</span>

<span class="sd">    Unnamed groups are numbered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    regex : compiled regex</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of column labels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">regex</span><span class="o">.</span><span class="n">groupindex</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">regex</span><span class="o">.</span><span class="n">groups</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">str_extractall</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
    <span class="c1"># the regex must contain capture groups.</span>
    <span class="k">if</span> <span class="n">regex</span><span class="o">.</span><span class="n">groups</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pattern contains no capture groups&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="n">_get_group_names</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
    <span class="n">match_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">index_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">is_mi</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">&gt;</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">subject_key</span><span class="p">,</span> <span class="n">subject</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_mi</span><span class="p">:</span>
                <span class="n">subject_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">subject_key</span><span class="p">,)</span>

            <span class="k">for</span> <span class="n">match_i</span><span class="p">,</span> <span class="n">match_tuple</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">regex</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">subject</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">match_tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">match_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">match_tuple</span><span class="p">,)</span>
                <span class="n">na_tuple</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="k">if</span> <span class="n">group</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="n">group</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">match_tuple</span><span class="p">]</span>
                <span class="n">match_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">na_tuple</span><span class="p">)</span>
                <span class="n">result_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">subject_key</span> <span class="o">+</span> <span class="p">(</span><span class="n">match_i</span><span class="p">,))</span>
                <span class="n">index_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_key</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">index_list</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;match&quot;</span><span class="p">])</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_result_dtype</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">_constructor_expanddim</span><span class="p">(</span>
        <span class="n">match_list</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso Furlanello, and Daniel Hug.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>