{"id": 2, "start_time": 1690380436, "output": "Section 1: Experimental APIs\n============================\n\nThese APIs may change at any time (including in minor releases) with no notice. You \nprobably shouldn't use them, but if you do, you should pin your application to an exact\nrelease of LibCST to avoid breakages.\n\nSection 2: Reentrant Code Generation\n===================================\n\nThis section includes the classes related to reentrant code generation.\n\n2.1 `ExperimentalReentrantCodegenProvider` Class\n----------------------------------------------\n\n.. autoclass:: libcst.metadata.ExperimentalReentrantCodegenProvider\n\n2.2 `CodegenPartial` Class\n-------------------------\n\n.. autoclass:: libcst.metadata.CodegenPartial", "prompt_tokens": 123, "completion_tokens": 135, "total_tokens": 258, "end_time": 1690380437}
{"id": 0, "start_time": 1690380436, "output": "Section 1: Introduction\n- README.rst (from introductory start to introductory end)\n\nSection 2: Introduction to LibCST\n- why_libcst\n- motivation\n\nSection 3: Tutorial\n- Parsing and Visitors (tutorial)\n- Metadata (metadata_tutorial)\n- Scope Analysis (scope_tutorial)\n- Matchers (matchers_tutorial)\n- Codemodding (codemods_tutorial)\n- Best Practices (best_practices)\n\nSection 4: Reference\n- parser\n- nodes\n- visitors\n- metadata\n- matchers\n- codemods\n- helpers\n- experimental\n\nSection 5: Indices and tables\n- genindex\n- modindex\n- search\n\nSection 6: Additional Documentation\n- README.rst (from fb-docs-start to fb-docs-end)", "prompt_tokens": 318, "completion_tokens": 168, "total_tokens": 486, "end_time": 1690380437}
{"id": 1, "start_time": 1690380436, "output": "Parsing\n=======\nThe parsing section of the documentation explains the parser functions provided by the library. It includes the following topics:\n\n1. Overview: Provides a brief introduction to the parser functions and their usage.\n \n2. parse_module: A detailed explanation of the `parse_module` function, including its parameters and return value. \n\n3. parse_expression: An explanation of the `parse_expression` function and its usage for inserting new nodes into the tree.\n\n4. parse_statement: An explanation of the `parse_statement` function and its usage for inserting new nodes into the tree.\n\n5. PartialParserConfig: An explanation of the `PartialParserConfig` class, including its purpose and usage.\n\nSyntax Errors\n-------------\nThis section explains the `ParserSyntaxError` class, which is used to handle syntax errors during parsing. It includes the following topics:\n\n1. ParserSyntaxError class: An introduction to the `ParserSyntaxError` class and its usage.\n\n2. Class members: Details about the class members of `ParserSyntaxError`, including `message`, `raw_line`, `raw_column`, `editor_line`, and `editor_column`.\n\n3. Special members: Information about the special member `__str__` of `ParserSyntaxError`.", "prompt_tokens": 318, "completion_tokens": 248, "total_tokens": 566, "end_time": 1690380437}
{"id": 7, "start_time": 1690380441, "output": "Motivation:\n- Exact Representation\n- Ease of Traversal\n- Ease of Modification\n- Well Tested", "prompt_tokens": 822, "completion_tokens": 21, "total_tokens": 843, "end_time": 1690380441}
{"id": 3, "start_time": 1690380436, "output": "Section 1: Best Practices\n==========================\n\nWhile there are plenty of ways to interact with LibCST, we recommend some patterns\nover others. Various best practices are laid out here along with their justifications.\n\nSection 2: Avoid instanceof when traversing\n-------------------------------------------\nExcessive use of isinstance implies that you should rewrite your check as a\nmatcher or unroll it into a set of visitor methods. Often, you should make use of\n`cst.ensure_type` to make your type checker aware of a node's type.\n\nSection 3: Prefer updated_node when modifying trees\n--------------------------------------------------\nWhen you are using `cst.CSTTransformer` to modify a LibCST tree, only return\nmodifications to updated_node. The original_node parameter on any\nleave_Node method is provided for book-keeping and is guaranteed to be\nequal via == and is checks to the node parameter in the corresponding\nvisit_Node method.\n\nSection 4: Provide a config when generating code from templates\n--------------------------------------------------------------\nWhen generating complex trees it is often far easier to pass a string to\n`libcst.parse_statement` or `libcst.parse_expression` than it is to\nmanually construct the tree. When using these functions to generate code, you should\nalways use the config parameter in order to generate code that matches the\ndefaults of the module you are modifying.\n\nThis ensures that line endings and indentation are consistent with the defaults in the\nmodule you are adding the code to.", "prompt_tokens": 1860, "completion_tokens": 300, "total_tokens": 2160, "end_time": 1690380437}
{"id": 4, "start_time": 1690380436, "output": "**Why LibCST?**\n\nPython's ast module already provides a syntax tree. Why do we need another?\n\nAbstract Syntax Trees (AST)\n===========================\n\n- Python's AST provides a syntax tree for code snippets, which preserves the semantics of the original code.\n- However, the AST does not preserve all information, such as comments, specific newline characters, and whitespace between arguments.\n- ASTs are suitable for tools like compilers and type checkers that focus on code semantics rather than exact syntax.\n\nConcrete Syntax Trees (CST)\n===========================\n\n- Lib2to3 is a popular CST library for Python, used by tools like 2to3 and Black.\n- CSTs preserve all whitespace information and can be reprinted exactly, but they closely match Python's grammar and can be complex to manipulate.\n- Modifying CSTs may require careful preservation of nodes, and whitespace and comment ownership can be unclear.\n\nLibCST\n======\n\n- LibCST takes a compromise between ASTs and CSTs.\n- Like CSTs, LibCST preserves all whitespace and can be reprinted exactly.\n- Like ASTs, LibCST parses source into nodes that represent code semantics.\n- LibCST assigns whitespace using an internal parser, allowing for granular ownership.\n- This reduces the complexity of complex manipulations compared to CSTs, but tools focusing primarily on whitespace may find it more difficult to implement.\n- LibCST is fully typed and offers well-defined node structures that match Python semantics.\n- However, parsing with LibCST is slower than Python's AST due to the additional work for assigning whitespace.\n\nConclusion\n==========\n\n- LibCST offers a compromise between ASTs and CSTs, providing flexibility and power.\n- The trade-offs made in LibCST, such as granular whitespace ownership, make it suitable for complex manipulations and tools that focus on code semantics.\n- However, tools primarily focusing on whitespace may find it more challenging to implement compared to lib2to3.\n- Overall, LibCST provides a valuable alternative for working with Python code.", "prompt_tokens": 3050, "completion_tokens": 417, "total_tokens": 3467, "end_time": 1690380437}
{"id": 8, "start_time": 1690380441, "output": "Codemods:\n- Introduction and definition of codemods in LibCST.\n\nCodemod Base:\n- Overview of the common base class for all codemods in LibCST.\n- Explanation of the Codemod and CodemodContext classes.\n- Introduction to LibCST-compatible visitors for codemods.\n\nExecution Interface:\n- Documentation on how to execute codemods programmatically using the transform_module function.\n- Description of the TransformResult, TransformSuccess, TransformFailure, TransformSkip, SkipReason, and TransformExit classes.\n\nCommand-Line Support:\n- Description of the CodemodCommand class and its usage for creating command-line interfaces for codemods.\n- Explanation of the \"codemod\" utility and its features for running codemods at the command-line.\n- Overview of the \"list\" utility for listing available codemods.\n- Description of the \"initialize\" utility for setting up a directory for codemodding.\n\nCommand-Line Toolkit:\n- Documentation for helpers used in constructing custom command-line tools.\n- Explanation of gather_files, exec_transform_with_prettyprint, parallel_exec_transform_with_prettyprint, ParallelTransformResult, and diff_code.\n\nLibrary of Transforms:\n- Introduction to the library of transforms provided by LibCST.\n- Description of the GatherImportsVisitor, GatherExportsVisitor, AddImportsVisitor, RemoveImportsVisitor, ApplyTypeAnnotationsVisitor, GatherUnusedImportsVisitor, GatherCommentsVisitor, and GatherNamesFromStringAnnotationsVisitor.", "prompt_tokens": 1936, "completion_tokens": 297, "total_tokens": 2233, "end_time": 1690380441}
{"id": 9, "start_time": 1690380444, "output": "Section 1: Visitors\n===================\n\nThis section introduces the concept of Visitors and provides information about the different visitor classes and functions available in the `libcst` module. It includes the following:\n- `CSTVisitor` class\n- `CSTTransformer` class\n- `RemoveFromParent` function\n- `RemovalSentinel` class\n- `FlattenSentinel` class\n\nSection 2: Visit and Leave Helper Functions\n===========================================\n\nThis section explains the recommended approach to implementing visitors by subclassing from `CSTVisitor` or `CSTTransformer` and using the helper functions. It includes the following information:\n- Explanation about the default implementation of visitors and how the helper functions work\n- Use of `visit_<Type[CSTNode]>` and `leave_<Type[CSTNode]>` methods\n- Use of `visit_<Type[CSTNode]>_<attribute>` and `leave_<Type[CSTNode]>_<attribute>` methods\n- Handling of return values from visit functions and the use of `None` for default behavior\n- Example code demonstrating the usage of visit functions\n\nSection 3: Traversal Order\n==========================\n\nThis section explains the traversal order of a parsed tree and the sequence of method calls during the traversal process. It includes the following information:\n- Explanation of the traversal order based on the order of tokens in the parsed source\n- Sequence of method calls for different nodes and attributes in the tree\n- Note about attribute visitors not being called for built-in Python types\n\nSection 4: Batched Visitors\n===========================\n\nThis section introduces the concept of batchable visitors and the `BatchableCSTVisitor` class. It also mentions the `visit_batched` function. The purpose of batchable visitors is to perform operations that can be parallelized in a single traversal. An example mentioned is metadata computation.\n\nEach section provides information about the relevant classes, functions, and their usage.", "prompt_tokens": 1246, "completion_tokens": 394, "total_tokens": 1640, "end_time": 1690380444}
{"id": 6, "start_time": 1690380436, "output": "Metadata\n========\n\nMetadata APIs\n-------------\n\nLibCST ships with a metadata interface that defines a standardized way to associate nodes in a CST with arbitrary metadata while maintaining the immutability of the tree. The metadata interface is designed to be declarative and type safe. Here's a quick example of using the metadata interface to get line and column numbers of nodes through the `PositionProvider`:\n\n`NamePrinter` is a class that extends `CSTVisitor` and overrides the `visit_Name` method. It prints the line and column numbers of a `Name` node. The position metadata is obtained using the `get_metadata` method, which takes the `PositionProvider` class as an argument.\n\nTo use the metadata interface, you need to wrap a module with a `MetadataWrapper`. The `MetadataWrapper` provides functions `resolve` and `resolve_many` to generate metadata. If you're working with visitors that extend `MetadataDependent`, metadata dependencies will be automatically computed when visited by a `MetadataWrapper` and are accessible through the `get_metadata` method.\n\nProviding Metadata\n------------------\n\nMetadata is generated through provider classes that can be passed to the `MetadataWrapper.resolve` function or declared as a dependency of a `MetadataDependent`. These providers are then resolved automatically using methods provided by `MetadataWrapper`. There are different types of metadata providers available, such as `PositionProvider`, `ByteSpanPositionProvider`, `WhitespaceInclusivePositionProvider`, `ExpressionContextProvider`, `ScopeProvider`, `QualifiedNameProvider`, `ParentNodeProvider`, and `TypeInferenceProvider`.\n\nPosition Metadata\n-----------------\n\nThere are two types of position metadata available. One represents position with line and column numbers, while the other outputs byte offset and length pairs.\n\nLine and column numbers are available through the metadata interface by declaring `PositionProvider` or `WhitespaceInclusivePositionProvider`. Node positions are represented with `CodeRange` objects.\n\nByte offset and length pairs can be accessed using `ByteSpanPositionProvider`. Positions are represented with `CodeSpan` objects.\n\nExpression Context Metadata\n---------------------------\n\nExpression context metadata provides information about the context in which an expression node is used. This metadata is available through the `ExpressionContextProvider`.\n\nScope Metadata\n--------------\n\nScope metadata provides information about scopes and variables in a program. Scopes enforce that a local variable name bound inside a function is not available outside of that function. LibCST allows you to inspect these scopes to see what local variables are assigned or accessed within. The available scope types are `BuiltinScope`, `GlobalScope`, `ClassScope`, `FunctionScope`, and `ComprehensionScope`. The scope metadata is provided by `ScopeProvider`.\n\nQualified Name Metadata\n-----------------------\n\nQualified name metadata provides unambiguous names to locate the definitions of variables, classes, and functions. The metadata includes a `QualifiedNameSource` and a `QualifiedNameProvider`. The `FullyQualifiedNameProvider` provides fully qualified names that take the current module's location into account.\n\nParent Node Metadata\n--------------------\n\nParent node metadata provides access to the parent `CSTNode` for more information or for traversing the tree in a bottom-up manner. This metadata is provided by the `ParentNodeProvider`.\n\nFile Path Metadata\n------------------\n\nFile path metadata provides the absolute file path on disk for any module being visited. This metadata is provided by the `FilePathProvider` and requires an active `FullRepoManager`.\n\nType Inference Metadata\n-----------------------\n\nType inference metadata automatically infers data types of expressions for deeper understanding of source code. This metadata is provided by the `TypeInferenceProvider` and requires a `FullRepoManager` for inter-process communication with Pyre, a type checker for Python. The `TypeInferenceProvider` uses Pyre's Query API to infer types based on type annotations.\n", "prompt_tokens": 2268, "completion_tokens": 765, "total_tokens": 3033, "end_time": 1690380437}
{"id": 12, "start_time": 1690380449, "output": "Helpers\n=======\n\nHelpers are higher level functions built for reducing recurring code boilerplate.\nWe add helpers as method of ``CSTNode`` or ``libcst.helpers`` package based on those principles:\n\n  - ``CSTNode`` method: simple, read-only and only require data of the direct children of a CSTNode.\n  - ``libcst.helpers``: node transforms or require recursively traversing the syntax tree.\n\nConstruction Helpers\n--------------------\n\nFunctions that assist in creating a new LibCST tree.\n\n.. autofunction:: libcst.helpers.parse_template_module\n    Parses a template module and returns a corresponding `Module` node.\n\n.. autofunction:: libcst.helpers.parse_template_expression\n    Parses a template expression and returns a corresponding `Expression` node.\n\n.. autofunction:: libcst.helpers.parse_template_statement\n    Parses a template statement and returns a corresponding `Statement` node.\n\nTransformation Helpers\n----------------------\n\nFunctions that assist in transforming an existing LibCST node.\n\n.. autofunction:: libcst.helpers.insert_header_comments\n    Inserts header comments before the given node.\n\nTraversing Helpers\n------------------\n\nFunctions that assist in traversing an existing LibCST tree.\n\n.. autofunction:: libcst.helpers.get_full_name_for_node\n    Retrieves the full name of a node in the syntax tree.\n\n.. autofunction:: libcst.helpers.get_full_name_for_node_or_raise\n    Retrieves the full name of a node in the syntax tree or raises an exception if not found.\n\n.. autofunction:: libcst.helpers.ensure_type\n    Ensures that a node is of a specific type, otherwise raises a `TypeError`.", "prompt_tokens": 250, "completion_tokens": 323, "total_tokens": 573, "end_time": 1690380449}
{"id": 10, "start_time": 1690380445, "output": "Sections in the documentation:\n1. Nodes\n2. CSTNode\n3. Module\n4. Expressions\n   1. BaseExpression\n   2. Name\n   3. Attribute\n   4. UnaryOperation\n   5. BinaryOperation\n   6. BooleanOperation\n   7. Comparison\n   8. ComparisonTarget\n5. Control Flow\n   1. Asynchronous\n   2. Await\n   3. Yield\n   4. From\n   5. IfExp\n6. Lambdas and Function Calls\n   1. Lambda\n   2. Call\n   3. Arg\n7. Literal Values\n   1. Ellipsis\n   2. Numbers\n   3. BaseNumber\n   4. Integer\n   5. Float\n   6. Imaginary\n   7. Strings\n   8. BaseString\n   9. SimpleString\n   10. ConcatenatedString\n   11. Formatted Strings (f-strings)\n   12. FormattedString\n   13. BaseFormattedStringContent\n   14. FormattedStringText\n   15. FormattedStringExpression\n8. Collections\n   1. Simple Collections\n      - Tuple\n      - BaseList\n      - List\n      - BaseSet\n      - Set\n   2. Simple Collection Elements\n      - BaseElement\n      - Element\n      - StarredElement\n   3. Dictionaries\n      - BaseDict\n      - Dict\n   4. Dictionary Elements\n      - BaseDictElement\n      - DictElement\n      - StarredDictElement\n9. Comprehensions\n   1. BaseComp\n   2. BaseSimpleComp\n   3. GeneratorExp\n   4. ListComp\n   5. SetComp\n   6. DictComp\n   7. CompFor\n   8. CompIf\n10. Subscripts and Slices\n    - Subscript\n    - BaseSlice\n    - Index\n    - Slice\n    - SubscriptElement\n11. Parenthesis, Brackets, and Braces\n    - LeftParen\n    - RightParen\n    - LeftSquareBracket\n    - RightSquareBracket\n    - LeftCurlyBrace\n    - RightCurlyBrace\n12. Statements\n    1. Simple Statements\n       - BaseSmallStatement\n       - AnnAssign\n       - Assert\n       - Assign\n       - AugAssign\n       - Break\n       - Continue\n       - Del\n       - Expr\n       - Global\n       - Import\n       - ImportFrom\n       - Nonlocal\n       - Pass\n       - Raise\n       - Return\n    2. Compound Statements\n       - BaseCompoundStatement\n       - ClassDef\n       - For\n       - FunctionDef\n       - If\n       - Try\n       - While\n       - With\n13. Helper Nodes\n    - Annotation\n    - AsName\n    - AssignTarget\n    - BaseAssignTargetExpression\n    - BaseDelTargetExpression\n    - Decorator\n    - Else\n    - ExceptHandler\n    - Finally\n    - ImportAlias\n    - NameItem\n    - Parameters\n    - Param\n    - ParamSlash\n    - ParamStar\n    - WithItem\n14. Statement Blocks\n    - BaseSuite\n    - SimpleStatementLine\n    - SimpleStatementSuite\n    - IndentedBlock\n15. Operators\n    1. Unary Operators\n       - BitInvert\n       - Minus\n       - Not\n       - Plus\n    2. Boolean Operators\n       - And\n       - Or\n    3. Binary Operators\n       - Add\n       - BitAnd\n       - BitOr\n       - BitXor\n       - Divide\n       - FloorDivide\n       - LeftShift\n       - MatrixMultiply\n       - Modulo\n       - Multiply\n       - Power\n       - RightShift\n       - Subtract\n    4. Comparison Operators\n       - Equal\n       - GreaterThan\n       - GreaterThanEqual\n       - In\n       - Is\n       - LessThan\n       - LessThanEqual\n       - NotEqual\n       - IsNot\n       - NotIn\n    5. Augmented Assignment Operators\n       - AddAssign\n       - BitAndAssign\n       - BitOrAssign\n       - BitXorAssign\n       - DivideAssign\n       - FloorDivideAssign\n       - LeftShiftAssign\n       - MatrixMultiplyAssign\n       - ModuloAssign\n       - MultiplyAssign\n       - PowerAssign\n       - RightShiftAssign\n       - SubtractAssign\n16. Miscellaneous\n    - AssignEqual\n    - Colon\n    - Comma\n    - Dot\n    - ImportStar\n    - Semicolon\n17. Whitespace\n    - Comment\n    - EmptyLine\n    - Newline\n    - ParenthesizedWhitespace\n    - SimpleWhitespace\n    - TrailingWhitespace\n    - BaseParenthesizableWhitespace\n18. Maybe Sentinel", "prompt_tokens": 2506, "completion_tokens": 1071, "total_tokens": 3577, "end_time": 1690380445}
{"id": 5, "start_time": 1690380436, "output": "=====================\nWorking With Codemods\n=====================\n\nCodemods are an abstraction on top of LibCST for performing large-scale changes to an entire codebase. See :doc:`Codemods <codemods>` for the complete documentation.\n\n-------------------------------\nSetting up and Running Codemods\n-------------------------------\n\nLet's say you were interested in converting legacy ``.format()`` calls to shiny new Python 3.6 f-strings. LibCST ships with a command-line interface known as ``libcst.tool``. This includes a few provisions for working with codemods at the command-line. It also includes a library of pre-defined codemods, one of which is a transform that can convert most ``.format()`` calls to f-strings. So, let's use this to give Python 3.6 f-strings a try.\n\nYou might be lucky enough that the defaults for LibCST perfectly match your coding style, but chances are you want to customize LibCST to your repository. Initialize your repository by running the following command in the root of your repository and then edit the produced ``.libcst.codemod.yaml`` file::\n\n    python3 -m libcst.tool initialize .\n\nThe file includes provisions for customizing any generated code marker, calling an external code formatter such as `black <https://pypi.org/project/black/>`_, blackisting patterns of files you never wish to touch and a list of modules that contain valid codemods that can be executed. If you want to write and run codemods specific to your repository or organization, you can add an in-repo module location to the list of modules and LibCST will discover codemods in all locations.\n\nNow that your repository is initialized, let's have a quick look at what's currently available for running. Run the following command from the root of your repository::\n\n    python3 -m libcst.tool list\n\nYou'll see several codemods available to you, one of which is ``convert_format_to_fstring.ConvertFormatStringCommand``. The description to the right of this codemod indicates that it converts ``.format()`` calls to f-strings, so let's give it a whirl! Execute the codemod from the root of your repository like so::\n\n    python3 -m libcst.tool codemod convert_format_to_fstring.ConvertFormatStringCommand .\n\nIf you want to try it out on only one file or a specific subdirectory, you can replace the ``.`` in the above command with a relative directory, file, list of directories or list of files. While LibCST is walking through your repository and codemodding files you will see a progress indicator. If there's anything the codemod can't do or any unexpected syntax errors, you will also see them on your console as it progresses.\n\nIf everything works out, you'll notice that your ``.format()`` calls have been converted to f-strings!\n\n-----------------\nWriting a Codemod\n-----------------\n\nCodemods use the same principles as the rest of LibCST. They take LibCST's core, metadata and matchers and package them up as a simple command-line interface. So, anything you can do with LibCST in isolation you can also do with a codemod.\n\nLet's say you need to clean up some legacy code which used magic values instead of constants. You've already got a constants module called ``utils.constants`` and you want to assume that every reference to a raw string matching a particular constant should be converted to that constant. For the simplest version of this codemod, you'll need a command-line tool that takes as arguments the string to replace and the constant to replace it with. You'll also need to ensure that modified modules import the constant itself.\n\nSo, you can write something similar to the following::\n\n    import argparse\n    from ast import literal_eval\n    from typing import Union\n\n    import libcst as cst\n    from libcst.codemod import CodemodContext, VisitorBasedCodemodCommand\n    from libcst.codemod.visitors import AddImportsVisitor\n\n\n    class ConvertConstantCommand(VisitorBasedCodemodCommand):\n\n        # Add a description so that future codemodders can see what this does.\n        DESCRIPTION: str = \"Converts raw strings to constant accesses.\"\n\n        @staticmethod\n        def add_args(arg_parser: argparse.ArgumentParser) -> None:\n            # Add command-line args that a user can specify for running this\n            # codemod.\n            arg_parser.add_argument(\n                \"--string\",\n                dest=\"string\",\n                metavar=\"STRING\",\n                help=\"String contents that we should look for.\",\n                type=str,\n                required=True,\n            )\n            arg_parser.add_argument(\n                \"--constant\",\n                dest=\"constant\",\n                metavar=\"CONSTANT\",\n                help=\"Constant identifier we should replace strings with.\",\n                type=str,\n                required=True,\n            )\n\n        def __init__(self, context: CodemodContext, string: str, constant: str) -> None:\n            # Initialize the base class with context, and save our args. Remember, the\n            # \"dest\" for each argument we added above must match a parameter name in\n            # this init.\n            super().__init__(context)\n            self.string = string\n            self.constant = constant\n\n        def leave_SimpleString(\n            self, original_node: cst.SimpleString, updated_node: cst.SimpleString\n        ) -> Union[cst.SimpleString, cst.Name]:\n            if literal_eval(updated_node.value) == self.string:\n                # Check to see if the string matches what we want to replace. If so,\n                # then we do the replacement. We also know at this point that we need\n                # to import the constant itself.\n                AddImportsVisitor.add_needed_import(\n                    self.context, \"utils.constants\", self.constant,\n                )\n                return cst.Name(self.constant)\n            # This isn't a string we're concerned with, so leave it unchanged.\n            return updated_node\n\nThis codemod is pretty simple. It defines a command-line description, sets up to parse a few required command-line args, initializes its own member variables with the command-line args that were parsed for it by ``libcst.tool codemod`` and finally replaces any string which matches our string command-line argument with a constant. It also takes care of adding the import required for the constant to be defined properly.\n\nCool! Let's look at the command-line help for this codemod. Let's assume you saved it as ``constant_folding.py`` inside ``libcst.codemod.commands``. You can get help for the codemod by running the following command::\n\n    python3 -m libcst.tool codemod constant_folding.ConvertConstantCommand --help\n\nNotice that along with the default arguments, the ``--string`` and ``--constant`` arguments are present in the help, and the command-line description has been updated with the codemod's description string. You'll notice that the codemod also shows up on ``libcst.tool list``.\n\n----------------\nTesting Codemods\n----------------\n\nInstead of iterating on a codemod by running it repeatedly on a codebase and seeing what happens, we can write a series of unit tests that assert on desired transformations. Given the above constant folding codemod that we wrote, we can test it with some code similar to the following::\n\n    from libcst.codemod import CodemodTest\n    from libcst.codemod.commands.constant_folding import ConvertConstantCommand\n\n\n    class TestConvertConstantCommand(CodemodTest):\n\n        # The codemod that will be instantiated for us in assertCodemod.\n        TRANSFORM = ConvertConstantCommand\n\n        def test_noop(self) -> None:\n            before = \"\"\"\n                foo = \"bar\"\n            \"\"\"\n            after = \"\"\"\n                foo = \"bar\"\n            \"\"\"\n\n            # Verify that if we don't have a valid string match, we don't make\n            # any substitutions.\n            self.assertCodemod(before, after, string=\"baz\", constant=\"BAZ\")\n\n        def test_substitution(self) -> None:\n            before = \"\"\"\n                foo = \"bar\"\n            \"\"\"\n            after = \"\"\"\n                from utils.constants import BAR\n\n                foo = BAR\n            \"\"\"\n\n            # Verify that if we do have a valid string match, we make a substitution\n            # as well as import the constant.\n            self.assertCodemod(before, after, string=\"bar\", constant=\"BAR\")\n\nIf we save this as ``test_constant_folding.py`` inside ``libcst.codemod.commands.tests`` then we can execute the tests with the following line::\n\n    python3 -m unittest libcst.codemod.commands.tests.test_constant_folding\n\nThat's all there is to it!", "prompt_tokens": 1879, "completion_tokens": 1810, "total_tokens": 3689, "end_time": 1690380437}
{"id": 11, "start_time": 1690380446, "output": "Matchers\n=========\n\nMatchers are provided as a way of asking whether a particular LibCST node and its children match a particular shape. It is possible to write a visitor that tracks attributes using `visit_<Node>` methods. It is also possible to implement manual instance checking and traversal of a node's children. However, both are cumbersome to write and hard to understand. Matchers offer a more concise way of defining what attributes on a node matter when matching against predefined patterns.\n\nTo accomplish this, a matcher has been created which corresponds to each LibCST node documented in `libcst-nodes`. Matchers default each of their attributes to the special sentinel matcher `DoNotCare`. When constructing a matcher, you can initialize the node with only the values of attributes that you are concerned with, leaving the rest of the attributes set to `DoNotCare` in order to skip comparing against them.\n\nMatcher APIs\n------------\n\n### Functions\n\nMatchers can be used either by calling `matches` or `findall` directly, or by using various decorators to selectively control when LibCST calls visitor functions.\n\n`libcst.matchers.matches`\n`libcst.matchers.findall`\n`libcst.matchers.extract`\n`libcst.matchers.extractall`\n`libcst.matchers.replace`\n\n### Decorators\n\nThe following decorators can be placed onto a method in a visitor or transformer in order to convert it into a visitor which is called when the provided matcher is true.\n\n`libcst.matchers.visit`\n`libcst.matchers.leave`\n\nThe following decorators can be placed onto any existing `visit_<Node>` or `leave_<Node>` visitor, as well as any visitor created using either `visit` or `leave`. They control whether the visitor itself gets called or skipped by LibCST when traversing a tree. Note that when a visitor function is skipped, its children will still be visited based on the rules set forth in `libcst-visitors`. Namely, if you have a separate `visit_<Node>` visitor that returns `False` for a particular node, we will not traverse to its children.\n\n`libcst.matchers.call_if_inside`\n`libcst.matchers.call_if_not_inside`\n\nWhen using matcher decorators, your visitors must subclass from `MatcherDecoratableVisitor` instead of `libcst.CSTVisitor`, and from `MatcherDecoratableTransformer` instead of `libcst.CSTTransformer`. This is so that visitors and transformers not making use of matcher decorators do not pay the extra cost of their implementation. Note that if you do not subclass from `MatcherDecoratableVisitor` or `MatcherDecoratableTransformer`, you can still use the `matches` function.\n\nBoth of these classes are strict subclasses of their corresponding LibCST base class, so they can be used anywhere that expects a LibCST base class. See `libcst-visitors` for more information.\n\n`libcst.matchers.MatcherDecoratableVisitor`\n`libcst.matchers.MatcherDecoratableTransformer`\n\nTraversal Order\n---------------\n\nVisit and leave functions created using `visit` or `leave` follow the traversal order rules laid out in LibCST's visitor `libcst-visitor-traversal` with one additional rule. Any visit function created using the `visit` decorator will be called **before** a `visit_<Node>` function if it is defined for your visitor. The order in which various visit functions which are created with `visit` are called is indeterminate, but all such functions will be called before calling the `visit_<Node>` method. Similarly, any leave function created using the `leave` decorator will be called **after** a `leave_<Node>` function if it is defined for your visitor. The order in which various leave functions which are created with `leave` are called is indeterminate, but all such functions will be called after calling the `visit_<Node>` function if it is defined for your visitor.\n\nThis has a few implications. The first is that if you return `False` from a `visit_<Node>` method, we are guaranteed to call your decorated visit functions as well. Second, when modifying a node in both `leave_<Node>` and a visitor created with `leave`, the `original_node` will be unchanged for both and the `updated_node` available to the decorated leave method will be the node that is returned by the `leave_<Node>` method. Chaining modifications across multiple leave functions is supported, but must be done with care.\n\nMatcher Types\n-------------\n\n### Concrete Matchers\n\nFor each node found in `libcst-nodes`, a corresponding concrete matcher has been generated. Each matcher has attributes identical to its LibCST node counterpart. For example, `libcst.Expr` includes the `value` and `semicolon` attributes, and therefore `libcst.matchers.Expr` similarly includes the same attributes. Just as `libcst.Expr`'s `value` is typed as taking a `libcst.BaseExpression`, `libcst.matchers.Expr`'s `value` is typed as taking a `libcst.matchers.BaseExpression`. For every node that exists in LibCST, both concrete and abstract, a corresponding matcher has been defined.\n\nThere are a few special cases to the rules laid out above. For starters, matchers don't support evaluating `libcst.MaybeSentinel`. There is no way to specify that you wish to match against a `libcst.MaybeSentinel` except with the `DoNotCare` matcher. This tends not to be an issue in practice because `libcst.MaybeSentinel` is only found on syntax nodes.\n\nWhile there are base classes such as `libcst.matchers.BaseExpression`, you cannot match directly on them. They are provided for typing purposes only in order to exactly match the types on LibCST node attributes. If you need to match on all concrete subclasses of a base class, we recommend using the special matcher `OneOf`.\n\n### Special Matchers\n\nSpecial matchers are matchers that don't have a corresponding LibCST node. Concrete matchers only match against their corresponding LibCST node, limiting their use under certain circumstances. Special matchers fill in the gap by allowing higher-level logic constructs such as inversion. You can use any special matcher in place of a concrete matcher when specifying matcher attributes. Additionally, you can also use the `OneOf` and `AllOf` special matchers in place of a concrete matcher when calling `matches` or using decorators.\n\n`libcst.matchers.OneOf`\n`libcst.matchers.AllOf`\n`libcst.matchers.TypeOf`\n`libcst.matchers.DoesNotMatch`\n`libcst.matchers.MatchIfTrue`\n`libcst.matchers.MatchRegex`\n`libcst.matchers.MatchMetadata`\n`libcst.matchers.MatchMetadataIfTrue`\n`libcst.matchers.SaveMatchedNode`\n`libcst.matchers.DoNotCare`\n\n### Sequence Wildcard Matchers\n\nSequence wildcard matchers are matchers that only get used when constructing a sequence to match against. Not all LibCST nodes have attributes which are sequences, but for those that do, sequence wildcard matchers offer a great degree of flexibility. Unlike all other matcher types, these allow you to match against more than one LibCST node, much like wildcards in regular expressions do.\n\nLibCST does not implicitly match on partial sequences for you. So, when matching against a sequence you will need to provide a complete pattern. This often means using helpers such as `ZeroOrMore` as the first and last element of your sequence. Think of it as the difference between Python's `re.match` and `re.fullmatch` functions. LibCST matchers behave like the latter so that it is possible to specify sequences which must start with, end with or be exactly equal to some pattern.\n\n`libcst.matchers.AtLeastN`\n`libcst.matchers.ZeroOrMore`\n`libcst.matchers.AtMostN`\n`libcst.matchers.ZeroOrOne`", "prompt_tokens": 2068, "completion_tokens": 1614, "total_tokens": 3682, "end_time": 1690380446}
{"id": 1, "start_time": 1690380905, "output": "Sections:\n\n1. Parsing\n   1. Overview\n   2. Available Functions\n   3. Example\n2. Syntax Errors\n   1. Overview\n   2. Class Details", "prompt_tokens": 321, "completion_tokens": 42, "total_tokens": 363, "end_time": 1690380905}
{"id": 3, "start_time": 1690380905, "output": "Sections:\n\n1. Best Practices\n2. Avoid `isinstance` when traversing\n3. Prefer `updated_node` when modifying trees\n4. Provide a `config` when generating code from templates", "prompt_tokens": 1863, "completion_tokens": 41, "total_tokens": 1904, "end_time": 1690380905}
{"id": 2, "start_time": 1690380905, "output": "# Experimental APIs\n\nThese APIs may change at any time (including in minor releases) with no notice. You probably shouldn't use them, but if you do, you should pin your application to an exact release of LibCST to avoid breakages.\n\n## Reentrant Code Generation\n\n- `libcst.metadata.ExperimentalReentrantCodegenProvider`\n- `libcst.metadata.CodegenPartial`", "prompt_tokens": 126, "completion_tokens": 78, "total_tokens": 204, "end_time": 1690380905}
{"id": 8, "start_time": 1690380907, "output": "Sections:\n1. Codemods\n2. Codemod Base\n3. Execution Interface\n4. Command-Line Support\n5. Command-Line Toolkit\n6. Library of Transforms", "prompt_tokens": 1939, "completion_tokens": 38, "total_tokens": 1977, "end_time": 1690380907}
{"id": 4, "start_time": 1690380905, "output": "Sections:\n\n1. Why LibCST?\n   - Introduction\n   \n2. Abstract Syntax Trees (AST)\n   - Python's AST for a code snippet\n   - Limitations of AST\n   \n3. Concrete Syntax Trees (CST)\n   - lib2to3 and its syntax tree\n   - Limitations of CST\n   \n4. LibCST\n   - Description of LibCST\n   - Example code snippet in LibCST\n   - Pros and cons of using LibCST", "prompt_tokens": 3053, "completion_tokens": 99, "total_tokens": 3152, "end_time": 1690380905}
{"id": 0, "start_time": 1690380905, "output": "Sections:\n\n1. Introduction\n   - README.rst (start-after: intro-start, end-before: intro-end)\n\n2. Tutorial\n   - Parsing and Visitors (tutorial)\n   - Metadata (metadata_tutorial)\n   - Scope Analysis (scope_tutorial)\n   - Matchers (matchers_tutorial)\n   - Codemodding (codemods_tutorial)\n   - Best Practices (best_practices)\n\n3. Reference\n   - parser\n   - nodes\n   - visitors\n   - metadata\n   - matchers\n   - codemods\n   - helpers\n   - experimental\n\n4. Indices and tables\n   - genindex\n   - modindex\n   - search\n\nAdditional Information:\n- README.rst (start-after: fb-docs-start, end-before: fb-docs-end)", "prompt_tokens": 321, "completion_tokens": 167, "total_tokens": 488, "end_time": 1690380905}
{"id": 11, "start_time": 1690380908, "output": "Sections:\n\n1. Introduction\n2. Matcher APIs\n   2.1 Functions\n   2.2 Decorators\n3. Traversal Order\n4. Matcher Types\n   4.1 Concrete Matchers\n   4.2 Special Matchers\n   4.3 Sequence Wildcard Matchers", "prompt_tokens": 2071, "completion_tokens": 62, "total_tokens": 2133, "end_time": 1690380909}
{"id": 7, "start_time": 1690380907, "output": "Sections:\n\n1. Motivation\n    1. Exact Representation\n    2. Nodes should be constructed exactly as written in code\n2. Ease of Traversal\n    1. As flat as possible\n    2. As regular as possible\n    3. As high-level as possible\n3. Ease of Modification\n    1. All nodes should be fully typed\n    2. Additional runtime constraints\n    3. Sane defaults\n    4. Reasonably intelligent ownership of whitespace\n    5. Easy to change a single field in an existing node\n    6. Reparentable\n4. Well Tested\n    1. All nodes should be fully tested", "prompt_tokens": 825, "completion_tokens": 145, "total_tokens": 970, "end_time": 1690380907}
{"id": 12, "start_time": 1690380910, "output": "Sections:\n\n1. Introduction\n2. Construction Helpers\n3. Transformation Helpers\n4. Traversing Helpers\n\nI apologize for the incorrect indentation and lack of section titles in the original documentation. Let me correct that for you.", "prompt_tokens": 253, "completion_tokens": 46, "total_tokens": 299, "end_time": 1690380910}
{"id": 9, "start_time": 1690380908, "output": "Sections:\n\n1. `Visitors`\n  a. `CSTVisitor`\n  b. `CSTTransformer`\n  c. `RemoveFromParent`\n  d. `RemovalSentinel`\n  e. `FlattenSentinel`\n\n2. `Visit and Leave Helper Functions`\n\n3. `Traversal Order`\n\n4. `Batched Visitors`\n  a. `BatchableCSTVisitor`\n  b. `visit_batched`", "prompt_tokens": 1249, "completion_tokens": 90, "total_tokens": 1339, "end_time": 1690380908}
{"id": 6, "start_time": 1690380905, "output": "Sections:\n\n1. Metadata\n  - Metadata APIs\n  \n2. Accessing Metadata\n  - MetadataWrapper\n  \n3. Providing Metadata\n  - BaseMetadataProvider\n  - BatchableMetadataProvider\n  - VisitorMetadataProvider\n\n4. Metadata Providers\n  - PositionProvider\n  - ByteSpanPositionProvider\n  - WhitespaceInclusivePositionProvider\n  - ExpressionContextProvider\n  - ScopeProvider\n  - QualifiedNameProvider\n  - ParentNodeProvider\n  - TypeInferenceProvider\n\n5. Position Metadata\n  - PositionProvider\n  - WhitespaceInclusivePositionProvider\n\n6. Byte offset and length pairs Metadata\n  - ByteSpanPositionProvider\n\n7. Expression Context Metadata\n  - ExpressionContextProvider\n\n8. Scope Metadata\n  - ScopeProvider\n  - BaseAssignment\n  - Access\n  - Assignment\n  - BuiltinAssignment\n  - Scope\n  - BuiltinScope\n  - GlobalScope\n  - FunctionScope\n  - ClassScope\n  - ComprehensionScope\n  - Assignments\n  - Accesses\n\n9. Qualified Name Metadata\n  - QualifiedNameProvider\n  - FullyQualifiedNameProvider\n\n10. Parent Node Metadata\n  - ParentNodeProvider\n\n11. File Path Metadata\n  - FilePathProvider\n\n12. Type Inference Metadata\n  - TypeInferenceProvider\n  - FullRepoManager", "prompt_tokens": 2271, "completion_tokens": 280, "total_tokens": 2551, "end_time": 1690380905}
{"id": 5, "start_time": 1690380905, "output": "Working With Codemods\n=====================\n\nCodemods are an abstraction on top of LibCST for performing large-scale changes to an entire codebase. \n\nSetting up and Running Codemods\n------------------------------\n\nTo set up and run codemods, follow these steps:\n\n1. Initialize your repository by running the following command in the root of your repository:\n\n```python\npython3 -m libcst.tool initialize .\n```\n\n2. Edit the produced \".libcst.codemod.yaml\" file to customize LibCST to your repository.\n\n3. Run the following command from the root of your repository to see the available codemods:\n\n```python\npython3 -m libcst.tool list\n```\n\n4. Choose a codemod from the list and execute it by running the following command:\n\n```python\npython3 -m libcst.tool codemod <codemod_command> .\n```\n\nReplace `<codemod_command>` with the specific command for the codemod you want to run.\n\nWriting a Codemod\n-----------------\n\nTo write a codemod, follow these steps:\n\n1. Import the necessary modules and packages.\n\n2. Define a class for your codemod that inherits from the `VisitorBasedCodemodCommand` class.\n\n3. Set the description and command-line arguments for your codemod using the `DESCRIPTION` and `add_args` methods.\n\n4. Implement the necessary methods in your codemod class to perform the desired transformations.\n\nTesting Codemods\n----------------\n\nTo test a codemod, follow these steps:\n\n1. Create a test class that inherits from the `CodemodTest` class.\n\n2. Define test methods in the test class to validate the transformations made by the codemod.\n\n3. Use the `assertCodemod` method provided by the `CodemodTest` class to compare the expected and actual code after running the codemod.\n\n4. Run the tests using a test runner, such as `unittest`, to ensure that the codemod is working correctly.\n\nThat's all there is to working with codemods in LibCST!", "prompt_tokens": 1882, "completion_tokens": 435, "total_tokens": 2317, "end_time": 1690380905}
{"id": 10, "start_time": 1690380908, "output": "Sections:\n\n1. Nodes\n2. CSTNode\n3. Module\n4. Expressions\n    - BaseExpression\n    - Name\n    - Attribute\n    - UnaryOperation\n    - BinaryOperation\n    - BooleanOperation\n    - Comparison\n    - ComparisonTarget\n5. Control Flow\n    - Asynchronous\n    - Await\n    - Yield\n    - From\n    - IfExp\n6. Lambdas and Function Calls\n    - Lambda\n    - Call\n    - Arg\n7. Literal Values\n    - Ellipsis\n8. Numbers\n    - BaseNumber\n    - Integer\n    - Float\n    - Imaginary\n9. Strings\n    - BaseString\n    - SimpleString\n    - ConcatenatedString\n10. Formatted Strings (f-strings)\n    - FormattedString\n    - BaseFormattedStringContent\n    - FormattedStringText\n    - FormattedStringExpression\n11. Collections\n    - Simple Collections\n        - Tuple\n        - BaseList\n        - List\n        - BaseSet\n        - Set\n    - Simple Collection Elements\n        - BaseElement\n        - Element\n        - StarredElement\n    - Dictionaries\n        - BaseDict\n        - Dict\n    - Dictionary Elements\n        - BaseDictElement\n        - DictElement\n        - StarredDictElement\n12. Comprehensions\n    - BaseComp\n    - BaseSimpleComp\n    - GeneratorExp\n    - ListComp\n    - SetComp\n    - DictComp\n    - CompFor\n    - CompIf\n13. Subscripts and Slices\n    - Subscript\n    - BaseSlice\n    - Index\n    - Slice\n    - SubscriptElement\n14. Parenthesis, Brackets, and Braces\n    - LeftParen\n    - RightParen\n    - LeftSquareBracket\n    - RightSquareBracket\n    - LeftCurlyBrace\n    - RightCurlyBrace\n15. Statements\n    - BaseSmallStatement\n    - AnnAssign\n    - Assert\n    - Assign\n    - AugAssign\n    - Break\n    - Continue\n    - Del\n    - Expr\n    - Global\n    - Import\n    - ImportFrom\n    - Nonlocal\n    - Pass\n    - Raise\n    - Return\n    - BaseCompoundStatement\n    - ClassDef\n    - For\n    - FunctionDef\n    - If\n    - Try\n    - While\n    - With\n16. Helper Nodes\n    - Annotation\n    - AsName\n    - AssignTarget\n    - BaseAssignTargetExpression\n    - BaseDelTargetExpression\n    - Decorator\n    - Else\n    - ExceptHandler\n    - Finally\n    - ImportAlias\n    - NameItem\n    - Parameters\n    - Param\n    - ParamSlash\n    - ParamStar\n    - WithItem\n    - BaseSuite\n    - SimpleStatementLine\n    - SimpleStatementSuite\n    - IndentedBlock\n17. Operators\n    - Unary Operators\n        - BitInvert\n        - Minus\n        - Not\n        - Plus\n        - BaseUnaryOp\n    - Boolean Operators\n        - And\n        - Or\n        - BaseBooleanOp\n    - Binary Operators\n        - Add\n        - BitAnd\n        - BitOr\n        - BitXor\n        - Divide\n        - FloorDivide\n        - LeftShift\n        - MatrixMultiply\n        - Modulo\n        - Multiply\n        - Power\n        - RightShift\n        - Subtract\n        - BaseBinaryOp\n    - Comparison Operators\n        - Equal\n        - GreaterThan\n        - GreaterThanEqual\n        - In\n        - Is\n        - LessThan\n        - LessThanEqual\n        - NotEqual\n        - IsNot\n        - NotIn\n        - BaseCompOp\n    - Augmented Assignment Operators\n        - AddAssign\n        - BitAndAssign\n        - BitOrAssign\n        - BitXorAssign\n        - DivideAssign\n        - FloorDivideAssign\n        - LeftShiftAssign\n        - MatrixMultiplyAssign\n        - ModuloAssign\n        - MultiplyAssign\n        - PowerAssign\n        - RightShiftAssign\n        - SubtractAssign\n        - BaseAugOp\n18. Miscellaneous\n    - AssignEqual\n    - Colon\n    - Comma\n    - Dot\n    - ImportStar\n    - Semicolon\n19. Whitespace\n    - Comment\n    - EmptyLine\n    - Newline\n    - ParenthesizedWhitespace\n    - SimpleWhitespace\n    - TrailingWhitespace\n    - BaseParenthesizableWhitespace\n20. Maybe Sentinel\n    - MaybeSentinel", "prompt_tokens": 2509, "completion_tokens": 989, "total_tokens": 3498, "end_time": 1690380909}
