{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":".. LibCST documentation master file, created by\n   sphinx-quickstart on Wed Jul 17 17:05:21 2019.\n   You can adapt this file completely to your liking, but it should at least\n   contain the root `toctree` directive.\n\n======\nLibCST\n======\n\n.. include:: ../../README.rst\n    :start-after: intro-start\n    :end-before: intro-end\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Introduction:\n\n   why_libcst\n   motivation\n\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Tutorial:\n\n   Parsing and Visitors <tutorial>\n   Metadata <metadata_tutorial>\n   Scope Analysis <scope_tutorial>\n   Matchers <matchers_tutorial>\n   Codemodding <codemods_tutorial>\n   Best Practices <best_practices>\n\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Reference:\n\n   parser\n   nodes\n   visitors\n   metadata\n   matchers\n   codemods\n   helpers\n   experimental\n\n\n\nIndices and tables\n==================\n\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\n\n\n.. include:: ../../README.rst\n    :start-after: fb-docs-start\n    :end-before: fb-docs-end\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":"Parsing\n=======\n\nThe parser functions accept source code and an optional configuration object,\nand will generate :class:`~libcst.CSTNode` objects.\n\n:func:`~libcst.parse_module` is the most useful function here, since it accepts\nthe entire contents of a file and returns a new tree, but\n:func:`~libcst.parse_expression` and :func:`~libcst.parse_statement` are useful\nwhen inserting new nodes into the tree, because they're easier to use than the\nequivalent node constructors.\n\n>>> import libcst as cst\n>>> cst.parse_expression(\"1 + 2\")\nBinaryOperation(\n    left=Integer(\n        value='1',\n        lpar=[],\n        rpar=[],\n    ),\n    operator=Add(\n        whitespace_before=SimpleWhitespace(\n            value=' ',\n        ),\n        whitespace_after=SimpleWhitespace(\n            value=' ',\n        ),\n    ),\n    right=Integer(\n        value='2',\n        lpar=[],\n        rpar=[],\n    ),\n    lpar=[],\n    rpar=[],\n)\n\n\n.. autofunction:: libcst.parse_module\n.. autofunction:: libcst.parse_expression\n.. autofunction:: libcst.parse_statement\n.. autoclass:: libcst.PartialParserConfig\n\nSyntax Errors\n-------------\n\n.. autoclass:: libcst.ParserSyntaxError\n   :members: message, raw_line, raw_column, editor_line, editor_column\n   :special-members: __str__\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":".. _libcst-experimental:\n\n=================\nExperimental APIs\n=================\n\nThese APIs may change at any time (including in minor releases) with no notice. You \nprobably shouldn't use them, but if you do, you should pin your application to an exact\nrelease of LibCST to avoid breakages.\n\nReentrant Code Generation\n-------------------------\n\n.. autoclass:: libcst.metadata.ExperimentalReentrantCodegenProvider\n.. autoclass:: libcst.metadata.CodegenPartial\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":"==============\nBest Practices\n==============\n\nWhile there are plenty of ways to interact with LibCST, we recommend some patterns\nover others. Various best practices are laid out here along with their justifications.\n\nAvoid ``isinstance`` when traversing\n------------------------------------\n\nExcessive use of ``isinstance`` implies that you should rewrite your check as a\nmatcher or unroll it into a set of visitor methods. Often, you should make use of\n:func:`~libcst.ensure_type` to make your type checker aware of a node's type.\n\nOften it is far easier to use :ref:`libcst-matchers` over explicit instance checks\nin a transform. Matching against some pattern and then extracting a value from a\nnode's child is often easier and far more readable. Unfortunately this clashes with\nvarious type-checkers which do not understand that :func:`~libcst.matchers.matches`\nguarantees a particular set of children. Instead of instance checks, you should use\n:func:`~libcst.ensure_type` which can be inlined and nested.\n\nFor example, if you have written the following::\n\n    def get_identifier_name(node: cst.CSTNode) -> Optional[str]:\n        if m.matches(node, m.Name()):\n            assert isinstance(node, cst.Name)\n            return node.value\n        return None\n\nYou could instead write something like::\n\n    def get_identifier_name(node: cst.CSTNode) -> Optional[str]:\n        return (\n            cst.ensure_type(node, cst.Name).value\n            if m.matches(node, m.Name())\n            else None\n        )\n\nIf you find yourself attempting to manually traverse a tree using ``isinstance``,\nyou can often rewrite your code using visitor methods instead. Nested instance checks\ncan often be unrolled into visitors methods along with matcher decorators. This may\nentail adding additional state to your visitor, but the resulting code is far more\nlikely to work after changes to LibCST itself. For example, if you have written the\nfollowing::\n\n    class CountBazFoobarArgs(cst.CSTVisitor):\n        \"\"\"\n        Given a set of function names, count how many arguments to those function\n        calls are the identifiers \"baz\" or \"foobar\".\n        \"\"\"\n\n        def __init__(self, functions: Set[str]) -> None:\n            super().__init__()\n            self.functions: Set[str] = functions\n            self.arg_count: int = 0\n\n        def visit_Call(self, node: cst.Call) -> None:\n            # See if the call itself is one of our functions we care about\n            if isinstance(node.func, cst.Name) and node.func.value in self.functions:\n                # Loop through each argument\n                for arg in node.args:\n                    # See if the argument is an identifier matching what we want to count\n                    if isinstance(arg.value, cst.Name) and arg.value.value in {\"baz\", \"foobar\"}:\n                        self.arg_count += 1\n                        \nYou could instead write something like::\n\n    class CountBazFoobarArgs(m.MatcherDecoratableVisitor):\n        \"\"\"\n        Given a set of function names, count how many arguments to those function\n        calls are the identifiers \"baz\" or \"foobar\".\n        \"\"\"\n\n        def __init__(self, functions: Set[str]) -> None:\n            super().__init__()\n            self.functions: Set[str] = functions\n            self.arg_count: int = 0\n            self.call_stack: List[str] = []\n\n        def visit_Call(self, node: cst.Call) -> None:\n            # Store all calls in a stack\n            if m.matches(node.func, m.Name()):\n                self.call_stack.append(cst.ensure_type(node.func, cst.Name).value)\n\n        def leave_Call(self, original_node: cst.Call) -> None:\n            # Pop the latest call off the stack\n            if m.matches(node.func, m.Name()):\n                self.call_stack.pop()\n\n        @m.visit(m.Arg(m.Name(\"baz\") | m.Name(\"foobar\")))\n        def _count_args(self, node: cst.Arg) -> None:\n            # See if the most shallow call is one we're interested in, so we can\n            # count the args we care about only in calls we care about.\n            if self.call_stack[-1] in self.functions:\n                self.arg_count += 1\n\nWhile there is more code than the previous example, it is arguably easier to understand\nand maintain each part of the code. It is also immune to any future changes to LibCST\nwhich change's the tree shape. Note that LibCST is traversing the tree completely\nin both cases, so while the first appears to be faster, it is actually doing the same\namount of work as the second.\n\nPrefer ``updated_node`` when modifying trees\n--------------------------------------------\n\nWhen you are using :class:`~libcst.CSTTransformer` to modify a LibCST tree, only return\nmodifications to ``updated_node``. The ``original_node`` parameter on any\n``leave_<Node>`` method is provided for book-keeping and is guaranteed to be\nequal via ``==`` and ``is`` checks to the ``node`` parameter in the corresponding\n``visit_<Node>`` method. Remember that LibCST trees are immutable, so the only\nway to make a modification is to return a new tree. Hence, by the time we get to\ncalling ``leave_<Node>`` methods, we have an updated tree whose children have been\nmodified. Therefore, you should only return ``original_node`` when you want to\nexplicitly discard changes performed on the node's children.\n\nSay you wanted to rename all function calls which were calling global functions.\nSo, you might write the following::\n\n    class FunctionRenamer(cst.CSTTransformer):\n        def leave_Call(self, original_node: cst.Call, updated_node: cst.Call) -> cst.Call:\n            if m.matches(original_node.func, m.Name()):\n                return original_node.with_changes(\n                    func=cst.Name(\n                        \"renamed_\" + cst.ensure_type(original_node.func, cst.Name).value\n                    )\n                )\n            return original_node\n\nConsider writing instead::\n\n    class FunctionRenamer(cst.CSTTransformer):\n        def leave_Call(self, original_node: cst.Call, updated_node: cst.Call) -> cst.Call:\n            if m.matches(updated_node.func, m.Name()):\n                return updated_node.with_changes(\n                    func=cst.Name(\n                        \"renamed_\" + cst.ensure_type(updated_node.func, cst.Name).value\n                    )\n                )\n            return updated_node\n\nThe version that returns modifications to ``original_node`` has a subtle bug. Consider\nthe following code snippet::\n\n    some_func(1, 2, other_func(3))\n\nRunning the recommended transform will return us a new code snippet that looks like this::\n\n    renamed_some_func(1, 2, renamed_other_func(3))\n\nHowever, running the version which modifies ``original_node`` will instead return::\n\n    renamed_some_func(1, 2, other_func(3))\n\nThat's because the ``updated_node`` tree contains the modification to ``other_func``.\nBy returning modifications to ``original_node`` instead of ``updated_node``, we accidentally\ndiscarded all the work done deeper in the tree.\n\n.. _libcst-config_best_practice:\n\nProvide a ``config`` when generating code from templates\n--------------------------------------------------------\n\nWhen generating complex trees it is often far easier to pass a string to\n:func:`~libcst.parse_statement` or :func:`~libcst.parse_expression` than it is to\nmanually construct the tree. When using these functions to generate code, you should\nalways use the ``config`` parameter in order to generate code that matches the\ndefaults of the module you are modifying. The :class:`~libcst.Module` class even has\na helper attribute :attr:`~libcst.Module.config_for_parsing` to make it easy to use. This\nensures that line endings and indentation are consistent with the defaults in the\nmodule you are adding the code to.\n\nFor example, to add a print statement to the end of a module::\n\n    module = cst.parse_module(some_code_string)\n    new_module = module.with_changes(\n        body=(\n            *module.body,\n            cst.parse_statement(\n                \"print('Hello, world!')\",\n                config=module.config_for_parsing,\n            ),\n        ),\n    )\n    new_code_string = new_module.code\n\nLeaving out the ``config`` parameter means that LibCST will assume some defaults\nand could result in added code which is formatted differently than the rest of the\nmodule it was added to. In the above example, because we used the config from the\nalready-parsed example, the print statement will be added with line endings matching\nthe rest of the module. If we neglect the ``config`` parameter, we might accidentally\ninsert a windows line ending into a unix file or vice versa, depending on what system\nwe ran the code under.\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":"===========\nWhy LibCST?\n===========\n\n**Python's ast module already provides a syntax tree. Why do we need another?**\n\n.. include:: ../../README.rst\n    :start-after: why-libcst-intro-start\n    :end-before: why-libcst-intro-end\n\nAbstract Syntax Trees (AST)\n===========================\n\nLet's look at Python's AST for the following code snippet::\n\n    fn(1, 2)  # calls fn\n\n.. container:: toggle\n\n    .. code-block:: python\n\n        ast.Module(\n            body=[\n                ast.Expr(\n                    value=ast.Call(\n                        func=ast.Name(\"fn\", ctx=ast.Load()),\n                        args=[ast.Num(n=1), ast.Num(n=2)],\n                        keywords=[],\n                    ),\n                ),\n            ],\n        )\n\n.. graphviz::\n\n    digraph ast {\n        layout=dot;\n        rankdir=LR;\n        splines=polyline;\n        ranksep=.6;\n        nodesep=.4;\n        dpi=300;\n        bgcolor=transparent;\n        node [\n            style=filled,\n            color=\"#fb8d3f\",\n            fontcolor=\"#4b4f54\",\n            fillcolor=\"#fdd2b3\",\n            fontname=\"Source Code Pro Semibold\",\n            penwidth=\"2\",\n        ];\n        edge [\n            color=\"#999999\",\n            fontcolor=\"#4b4f54\",\n            fontname=\"Source Code Pro Semibold\",\n            fontsize=12,\n            penwidth=2,\n        ];\n        Name [label=\" Name('fn') \"];\n        Load [label=\" Load() \"];\n        Num1 [label=\" Num(n=1) \"];\n        Num2 [label=\" Num(n=2) \"];\n        Module -> Expr [label=\"body[0]\"]\n        Expr -> Call [label=\"value\"]\n        Call -> Name [label=\"func\"]\n        Name -> Load [label=\"ctx\"]\n        Call -> Num1 [label=\"args[0]\"]\n        Call -> Num2 [label=\"args[1]\"]\n    }\n\nThis syntax tree does a great job of preserving the semantics of the original code, and the structure of the tree is relatively simple.\n\nHowever, given only the AST, it wouldn't be possible to reprint the original source code. `Like a JPEG <https://www.youtube.com/watch?v=j5nZhf8SjXw>`_, the Abstract Syntax Tree is lossy.\n\n- The comment we left at the line is gone.\n- There's a newline at the end of the file, but the AST doesn't tell us that. It also doesn't tell us if it's ``\\n``, ``\\r``, or ``\\r\\n``.\n- We've lost some information about the whitespace between the first and second argument.\n\nAbstract Syntax Trees are good for tools like compilers and type checkers where the semantics of code is important, but the exact syntax isn't.\n\n\nConcrete Syntax Trees (CST)\n===========================\n\nA popular CST library for Python is `lib2to3 <https://github.com/python/cpython/tree/master/Lib/lib2to3>`_, which powers tools like `2to3 <https://docs.python.org/3/library/2to3.html>`_ and `Black <https://github.com/ambv/black>`_. Let's look at the syntax tree it generates for the same piece of code::\n\n    fn(1, 2)  # calls fn\n\n.. container:: toggle\n\n    .. code-block:: python\n    \n        Node(\n            file_input,\n            children=[\n                Node(\n                    simple_stmt,\n                    children=[\n                        Node(\n                            power,\n                            children=[\n                                Leaf(NAME, \"fn\", prefix=\"\"),\n                                Node(\n                                    trailer,\n                                    children=[\n                                        Leaf(LPAR, \"(\", prefix=\"\"),\n                                        Node(\n                                            arglist,\n                                            children=[\n                                                Leaf(NUMBER, \"1\", prefix=\"\"),\n                                                Leaf(COMMA, \",\", prefix=\"\"),\n                                                Leaf(NUMBER, \"2\", prefix=\" \"),\n                                            ],\n                                        ),\n                                        Leaf(RPAR, \")\", prefix=\"\"),\n                                    ],\n                                ),\n                            ],\n                        ),\n                        Leaf(\n                            NEWLINE,\n                            \"\\n\",\n                            prefix=\"  # calls fn\",\n                        ),\n                    ],\n                    prefix=\"\"\n                ),\n                Leaf(ENDMARKER, \"\", prefix=\"\"),\n            ],\n            prefix=\"\",\n        )\n\n.. graphviz::\n\n    digraph cst {\n        layout=dot;\n        rankdir=TB;\n        ordering=out;\n        splines=line;\n        ranksep=.3;\n        nodesep=.3;\n        dpi=300;\n        bgcolor=transparent;\n        node [\n            style=filled,\n            color=\"#fb8d3f\",\n            fontcolor=\"#4b4f54\",\n            fillcolor=\"#fdd2b3\",\n            fontname=\"Source Code Pro Semibold\",\n            penwidth=\"2\",\n            group=main,\n        ];\n        edge [\n            color=\"#999999\",\n            fontcolor=\"#4b4f54\",\n            fontname=\"Source Code Pro Semibold\",\n            fontsize=12,\n            penwidth=2,\n        ];\n        ENDMARKER [label=\" ENDMARKER('') \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        NAME_fn [label=\" NAME('fn') \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        LPAR [label=\" LPAR('(') \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        NUMBER_1 [label=\" NUMBER('1') \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        COMMA [label=\" COMMA(',') \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        NUMBER_2 [label=\" NUMBER('2', prefix=' ') \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        RPAR [label=\" RPAR(')') \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        NEWLINE [label=\"  NEWLINE('\\\\n', prefix='  # calls fn')  \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        file_input -> simple_stmt [label=\"0\"]\n        file_input -> ENDMARKER [label=\"1\"]\n        simple_stmt -> power [label=\"0\"]\n        simple_stmt -> NEWLINE [label=\"1\"]\n        power -> NAME_fn [label=\"0\"];\n        power -> trailer [label=\"1\"];\n        trailer -> LPAR [label=\"0\"];\n        trailer -> NUMBER_1 [label=\"1\"];\n        trailer -> COMMA [label=\"2\"];\n        trailer -> NUMBER_2 [label=\"3\"];\n        trailer -> RPAR [label=\"4\"];\n    }\n\nThis tree is lossless. It retains enough information to reprint the exact input code by storing whitespace information in ``prefix`` properties. This makes it a \"Concrete\" Syntax Tree, or CST.\n\nHowever, much of the semantics of the code is now difficult to understand and extract. lib2to3 presents a tree that closely matches `Python's grammar <https://docs.python.org/3/reference/grammar.html>`_ which can be hard to manipulate for complex operations.\n\n- Adding or removing a parameter from ``fn`` requires careful preservation of ``COMMA`` nodes.\n- Whitespace and comment ownership is unclear. Deleting nodes could result in invalid generated code.\n\nConcrete Syntax Trees are good for operations that don't significantly change the tree and tools that do not wish to change the semantics of the code itself, such as `Black <https://github.com/ambv/black>`_.\n\nLibCST\n======\n\nLibCST takes a compromise between the two formats outlined above. Like a CST, LibCST preserves all whitespace and can be reprinted exactly. Like an AST, LibCST parses source into nodes that represent the semantics of the code.\n\n.. code-block:: python\n\n    fn(1, 2)  # calls fn\n\n.. container:: toggle\n\n    .. code-block:: python\n\n        Module(\n            body=[\n                SimpleStatementLine(\n                    body=[\n                        Expr(\n                            value=Call(\n                                func=Name(\n                                    value='fn',\n                                    lpar=[],\n                                    rpar=[],\n                                ),\n                                args=[\n                                    Arg(\n                                        value=Integer(\n                                            value='1',\n                                            lpar=[],\n                                            rpar=[],\n                                        ),\n                                        keyword=None,\n                                        equal=MaybeSentinel.DEFAULT,\n                                        comma=Comma(\n                                            whitespace_before=SimpleWhitespace(\n                                                value='',\n                                            ),\n                                            whitespace_after=SimpleWhitespace(\n                                                value=' ',\n                                            ),\n                                        ),\n                                        star='',\n                                        whitespace_after_star=SimpleWhitespace(\n                                            value='',\n                                        ),\n                                        whitespace_after_arg=SimpleWhitespace(\n                                            value='',\n                                        ),\n                                    ),\n                                    Arg(\n                                        value=Integer(\n                                            value='2',\n                                            lpar=[],\n                                            rpar=[],\n                                        ),\n                                        keyword=None,\n                                        equal=MaybeSentinel.DEFAULT,\n                                        comma=MaybeSentinel.DEFAULT,\n                                        star='',\n                                        whitespace_after_star=SimpleWhitespace(\n                                            value='',\n                                        ),\n                                        whitespace_after_arg=SimpleWhitespace(\n                                            value='',\n                                        ),\n                                    ),\n                                ],\n                                lpar=[],\n                                rpar=[],\n                                whitespace_after_func=SimpleWhitespace(\n                                    value='',\n                                ),\n                                whitespace_before_args=SimpleWhitespace(\n                                    value='',\n                                ),\n                            ),\n                            semicolon=MaybeSentinel.DEFAULT,\n                        ),\n                    ],\n                    leading_lines=[],\n                    trailing_whitespace=TrailingWhitespace(\n                        whitespace=SimpleWhitespace(\n                            value='  ',\n                        ),\n                        comment=Comment(\n                            value='# calls fn',\n                        ),\n                        newline=Newline(\n                            value=None,\n                        ),\n                    ),\n                ),\n            ],\n            header=[],\n            footer=[],\n            encoding='utf-8',\n            default_indent='    ',\n            default_newline='\\n',\n            has_trailing_newline=True,\n        )\n\n.. graphviz::\n\n    digraph libcst {\n        layout=dot;\n        rankdir=TB;\n        splines=line;\n        ranksep=0.5;\n        nodesep=1.0;\n        dpi=300;\n        bgcolor=transparent;\n        node [\n            style=filled,\n            color=\"#fb8d3f\",\n            fontcolor=\"#4b4f54\",\n            fillcolor=\"#fdd2b3\",\n            fontname=\"Source Code Pro Semibold\",\n            penwidth=\"2\",\n            group=main,\n        ];\n        edge [\n            color=\"#999999\",\n            fontcolor=\"#4b4f54\",\n            fontname=\"Source Code Pro Semibold\",\n            fontsize=12,\n            penwidth=2,\n        ];\n        Module [label=\"Module\"];\n        SimpleStatementLine [label=\"SimpleStatementLine\"];\n        Expr [label=\"Expr\"];\n        Call [label=\"Call\"];\n        Name [label=\"Name\"];\n        NameValue [label=\" 'fn' \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        Arg1 [label=\"Arg\"];\n        Integer1 [label=\"Integer\"];\n        Integer1Value [label=\" '1' \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        Comma [label=\"Comma\"];\n        SimpleWhitespace2 [label=\"SimpleWhitespace\", color=\"#777777\", fillcolor=\"#eeeeee\"];\n        SimpleWhitespace2Value [label=\" ' ' \", color=\"#777777\", fillcolor=\"#cccccc\", shape=box];\n        Arg2 [label=\"Arg\"];\n        Integer2 [label=\"Integer\"];\n        Integer2Value [label=\" '2' \", color=\"#3e99ed\", fillcolor=\"#b8d9f8\", shape=box];\n        TrailingWhitespace [label=\"TrailingWhitespace\", color=\"#777777\", fillcolor=\"#eeeeee\"];\n        SimpleWhitespace1 [label=\"SimpleWhitespace\", color=\"#777777\", fillcolor=\"#eeeeee\"];\n        SimpleWhitespace1Value [label=\" '  ' \", color=\"#777777\", fillcolor=\"#cccccc\", shape=box];\n        Comment1 [label=\"Comment\", color=\"#777777\", fillcolor=\"#eeeeee\"];\n        Comment1Value [label=\" '# calls fn' \", color=\"#777777\", fillcolor=\"#cccccc\", shape=box];\n\n        Module -> SimpleStatementLine [label=\"body[0]\"];\n        SimpleStatementLine -> Expr [label=\"body[0]\"];\n        Expr -> Call [label=\"value\"];\n        Call -> Name [label=\"func\"];\n        Name -> NameValue [label=\"value\"];\n        Call -> Arg1 [label=\"args[0]\"];\n        Arg1 -> Integer1 [label=\"value\"];\n        Integer1 -> Integer1Value [label=\"value\"];\n        Arg1 -> Comma [label=\"comma\"];\n        Comma -> SimpleWhitespace2 [label=\"whitespace_after\"];\n        SimpleWhitespace2 -> SimpleWhitespace2Value [label=\"value\"];\n        Call -> Arg2 [label=\"args[1]\"];\n        Arg2 -> Integer2 [label=\"value\"];\n        Integer2 -> Integer2Value [label=\"value\"];\n        SimpleStatementLine -> TrailingWhitespace [label=\"trailing_whitespace\"];\n        TrailingWhitespace -> SimpleWhitespace1 [label=\"whitespace\"];\n        SimpleWhitespace1 -> SimpleWhitespace1Value [label=\"value\"];\n        TrailingWhitespace -> Comment1 [label=\"comment\"];\n        Comment1 -> Comment1Value [label=\"value\"];\n    }\n\nLibCST preserves whitespace by parsing it using an internal whitespace parser and assigning it to relevant nodes. This allows for much more granular whitespace ownership and greatly reduces the amount of work necessary to perform complex manipulations. Additionally, it is fully typed. A node's children are well-defined and match the semantics of Python.\n\nHowever, this does come with some downsides.\n\n- It is more difficult to implement tools that focus almost exclusively on whitespace on top of LibCST instead of lib2to3. For example, `Black <https://github.com/ambv/black>`_ would need to modify whitespace nodes instead of prefix strings, making its implementation much more complex.\n- The equivalent AST for a Python module will usually be simpler. We must preserve whitespace ownership by assigning it to nodes that make the most sense which requires us to introduce nodes such as :class:`~libcst.Comma`.\n- Parsing with LibCST will always be slower than Python's AST due to the extra work needed to assign whitespace correctly.\n\nNevertheless, we think that the trade-offs made in LibCST are worthwhile and offer a great deal of flexibility and power.\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":"=====================\nWorking With Codemods\n=====================\n\nCodemods are an abstraction on top of LibCST for performing large-scale changes\nto an entire codebase. See :doc:`Codemods <codemods>` for the complete\ndocumentation.\n\n-------------------------------\nSetting up and Running Codemods\n-------------------------------\n\nLet's say you were interested in converting legacy ``.format()`` calls to shiny new\nPython 3.6 f-strings. LibCST ships with a command-line interface known as\n``libcst.tool``. This includes a few provisions for working with codemods at the\ncommand-line. It also includes a library of pre-defined codemods, one of which is\na transform that can convert most ``.format()`` calls to f-strings. So, let's use this\nto give Python 3.6 f-strings a try.\n\n\nYou might be lucky enough that the defaults for LibCST perfectly match your coding\nstyle, but chances are you want to customize LibCST to your repository. Initialize\nyour repository by running the following command in the root of your repository and\nthen edit the produced ``.libcst.codemod.yaml`` file::\n\n    python3 -m libcst.tool initialize .\n\nThe file includes provisions for customizing any generated code marker, calling an\nexternal code formatter such as `black <https://pypi.org/project/black/>`_, blackisting\npatterns of files you never wish to touch and a list of modules that contain valid\ncodemods that can be executed. If you want to write and run codemods specific to your\nrepository or organization, you can add an in-repo module location to the list of\nmodules and LibCST will discover codemods in all locations.\n\nNow that your repository is initialized, let's have a quick look at what's currently\navailable for running. Run the following command from the root of your repository::\n\n    python3 -m libcst.tool list\n\nYou'll see several codemods available to you, one of which is\n``convert_format_to_fstring.ConvertFormatStringCommand``. The description to the right\nof this codemod indicates that it converts ``.format()`` calls to f-strings, so let's\ngive it a whirl! Execute the codemod from the root of your repository like so::\n\n    python3 -m libcst.tool codemod convert_format_to_fstring.ConvertFormatStringCommand .\n\nIf you want to try it out on only one file or a specific subdirectory, you can replace\nthe ``.`` in the above command with a relative directory, file, list of directories or\nlist of files. While LibCST is walking through your repository and codemodding files\nyou will see a progress indicator. If there's anything the codemod can't do or any\nunexpected syntax errors, you will also see them on your console as it progresses.\n\nIf everything works out, you'll notice that your ``.format()`` calls have been\nconverted to f-strings!\n\n-----------------\nWriting a Codemod\n-----------------\n\nCodemods use the same principles as the rest of LibCST. They take LibCST's core,\nmetadata and matchers and package them up as a simple command-line interface. So,\nanything you can do with LibCST in isolation you can also do with a codemod.\n\nLet's say you need to clean up some legacy code which used magic values instead\nof constants. You've already got a constants module called ``utils.constants``\nand you want to assume that every reference to a raw string matching a particular\nconstant should be converted to that constant. For the simplest version of this\ncodemod, you'll need a command-line tool that takes as arguments the string to\nreplace and the constant to replace it with. You'll also need to ensure that\nmodified modules import the constant itself.\n\nSo, you can write something similar to the following::\n\n    import argparse\n    from ast import literal_eval\n    from typing import Union\n\n    import libcst as cst\n    from libcst.codemod import CodemodContext, VisitorBasedCodemodCommand\n    from libcst.codemod.visitors import AddImportsVisitor\n\n\n    class ConvertConstantCommand(VisitorBasedCodemodCommand):\n\n        # Add a description so that future codemodders can see what this does.\n        DESCRIPTION: str = \"Converts raw strings to constant accesses.\"\n\n        @staticmethod\n        def add_args(arg_parser: argparse.ArgumentParser) -> None:\n            # Add command-line args that a user can specify for running this\n            # codemod.\n            arg_parser.add_argument(\n                \"--string\",\n                dest=\"string\",\n                metavar=\"STRING\",\n                help=\"String contents that we should look for.\",\n                type=str,\n                required=True,\n            )\n            arg_parser.add_argument(\n                \"--constant\",\n                dest=\"constant\",\n                metavar=\"CONSTANT\",\n                help=\"Constant identifier we should replace strings with.\",\n                type=str,\n                required=True,\n            )\n\n        def __init__(self, context: CodemodContext, string: str, constant: str) -> None:\n            # Initialize the base class with context, and save our args. Remember, the\n            # \"dest\" for each argument we added above must match a parameter name in\n            # this init.\n            super().__init__(context)\n            self.string = string\n            self.constant = constant\n\n        def leave_SimpleString(\n            self, original_node: cst.SimpleString, updated_node: cst.SimpleString\n        ) -> Union[cst.SimpleString, cst.Name]:\n            if literal_eval(updated_node.value) == self.string:\n                # Check to see if the string matches what we want to replace. If so,\n                # then we do the replacement. We also know at this point that we need\n                # to import the constant itself.\n                AddImportsVisitor.add_needed_import(\n                    self.context, \"utils.constants\", self.constant,\n                )\n                return cst.Name(self.constant)\n            # This isn't a string we're concerned with, so leave it unchanged.\n            return updated_node\n\nThis codemod is pretty simple. It defines a command-line description, sets up to parse\na few required command-line args, initializes its own member variables with the\ncommand-line args that were parsed for it by ``libcst.tool codemod`` and finally\nreplaces any string which matches our string command-line argument with a constant.\nIt also takes care of adding the import required for the constant to be defined properly.\n\nCool! Let's look at the command-line help for this codemod. Let's assume you saved it\nas ``constant_folding.py`` inside ``libcst.codemod.commands``. You can get help for the\ncodemod by running the following command::\n\n    python3 -m libcst.tool codemod constant_folding.ConvertConstantCommand --help\n\nNotice that along with the default arguments, the ``--string`` and ``--constant``\narguments are present in the help, and the command-line description has been updated\nwith the codemod's description string. You'll notice that the codemod also shows up\non ``libcst.tool list``.\n\n----------------\nTesting Codemods\n----------------\n\nInstead of iterating on a codemod by running it repeatedly on a codebase and seeing\nwhat happens, we can write a series of unit tests that assert on desired\ntransformations. Given the above constant folding codemod that we wrote, we can test\nit with some code similar to the following::\n\n    from libcst.codemod import CodemodTest\n    from libcst.codemod.commands.constant_folding import ConvertConstantCommand\n\n\n    class TestConvertConstantCommand(CodemodTest):\n\n        # The codemod that will be instantiated for us in assertCodemod.\n        TRANSFORM = ConvertConstantCommand\n\n        def test_noop(self) -> None:\n            before = \"\"\"\n                foo = \"bar\"\n            \"\"\"\n            after = \"\"\"\n                foo = \"bar\"\n            \"\"\"\n\n            # Verify that if we don't have a valid string match, we don't make\n            # any substitutions.\n            self.assertCodemod(before, after, string=\"baz\", constant=\"BAZ\")\n\n        def test_substitution(self) -> None:\n            before = \"\"\"\n                foo = \"bar\"\n            \"\"\"\n            after = \"\"\"\n                from utils.constants import BAR\n\n                foo = BAR\n            \"\"\"\n\n            # Verify that if we do have a valid string match, we make a substitution\n            # as well as import the constant.\n            self.assertCodemod(before, after, string=\"bar\", constant=\"BAR\")\n\nIf we save this as ``test_constant_folding.py`` inside ``libcst.codemod.commands.tests``\nthen we can execute the tests with the following line::\n\n    python3 -m unittest libcst.codemod.commands.tests.test_constant_folding\n\nThat's all there is to it!\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":".. _libcst-metadata:\n\n========\nMetadata\n========\n\n-------------\nMetadata APIs\n-------------\n\nLibCST ships with a metadata interface that defines a standardized way to\nassociate nodes in a CST with arbitrary metadata while maintaining the immutability\nof the tree. The metadata interface is designed to be declarative and type safe.\nHere's a quick example of using the metadata interface to get line and column\nnumbers of nodes through the :class:`~libcst.metadata.PositionProvider`:\n\n.. _libcst-metadata-position-example:\n.. code-block:: python\n\n    class NamePrinter(cst.CSTVisitor):\n        METADATA_DEPENDENCIES = (cst.metadata.PositionProvider,)\n\n        def visit_Name(self, node: cst.Name) -> None:\n            pos = self.get_metadata(cst.metadata.PositionProvider, node).start\n            print(f\"{node.value} found at line {pos.line}, column {pos.column}\")\n\n    wrapper = cst.metadata.MetadataWrapper(cst.parse_module(\"x = 1\"))\n    result = wrapper.visit(NamePrinter())  # should print \"x found at line 1, column 0\"\n\nMore examples of using the metadata interface can be found on the\n:doc:`Metadata Tutorial <metadata_tutorial>`.\n\nAccessing Metadata\n------------------\n\nTo work with metadata you need to wrap a module with a :class:`~libcst.metadata.MetadataWrapper`.\nThe wrapper provides a :func:`~libcst.metadata.MetadataWrapper.resolve` function and a\n:func:`~libcst.metadata.MetadataWrapper.resolve_many` function to generate metadata.\n\n.. autoclass:: libcst.metadata.MetadataWrapper\n   :special-members: __init__\n\nIf you're working with visitors, which extend :class:`~libcst.MetadataDependent`,\nmetadata dependencies will be automatically computed when visited by a\n:class:`~libcst.metadata.MetadataWrapper` and are accessible through\n:func:`~libcst.MetadataDependent.get_metadata`\n\n.. autoclass:: libcst.MetadataDependent\n\nProviding Metadata\n------------------\n\nMetadata is generated through provider classes that can be be passed to\n:meth:`MetadataWrapper.resolve() <libcst.metadata.MetadataWrapper.resolve>` or\ndeclared as a dependency of a :class:`~libcst.metadata.MetadataDependent`. These\nproviders are then resolved automatically using methods provided by\n:class:`~libcst.metadata.MetadataWrapper`.\n\nIn most cases, you should extend\n:class:`~libcst.metadata.BatchableMetadataProvider` when writing a provider,\nunless you have a particular reason to not to use a batchable visitor. Only\nextend from :class:`~libcst.metadata.BaseMetadataProvider` if your provider does\nnot use the visitor pattern for computing metadata for a tree.\n\n.. autoclass:: libcst.BaseMetadataProvider\n.. autoclass:: libcst.metadata.BatchableMetadataProvider\n.. autoclass:: libcst.metadata.VisitorMetadataProvider\n\n.. _libcst-metadata-position:\n\n------------------\nMetadata Providers\n------------------\n:class:`~libcst.metadata.PositionProvider`,\n:class:`~libcst.metadata.ByteSpanPositionProvider`,\n:class:`~libcst.metadata.WhitespaceInclusivePositionProvider`,\n:class:`~libcst.metadata.ExpressionContextProvider`,\n:class:`~libcst.metadata.ScopeProvider`,\n:class:`~libcst.metadata.QualifiedNameProvider`,\n:class:`~libcst.metadata.ParentNodeProvider`, and\n:class:`~libcst.metadata.TypeInferenceProvider`\nare currently provided. Each metadata provider may has its own custom data structure.\n\nPosition Metadata\n-----------------\nThere are two types of position metadata available. They both track the same\nposition concept, but differ in terms of representation. One represents\nposition with line and column numbers, while the other outputs byte offset and\nlength pairs.\n\nLine and column numbers are available through the metadata interface by\ndeclaring one of :class:`~libcst.metadata.PositionProvider` or\n:class:`~libcst.metadata.WhitespaceInclusivePositionProvider`. For\nmost cases, :class:`~libcst.metadata.PositionProvider` is what you probably\nwant.\n\nNode positions are is represented with :class:`~libcst.metadata.CodeRange`\nobjects. See :ref:`the above example<libcst-metadata-position-example>`.\n\n.. autoclass:: libcst.metadata.PositionProvider\n.. autoclass:: libcst.metadata.WhitespaceInclusivePositionProvider\n\n.. autoclass:: libcst.metadata.CodeRange\n.. autoclass:: libcst.metadata.CodePosition\n\nByte offset and length pairs can be accessed using\n:class:`~libcst.metadata.ByteSpanPositionProvider`. This provider represents\npositions using :class:`~libcst.metadata.CodeSpan`, which will contain the\nbyte offsets of a :class:`~libcst.CSTNode` from the start of the file, and\nits length (also in bytes).\n\n.. autoclass:: libcst.metadata.ByteSpanPositionProvider\n\n.. autoclass:: libcst.metadata.CodeSpan\n\nExpression Context Metadata\n---------------------------\n.. autoclass:: libcst.metadata.ExpressionContextProvider\n   :no-undoc-members:\n\n.. autoclass:: libcst.metadata.ExpressionContext\n\n.. _libcst-scope-metadata:\n\nScope Metadata\n--------------\nScopes contain and separate variables from each other. Scopes enforce that a\nlocal variable name bound inside of a function is not available outside of that\nfunction.\n\nWhile many programming languages are \"block-scoped\", Python is\n`function-scoped <https://en.wikipedia.org/wiki/Scope_(computer_science)#Function_scope>`_.\nNew scopes are created for classes, functions, and comprehensions. Other block\nconstructs like conditional statements, loops, and try…except don't create their\nown scope.\n\nThere are five different type of scope in Python:\n:class:`~libcst.metadata.BuiltinScope`,\n:class:`~libcst.metadata.GlobalScope`,\n:class:`~libcst.metadata.ClassScope`,\n:class:`~libcst.metadata.FunctionScope`, and\n:class:`~libcst.metadata.ComprehensionScope`.\n\n.. image:: _static/img/python_scopes.png\n   :alt: Diagram showing how the above 5 scopes are nested in each other\n   :width: 400\n   :align: center\n\nLibCST allows you to inspect these scopes to see what local variables are\nassigned or accessed within.\n\n.. note::\n   Import statements bring new symbols into scope that are declared in other files.\n   As such, they are represented by :class:`~libcst.metadata.Assignment` for scope\n   analysis purposes. Dotted imports (e.g. ``import a.b.c``) generate multiple\n   :class:`~libcst.metadata.Assignment` objects — one for each module. When analyzing\n   references, only the most specific access is recorded.\n   \n   For example, the above ``import a.b.c`` statement generates three\n   :class:`~libcst.metadata.Assignment` objects: one for ``a``, one for ``a.b``, and\n   one for ``a.b.c``. A reference for ``a.b.c`` records an access only for the last\n   assignment, while a reference for ``a.d`` only records an access for the\n   :class:`~libcst.metadata.Assignment` representing ``a``.\n\n.. autoclass:: libcst.metadata.ScopeProvider\n   :no-undoc-members:\n\n.. autoclass:: libcst.metadata.BaseAssignment\n   :no-undoc-members:\n\n.. autoclass:: libcst.metadata.Access\n.. autoclass:: libcst.metadata.Assignment\n.. autoclass:: libcst.metadata.BuiltinAssignment\n\n.. autoclass:: libcst.metadata.Scope\n   :no-undoc-members:\n   :special-members: __contains__, __getitem__, __iter__\n\n.. autoclass:: libcst.metadata.BuiltinScope\n   :no-undoc-members:\n\n.. autoclass:: libcst.metadata.GlobalScope\n   :no-undoc-members:\n\n.. autoclass:: libcst.metadata.FunctionScope\n.. autoclass:: libcst.metadata.ClassScope\n.. autoclass:: libcst.metadata.ComprehensionScope\n\n.. autoclass:: libcst.metadata.Assignments\n   :special-members: __contains__, __getitem__, __iter__\n\n.. autoclass:: libcst.metadata.Accesses\n   :special-members: __contains__, __getitem__, __iter__\n\nQualified Name Metadata\n-----------------------\nQualified name provides an unambiguous name to locate the definition of variable and it's\nintroduced for class and function in `PEP-3155 <https://www.python.org/dev/peps/pep-3155/>`_.\nQualifiedNameProvider provides possible :class:`~libcst.metadata.QualifiedName` given a\n:class:`~libcst.CSTNode`.\n\nWe don't call it `fully qualified name <https://en.wikipedia.org/wiki/Fully_qualified_name>`_\nbecause the name refers to the current module which doesn't consider the hierarchy of\ncode repository.\n\nFor fully qualified names, there's :class:`~libcst.metadata.FullyQualifiedNameProvider`\nwhich is similar to the above but takes the current module's location (relative to some\npython root folder, usually the repository's root) into account.\n\n\n.. autoclass:: libcst.metadata.QualifiedNameSource\n.. autoclass:: libcst.metadata.QualifiedName\n.. autoclass:: libcst.metadata.QualifiedNameProvider\n   :no-undoc-members:\n   \n.. autoclass:: libcst.metadata.FullyQualifiedNameProvider\n   :no-undoc-members:\n\nParent Node Metadata\n--------------------\nA :class:`~libcst.CSTNode` only has attributes link to its child nodes and thus only top-down\ntree traversal is doable. Sometimes user may want to access the parent :class:`~libcst.CSTNode`\nfor more information or traverse in bottom-up manner.\nWe provide :class:`~libcst.metadata.ParentNodeProvider` for those use cases.\n\n.. autoclass:: libcst.metadata.ParentNodeProvider\n   :no-undoc-members:\n\nFile Path Metadata\n------------------\nThis provides the absolute file path on disk for any module being visited.\nRequires an active :class:`~libcst.metadata.FullRepoManager` when using this provider.\n\n.. autoclass:: libcst.metadata.FilePathProvider\n   :no-undoc-members:\n\nType Inference Metadata\n-----------------------\n`Type inference <https://en.wikipedia.org/wiki/Type_inference>`__ is to automatically infer\ndata types of expression for deeper understanding source code.\nIn Python, type checkers like `Mypy <https://github.com/python/mypy>`_ or\n`Pyre <https://pyre-check.org/>`__ analyze `type annotations <https://docs.python.org/3/library/typing.html>`__\nand infer types for expressions.\n:class:`~libcst.metadata.TypeInferenceProvider` is provided by `Pyre Query API <https://pyre-check.org/docs/querying-pyre.html>`__\nwhich requires `setup watchman <https://pyre-check.org/docs/getting-started/>`_ for incremental typechecking.\n:class:`~libcst.metadata.FullRepoManger` is built for manage the inter process communication to Pyre.\n\n.. autoclass:: libcst.metadata.TypeInferenceProvider\n   :no-undoc-members:\n\n.. autoclass:: libcst.metadata.FullRepoManager\n   :no-undoc-members:\n   :special-members: __init__\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":"==========\nMotivation\n==========\n\nWhen designing LibCST, we used the following list of motivations.\n\nExact Representation\n--------------------\n\n* **Trees should be rewritable.** It should always be possible to take a valid python file, parse it to a CST using LibCST and then write that tree back out exactly, byte for byte. When changing nodes in the tree, changes to the original source file should be localized to the area represented by the changed portion of the tree. Effectively, for all valid python inputs, the following equation should be true::\n\n    parse_module(some_input).code == some_input\n\n* **Nodes should be constructed exactly as written in code.** No magic should happen on initialization and all construction should be explicit. Nodes should directly correlate to the code they represent and vice versa.\n\nEase of Traversal\n-----------------\n\n* **As flat as possible.** There shouldn't be an AsyncFunction wrapper containing a FunctionDef just because the grammar specifies it that way. Instead, we should make a FunctionDef node and give it an async attribute. Instead of representing parenthesis as wrapper nodes, they should be attached to the expressions that they operate on. In any scenario where we could achieve deduplication of LibCST code through extra layers in the resulting tree, we will opt for more code in order to make traversal simpler.\n* **As regular as possible.** A module should always have a list of statements, even if that list is empty or only has one item. Irregularity makes tree inspection more difficult.\n* **As high-level as possible.** The tree should be as close to the Python AST as possible. It should not be necessary to understand Python syntax in order to traverse the tree correctly. You should not have to know to ignore commas when traversing a list of parameters for a function. You should not have to use helper functions to traverse or recognize expressions wrapped in parenthesis. A LibCST node will represent its semantic operation in python with as little syntactic trivia exposed as possible.\n\nEase of Modification\n--------------------\n\n* **All nodes should be fully typed.** A module is a list of statements, not a list of untyped nodes. A function has a name, parameters and an optional return. It should be clear where to access various attributes of each node and what are the valid node types that can be used for that attribute.\n* **Additional runtime (in addition to static types) constraints.** It shouldn't be possible to construct a node that can't be serialized correctly or that would result in invalid code. You shouldn't be able to construct a Name node with a string that isn't a valid python identifier. Strong constraints here should allow us to perform multiple passes safely without serializing and re-parsing the tree after each pass.\n* **Sane defaults.** If I construct a node, I shouldn't have to supply whitespace, commas or other required syntax unless I want to. I should be able to treat the node in abstract, specifying only the semantics of the resulting code.\n* **Reasonably intelligent ownership of whitespace.** A statement should own the comments directly above it, and any trailing comments on the same line. If we delete that statement, the whitespace should disappear with it.\n* **It should be easy to change a single field** in an existing node without needing to modify or fix up adjacent nodes. Syntactic trivia such as commas or proper spacing between nodes should be children of the node they logically belong to so that inserting or removing a node does not require modifications to adjacent nodes.\n* **Reparentable.** It should be possible to move or copy a node from one part of the tree easily.\n\nWell Tested\n-----------\n\n* **All nodes should be fully tested.** It should not be possible to break upstream parsing or rendering code with a change to LibCST. Parsing, rendering and verifying functionality are all tested as completely as possible for all defined nodes.\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":"========\nCodemods\n========\n\nLibCST defines a codemod as an automated refactor that can be applied to a codebase\nof arbitrary size. Codemods are provided as a framework for writing higher-order\ntransforms that consist of other, simpler transforms. It includes provisions for\nquickly creating a command-line interface to execute a codemod.\n\n.. _libcst-codemod-base:\n\n------------\nCodemod Base\n------------\n\nAll codemods derive from a common base, :class:`~libcst.codemod.Codemod`. This class\nincludes a context, automatic metadata resolution and multi-pass transform support.\nCodemods are intended to be executed using the :func:`~libcst.codemod.transform_module`\ninterface.\n\n.. autoclass:: libcst.codemod.Codemod\n.. autoclass:: libcst.codemod.CodemodContext\n\nAs a convenience, LibCST-compatible visitors are provided which extend the feature-set\nof :class:`~libcst.codemod.Codemod` to LibCST visitors and transforms. Remember that\n:class:`~libcst.codemod.ContextAwareTransformer` is still a\n:class:`~libcst.codemod.Codemod`, so you should still execute it using\n:func:`~libcst.codemod.transform_module`.\n\n.. autoclass:: libcst.codemod.ContextAwareTransformer\n  :exclude-members: transform_module_impl\n.. autoclass:: libcst.codemod.ContextAwareVisitor\n\nIt is often necessary to bail out of a codemod mid-operation when you realize that\nyou do not want to operate on a module. This can be for any reason such as realizing\nthe module includes some operation that you do not support. If you wish to skip a\nmodule, you can raise the :class:`~libcst.codemod.SkipFile` exception. For codemods\nexecuted using the :func:`~libcst.codemod.transform_module` interface, all warnings\nemitted up to the exception being thrown will be preserved in the result.\n\n.. autoclass:: libcst.codemod.SkipFile\n\nFinally, its often easier to test codemods by writing verification tests instead of\nrunning repeatedly on your project. LibCST makes this easy with\n:class:`~libcst.codemod.CodemodTest`. Often you can develop the majority of your\ncodemod using just tests, augmenting functionality when you run into an unexpected\nedge case when running it against your repository.\n\n.. autoclass:: libcst.codemod.CodemodTest\n  :inherited-members:\n  :exclude-members: addCleanup, addTypeEqualityFunc, assertAlmostEqual, assertAlmostEquals, assertCountEqual, assertDictContainsSubset, assertDictEqual, assertEqual, assertEquals, assertFalse, assertGreater, assertGreaterEqual, assertIn, assertIs, assertIsInstance, assertIsNone, assertIsNot, assertIsNotNone, assertLess, assertLessEqual, assertListEqual, assertLogs, assertMultiLineEqual, assertNotAlmostEqual, assertNotAlmostEquals, assertNotEqual, assertNotEquals, assertNotIn, assertNotIsInstance, assertNotRegex, assertNotRegexpMatches, assertRaises, assertRaisesRegex, assertRaisesRegexp, assertRegex, assertRegexpMatches, assertSequenceEqual, assertSetEqual, assertTrue, assertTupleEqual, assertWarns, assertWarnsRegex, assert_, countTestCases, debug, defaultTestResult, doCleanups, fail, failIf, failIfAlmostEqual, failIfEqual, failUnless, failUnlessAlmostEqual, failUnlessEqual, failUnlessRaises, failureException, id, longMessage, maxDiff, run, setUp, classmethod, setUpClass, shortDescription, skipTest, subTest, tearDown, tearDownClass\n\n-------------------\nExecution Interface\n-------------------\n\nAs documented in the Codemod Base section above, codemods are meant to be\nprogrammatically executed using :func:`~libcst.codemod.transform_module`. Executing\nin this manner handles all of the featureset of codemods, including metadata calculation\nand exception handling.\n\n.. autofunction:: libcst.codemod.transform_module\n.. autoclass:: libcst.codemod.TransformResult\n.. autoclass:: libcst.codemod.TransformSuccess\n.. autoclass:: libcst.codemod.TransformFailure\n.. autoclass:: libcst.codemod.TransformSkip\n.. autoclass:: libcst.codemod.SkipReason\n.. autoclass:: libcst.codemod.TransformExit\n\n--------------------\nCommand-Line Support\n--------------------\n\nLibCST includes additional support to facilitate faster development of codemods which\nare to be run at the command-line. This is achieved through the\n:class:`~libcst.codemod.CodemodCommand` class and the ``codemod`` utility which lives\ninside ``libcst.tool``. The :class:`~libcst.codemod.CodemodCommand` class provides a\ncodemod description and an interface to add arguments to the command-line. This is\ntranslated to a custom help message and command-line options that a user can provide\nwhen running a codemod at the command-line.\n\nFor a brief overview of supported universal options, run the ``codemod`` utility like so::\n\n    python3 -m libcst.tool codemod --help\n\nThe utility provides support for gathering up and parallelizing codemods across a\nseries of files or directories, auto-formatting changed code according to a configured\nformatter, generating a unified diff of changes instead of applying them to files,\ntaking code from stdin and codemodding it before returning to stdout, and printing\nprogress and warnings to stderr during execution of a codemod.\n\nHelp is auto-customized if a codemod class is provided, including any added options\nand the codemod description. For an example, run the ``codemod`` utility like so::\n\n    python3 -m libcst.tool codemod noop.NOOPCommand --help\n\nA second utility, ``list``, can list all available codemods given your configuration.\nRun it like so::\n\n    python3 -m libcst.tool list\n\nFinally, to set up a directory for codemodding using these tools, including additional\ndirectories where codemods can be found, use the ``initialize`` utility. To see help\nfor how to use this, run the ``initialize`` utility like so::\n\n    python3 -m libcst.tool initialize --help\n\nThe above tools operate against any codemod which subclasses from\n:class:`~libcst.codemod.CodemodCommand`. Remember that :class:`~libcst.codemod.CodemodCommand`\nis a subclass of :class:`~libcst.codemod.Codemod`, so all of the features documented\nin the :ref:`libcst-codemod-base` section are available in addition to command-line\nsupport. Any command-line enabled codemod can also be programmatically instantiated\nand invoked using the above-documented :func:`~libcst.codemod.transform_module`\ninterface.\n\n.. autoclass:: libcst.codemod.CodemodCommand\n  :exclude-members: transform_module\n\nAdditionally, a few convenience classes have been provided which take the boilerplate\nout of common types of codemods:\n\n.. autoclass:: libcst.codemod.VisitorBasedCodemodCommand\n.. autoclass:: libcst.codemod.MagicArgsCodemodCommand\n  :exclude-members: transform_module_impl\n\n--------------------\nCommand-Line Toolkit\n--------------------\n\nSeveral helpers for constructing a command-line interface are provided. These are used\nin the ``codemod`` utility to provide LibCST's de-facto command-line interface but they\nare also available to be used directly in the case that circumstances demand a custom\ncommand-line tool.\n\n.. autofunction:: libcst.codemod.gather_files\n.. autofunction:: libcst.codemod.exec_transform_with_prettyprint\n.. autofunction:: libcst.codemod.parallel_exec_transform_with_prettyprint\n.. autoclass:: libcst.codemod.ParallelTransformResult\n.. autofunction:: libcst.codemod.diff_code\n\n---------------------\nLibrary of Transforms\n---------------------\n\nLibCST additionally includes a library of transforms to reduce the need for boilerplate\ninside codemods. As of now, the list includes the following helpers.\n\n.. autoclass:: libcst.codemod.visitors.GatherImportsVisitor\n  :no-undoc-members:\n.. autoclass:: libcst.codemod.visitors.GatherExportsVisitor\n  :no-undoc-members:\n.. autoclass:: libcst.codemod.visitors.AddImportsVisitor\n  :no-undoc-members:\n.. autoclass:: libcst.codemod.visitors.RemoveImportsVisitor\n  :no-undoc-members:\n.. autoclass:: libcst.codemod.visitors.ApplyTypeAnnotationsVisitor\n  :no-undoc-members:\n.. autoclass:: libcst.codemod.visitors.GatherUnusedImportsVisitor\n  :no-undoc-members:\n.. autoclass:: libcst.codemod.visitors.GatherCommentsVisitor\n  :no-undoc-members:\n.. autoclass:: libcst.codemod.visitors.GatherNamesFromStringAnnotationsVisitor\n  :no-undoc-members:"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":".. _libcst-visitors:\n\nVisitors\n========\n\n.. autoclass:: libcst.CSTVisitor\n.. autoclass:: libcst.CSTTransformer\n.. autofunction:: libcst.RemoveFromParent\n.. autoclass:: libcst.RemovalSentinel\n.. autoclass:: libcst.FlattenSentinel\n\nVisit and Leave Helper Functions\n--------------------------------\n\nWhile it is possible to subclass from :class:`~libcst.CSTVisitor` or :class:`~libcst.CSTTransformer`\nand override the ``on_visit``/``on_leave``/``on_visit_attribute``/``on_leave_attribute`` functions\ndirectly, it is not recommended. The default implementation for both visitors will look up any\n``visit_<Type[CSTNode]>``, ``leave_<Type[CSTNode]>``, ``visit_<Type[CSTNode]>_<attribute>`` and\n``leave_<Type[CSTNode]>_<attribute>`` method on the visitor subclass and call them directly.\nIf such a function exists for the node in question, the visitor base class will call the relevant\nfunction, respecting the above outlined semantics. If the function does not exist, the visitor base\nclass will assume that you do not care about that node and visit its children for you without\nrequiring a default implementation.\n\nMuch like ``on_visit``, ``visit_<Type[CSTNode]>`` return a boolean specifying whether or not LibCST\nshould visit a node's children. As a convenience, you can return ``None`` instead of a boolean value\nfrom your ``visit_<Type[CSTNode]>`` functions. Returning a ``None`` value is treated as a request for\ndefault behavior, which causes the visitor to traverse children. It is equivalent to returning\n``True``, but requires no explicit return.\n\nFor example, the below visitor will visit every function definition, traversing to its children only\nif the function name doesn't include the word \"foo\". Notice that we don't need to provide our own\n``on_visit`` or ``on_leave`` function, nor do we need to provide visit and leave functions for the\nrest of the nodes which we do not care about. This will have the effect of visiting all strings not\ninside of functions that have \"foo\" in the name. Note that we take advantage of default behavior when\nwe decline to return a value in ``visit_SimpleString``.\n\n.. code-block:: python\n\n    class FooingAround(libcst.CSTVisitor):\n        def visit_FunctionDef(self, node: libcst.FunctionDef) -> bool:\n            return \"foo\" not in node.name.value\n\n        def visit_SimpleString(self, node: libcst.SimpleString) -> None:\n            print(node.value)\n\nAn example Python REPL using the above visitor is as follows::\n\n    >>> import libcst\n    >>> demo = libcst.parse_module(\"'abc'\\n'123'\\ndef foo():\\n    'not printed'\")\n    >>> _ = demo.visit(FooingAround())\n    'abc'\n    '123'\n\n.. _libcst-visitor-traversal:\n\nTraversal Order\n---------------\n\nTraversal of any parsed tree directly matches the order that tokens appear in the source which\nwas parsed. LibCST will first call ``on_visit`` for the node. Then, for each of the node's\nchild attributes, LibCST will call ``on_visit_attribute`` for the node's attribute, followed\nby running the same visit algorithm on each child node in the node's attribute. Then,\n``on_leave_attribute`` is called. After each attribute has been fully traversed, LibCST will\ncall ``on_leave`` for the node. Note that LibCST will only call ``on_visit_attribute`` and\n``on_leave_attribute`` for attributes in which there might be a LibCST node as a child. It\nwill not call attribute visitors for attributes which are built-in python types.\n\nFor example, take the following simple tree generated by calling ``parse_expression(\"1+2\")``.\n\n.. code-block:: python\n\n    BinaryOperation(\n        left=Integer(\n            value='1',\n            lpar=[],\n            rpar=[],\n        ),\n        operator=Add(\n            whitespace_before=SimpleWhitespace(\n                value='',\n            ),\n            whitespace_after=SimpleWhitespace(\n                value='',\n            ),\n        ),\n        right=Integer(\n            value='2',\n            lpar=[],\n            rpar=[],\n        ),\n        lpar=[],\n        rpar=[],\n    )\n\nAssuming you have a visitor that overrides every convenience helper method available,\nmethods will be called in this order:\n\n.. code-block:: python\n\n    visit_BinaryOperation\n    visit_BinaryOperation_lpar\n    leave_BinaryOperation_lpar\n    visit_BinaryOperation_left\n    visit_Integer\n    visit_Integer_lpar\n    leave_Integer_lpar\n    visit_Integer_rpar\n    leave_Integer_rpar\n    leave_Integer\n    leave_BinaryOperation_left\n    visit_BinaryOperation_operator\n    visit_Add\n    visit_Add_whitespace_before\n    visit_SimpleWhitespace\n    leave_SimpleWhitespace\n    leave_Add_whitespace_before\n    visit_Add_whitespace_after\n    visit_SimpleWhitespace\n    leave_SimpleWhitespace\n    leave_Add_whitespace_after\n    leave_Add\n    leave_BinaryOperation_operator\n    visit_BinaryOperation_right\n    visit_Integer\n    visit_Integer_lpar\n    leave_Integer_lpar\n    visit_Integer_rpar\n    leave_Integer_rpar\n    leave_Integer\n    leave_BinaryOperation_right\n    visit_BinaryOperation_rpar\n    leave_BinaryOperation_rpar\n    leave_BinaryOperation\n\nBatched Visitors\n----------------\n\nA batchable visitor class is provided to facilitate performing operations that\ncan be performed in parallel in a single traversal over a CST. An example of this\nis :ref:`metadata computation<libcst-metadata>`.\n\n.. autoclass:: libcst.BatchableCSTVisitor\n.. autofunction:: libcst.visit_batched\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":".. _libcst-nodes:\n\nNodes\n=====\n\nCSTNode and its subclasses cover Python's full grammar in a\nwhitespace-sensitive fashion, forming LibCST's concrete syntax tree.\n\nMany of these nodes are designed to `behave similarly to Python's abstract\nsyntax tree <https://greentreesnakes.readthedocs.io/en/latest/nodes.html>`_.\n\nCSTNode\n-------\n\nThe base node type which all other nodes derive from.\n\n.. autoclass:: libcst.CSTNode\n\nModule\n------\n\nA node that represents an entire python module.\n\n.. autoclass:: libcst.Module\n\nExpressions\n-----------\n\nAn expression is anything that represents a value (e.g. it could be returned\nfrom a function). All expressions subclass from :class:`~libcst.BaseExpression`.\n\nExpression can be parsed with :func:`~libcst.parse_expression` or as part of a\nstatement or module using :func:`~libcst.parse_statement` or\n:func:`~libcst.parse_module`.\n\n.. autoclass:: libcst.BaseExpression\n\nNames and Object Attributes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. autoclass:: libcst.Name\n.. autoclass:: libcst.Attribute\n\nOperations and Comparisons\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOperation and Comparison nodes combine one or more expressions with an\noperator_.\n\n.. _operator: Operators_\n\n.. autoclass:: libcst.UnaryOperation\n.. autoclass:: libcst.BinaryOperation\n.. autoclass:: libcst.BooleanOperation\n.. autoclass:: libcst.Comparison\n.. autoclass:: libcst.ComparisonTarget\n\nControl Flow\n^^^^^^^^^^^^\n\n.. autoclass:: libcst.Asynchronous\n.. autoclass:: libcst.Await\n.. autoclass:: libcst.Yield\n.. autoclass:: libcst.From\n.. autoclass:: libcst.IfExp\n\nLambdas and Function Calls\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. autoclass:: libcst.Lambda\n.. autoclass:: libcst.Call\n.. autoclass:: libcst.Arg\n\nLiteral Values\n^^^^^^^^^^^^^^\n\n.. autoclass:: libcst.Ellipsis\n\nNumbers\n'''''''\n\n.. autoclass:: libcst.BaseNumber\n.. autoclass:: libcst.Integer\n.. autoclass:: libcst.Float\n.. autoclass:: libcst.Imaginary\n\nStrings\n'''''''\n\n.. autoclass:: libcst.BaseString\n.. autoclass:: libcst.SimpleString\n.. autoclass:: libcst.ConcatenatedString\n\nFormatted Strings (f-strings)\n'''''''''''''''''''''''''''''\n\n.. autoclass:: libcst.FormattedString\n.. autoclass:: libcst.BaseFormattedStringContent\n.. autoclass:: libcst.FormattedStringText\n.. autoclass:: libcst.FormattedStringExpression\n\nCollections\n^^^^^^^^^^^\n\nSimple Collections\n''''''''''''''''''\n\n.. autoclass:: libcst.Tuple\n\n.. autoclass:: libcst.BaseList\n.. autoclass:: libcst.List\n\n.. autoclass:: libcst.BaseSet\n.. autoclass:: libcst.Set\n\nSimple Collection Elements\n''''''''''''''''''''''''''\n\n.. autoclass:: libcst.BaseElement\n.. autoclass:: libcst.Element\n.. autoclass:: libcst.StarredElement\n\nDictionaries\n''''''''''''\n\n.. autoclass:: libcst.BaseDict\n.. autoclass:: libcst.Dict\n\nDictionary Elements\n'''''''''''''''''''\n\n.. autoclass:: libcst.BaseDictElement\n.. autoclass:: libcst.DictElement\n.. autoclass:: libcst.StarredDictElement\n\nComprehensions\n^^^^^^^^^^^^^^\n\n.. autoclass:: libcst.BaseComp\n.. autoclass:: libcst.BaseSimpleComp\n\n.. autoclass:: libcst.GeneratorExp\n.. autoclass:: libcst.ListComp\n.. autoclass:: libcst.SetComp\n.. autoclass:: libcst.DictComp\n\n.. autoclass:: libcst.CompFor\n.. autoclass:: libcst.CompIf\n\nSubscripts and Slices\n^^^^^^^^^^^^^^^^^^^^^\n\n.. autoclass:: libcst.Subscript\n.. autoclass:: libcst.BaseSlice\n.. autoclass:: libcst.Index\n.. autoclass:: libcst.Slice\n.. autoclass:: libcst.SubscriptElement\n\nParenthesis, Brackets, and Braces\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. autoclass:: libcst.LeftParen\n.. autoclass:: libcst.RightParen\n\n.. autoclass:: libcst.LeftSquareBracket\n.. autoclass:: libcst.RightSquareBracket\n\n.. autoclass:: libcst.LeftCurlyBrace\n.. autoclass:: libcst.RightCurlyBrace\n\nStatements\n----------\n\nStatements represent a \"line of code\" or a control structure with other lines of\ncode, such as an :class:`~libcst.If` block.\n\nAll statements subclass from :class:`~libcst.BaseSmallStatement` or\n:class:`~libcst.BaseCompoundStatement`.\n\nStatements can be parsed with :func:`~libcst.parse_statement` or as part of a\nmodule using :func:`~libcst.parse_module`.\n\nSimple Statements\n^^^^^^^^^^^^^^^^^\n\nStatements which at most have expressions as child attributes.\n\n.. autoclass:: libcst.BaseSmallStatement\n.. autoclass:: libcst.AnnAssign\n.. autoclass:: libcst.Assert\n.. autoclass:: libcst.Assign\n.. autoclass:: libcst.AugAssign\n.. autoclass:: libcst.Break\n.. autoclass:: libcst.Continue\n.. autoclass:: libcst.Del\n.. autoclass:: libcst.Expr\n.. autoclass:: libcst.Global\n.. autoclass:: libcst.Import\n.. autoclass:: libcst.ImportFrom\n.. autoclass:: libcst.Nonlocal\n.. autoclass:: libcst.Pass\n.. autoclass:: libcst.Raise\n.. autoclass:: libcst.Return\n\n\nCompound Statements\n^^^^^^^^^^^^^^^^^^^\n\nStatements that have one or more statement blocks as a child attribute.\n\n.. autoclass:: libcst.BaseCompoundStatement\n.. autoclass:: libcst.ClassDef\n.. autoclass:: libcst.For\n.. autoclass:: libcst.FunctionDef\n.. autoclass:: libcst.If\n.. autoclass:: libcst.Try\n.. autoclass:: libcst.While\n.. autoclass:: libcst.With\n\nHelper Nodes\n^^^^^^^^^^^^\n\nNodes that are used by various statements to represent some syntax, but\nare not statements on their own and cannot be used outside of the statements\nthey belong with.\n\n.. Annotation is in the expression module for import-order reasons, it's\n   most-often used a a helper for statements (e.g. functions)\n.. autoclass:: libcst.Annotation\n\n.. autoclass:: libcst.AsName\n.. autoclass:: libcst.AssignTarget\n.. autoclass:: libcst.BaseAssignTargetExpression\n.. autoclass:: libcst.BaseDelTargetExpression\n.. autoclass:: libcst.Decorator\n.. autoclass:: libcst.Else\n.. autoclass:: libcst.ExceptHandler\n.. autoclass:: libcst.Finally\n.. autoclass:: libcst.ImportAlias\n.. autoclass:: libcst.NameItem\n\n.. Params are in the expression module for import-order reasons, but it makes\n   sense to group these closer to FunctionDef than with Lambda.\n.. autoclass:: libcst.Parameters\n.. autoclass:: libcst.Param\n.. autoclass:: libcst.ParamSlash\n.. autoclass:: libcst.ParamStar\n\n.. autoclass:: libcst.WithItem\n\nStatement Blocks\n^^^^^^^^^^^^^^^^\n\nNodes that represent some group of statements.\n\n.. autoclass:: libcst.BaseSuite\n.. autoclass:: libcst.SimpleStatementLine\n.. autoclass:: libcst.SimpleStatementSuite\n.. autoclass:: libcst.IndentedBlock\n\nOperators\n---------\n\nNodes that are used to signify an operation to be performed on a variable\nor value.\n\nUnary Operators\n^^^^^^^^^^^^^^^\n\nNodes that are used with :class:`~libcst.UnaryOperation` to perform some unary\noperation.\n\n.. class:: libcst.BitInvert\n.. class:: libcst.Minus\n.. class:: libcst.Not\n.. autoclass:: libcst.Plus\n\nIn addition, :class:`~libcst.BaseUnaryOp` is defined purely for typing and isinstance\nchecks.\n\n.. class:: libcst.BaseUnaryOp\n\nBoolean Operators\n^^^^^^^^^^^^^^^^^\n\nNodes that are used with :class:`~libcst.BooleanOperation` to perform some boolean\noperation.\n\n.. class:: libcst.And\n.. autoclass:: libcst.Or\n\nIn addition, :class:`~libcst.BaseBooleanOp` is defined purely for typing and isinstance\nchecks.\n\n.. class:: libcst.BaseBooleanOp\n\nBinary Operators\n^^^^^^^^^^^^^^^^\n\nNodes that are used with :class:`~libcst.BinaryOperation` to perform some binary\noperation.\n\n.. class:: libcst.Add\n.. class:: libcst.BitAnd\n.. class:: libcst.BitOr\n.. class:: libcst.BitXor\n.. class:: libcst.Divide\n.. class:: libcst.FloorDivide\n.. class:: libcst.LeftShift\n.. class:: libcst.MatrixMultiply\n.. class:: libcst.Modulo\n.. class:: libcst.Multiply\n.. class:: libcst.Power\n.. class:: libcst.RightShift\n.. autoclass:: libcst.Subtract\n\nIn addition, :class:`~libcst.BaseBinaryOp` is defined purely for typing and isinstance\nchecks.\n\n.. class:: libcst.BaseBinaryOp\n\nComparison Operators\n^^^^^^^^^^^^^^^^^^^^\n\nNodes that are used with :class:`~libcst.Comparison` to perform some comparison\noperation.\n\n.. class:: libcst.Equal\n.. class:: libcst.GreaterThan\n.. class:: libcst.GreaterThanEqual\n.. class:: libcst.In\n.. class:: libcst.Is\n.. class:: libcst.LessThan\n.. autoclass:: libcst.LessThanEqual\n\n.. autoclass:: libcst.NotEqual\n\n.. class:: libcst.IsNot\n.. autoclass:: libcst.NotIn\n\nIn addition, :class:`~libcst.BaseCompOp` is defined purely for typing and isinstance\nchecks.\n\n.. class:: libcst.BaseCompOp\n\nAugmented Assignment Operators\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nNodes that are used with :class:`~libcst.AugAssign` to perform some agumented\nassignment.\n\n.. class:: libcst.AddAssign\n.. class:: libcst.BitAndAssign\n.. class:: libcst.BitOrAssign\n.. class:: libcst.BitXorAssign\n.. class:: libcst.DivideAssign\n.. class:: libcst.FloorDivideAssign\n.. class:: libcst.LeftShiftAssign\n.. class:: libcst.MatrixMultiplyAssign\n.. class:: libcst.ModuloAssign\n.. class:: libcst.MultiplyAssign\n.. class:: libcst.PowerAssign\n.. class:: libcst.RightShiftAssign\n.. autoclass:: libcst.SubtractAssign\n\nIn addition, :class:`~libcst.BaseAugOp` is defined purely for typing and isinstance\nchecks.\n\n.. class:: libcst.BaseAugOp\n\nMiscellaneous\n-------------\n\nMiscelaneous nodes that are purely syntactic trivia. While python requires these nodes\nin order to parse a module, statement or expression they do not carry any meaning on\ntheir own.\n\n.. autoclass:: libcst.AssignEqual\n.. autoclass:: libcst.Colon\n.. autoclass:: libcst.Comma\n.. autoclass:: libcst.Dot\n.. autoclass:: libcst.ImportStar\n.. autoclass:: libcst.Semicolon\n\nWhitespace\n----------\n\nNodes that encapsulate pure whitespace.\n\n.. autoclass:: libcst.Comment\n.. autoclass:: libcst.EmptyLine\n.. autoclass:: libcst.Newline\n.. autoclass:: libcst.ParenthesizedWhitespace\n.. autoclass:: libcst.SimpleWhitespace\n.. autoclass:: libcst.TrailingWhitespace\n.. autoclass:: libcst.BaseParenthesizableWhitespace\n\nMaybe Sentinel\n--------------\n\n.. autoclass:: libcst.MaybeSentinel\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":".. _libcst-matchers:\n\n========\nMatchers\n========\n\nMatchers are provided as a way of asking whether a particular LibCST node and its\nchildren match a particular shape. It is possible to write a visitor that\ntracks attributes using ``visit_<Node>`` methods. It is also possible to implement\nmanual instance checking and traversal of a node's children. However, both are\ncumbersome to write and hard to understand. Matchers offer a more concise way of\ndefining what attributes on a node matter when matching against predefined patterns.\n\nTo accomplish this, a matcher has been created which corresponds to each LibCST\nnode documented in :ref:`libcst-nodes`. Matchers default each of their attributes\nto the special sentinel matcher :func:`~libcst.matchers.DoNotCare`. When constructing\na matcher, you can initialize the node with only the values of attributes that\nyou are concerned with, leaving the rest of the attributes set to\n:func:`~libcst.matchers.DoNotCare` in order to skip comparing against them.\n\n------------\nMatcher APIs\n------------\n\nFunctions\n^^^^^^^^^\n\nMatchers can be used either by calling :func:`~libcst.matchers.matches` or\n:func:`~libcst.matchers.findall` directly, or by using various decorators to\nselectively control when LibCST calls visitor functions.\n\n.. autofunction:: libcst.matchers.matches\n.. autofunction:: libcst.matchers.findall\n.. autofunction:: libcst.matchers.extract\n.. autofunction:: libcst.matchers.extractall\n.. autofunction:: libcst.matchers.replace\n\n.. _libcst-matcher-decorators:\n\nDecorators\n^^^^^^^^^^\n\nThe following decorators can be placed onto a method in a visitor or transformer\nin order to convert it into a visitor which is called when the provided matcher is\ntrue.\n\n.. autofunction:: libcst.matchers.visit\n.. autofunction:: libcst.matchers.leave\n\nThe following decorators can be placed onto any existing ``visit_<Node>`` or\n``leave_<Node>`` visitor, as well as any visitor created using either\n:func:`~libcst.matchers.visit` or :func:`~libcst.matchers.leave`. They control\nwhether the visitor itself gets called or skipped by LibCST when traversing a tree.\nNote that when a visitor function is skipped, its children will still be visited\nbased on the rules set forth in :ref:`libcst-visitors`. Namely, if you have a separate\n``visit_<Node>`` visitor that returns ``False`` for a particular node, we will not\ntraverse to its children.\n\n.. autofunction:: libcst.matchers.call_if_inside\n.. autofunction:: libcst.matchers.call_if_not_inside\n\nWhen using matcher decorators, your visitors must subclass from\n:class:`~libcst.matchers.MatcherDecoratableVisitor` instead of :class:`libcst.CSTVisitor`,\nand from :class:`~libcst.matchers.MatcherDecoratableTransformer` instead of\n:class:`libcst.CSTTransformer`. This is so that visitors and transformers not making\nuse of matcher decorators do not pay the extra cost of their implementation. Note that\nif you do not subclass from :class:`~libcst.matchers.MatcherDecoratableVisitor` or\n:class:`~libcst.matchers.MatcherDecoratableTransformer`, you can still use the\n:func:`~libcst.matchers.matches` function.\n\nBoth of these classes are strict subclasses of their corresponding LibCST base class,\nso they can be used anywhere that expects a LibCST base class. See :ref:`libcst-visitors`\nfor more information.\n\n.. autoclass:: libcst.matchers.MatcherDecoratableVisitor\n.. autoclass:: libcst.matchers.MatcherDecoratableTransformer\n\nTraversal Order\n^^^^^^^^^^^^^^^\n\nVisit and leave functions created using :func:`~libcst.matchers.visit` or\n:func:`~libcst.matchers.leave` follow the traversal order rules laid out in\nLibCST's visitor :ref:`libcst-visitor-traversal` with one additional rule. Any\nvisit function created using the :func:`~libcst.matchers.visit` decorator will be\ncalled **before** a ``visit_<Node>`` function if it is defined for your visitor.\nThe order in which various visit functions which are created with\n:func:`~libcst.matchers.visit` are called is indeterminate, but all such functions\nwill be called before calling the ``visit_<Node>`` method. Similarly, any leave\nfunction created using the :func:`~libcst.matchers.leave` decorator will be called\n**after** a ``leave_<Node>`` function if it is defined for your visitor. The order\nin which various leave functions which are created with\n:func:`~libcst.matchers.leave` are called is indeterminate, but all such functions\nwill be called after calling the ``visit_<Node>`` function if it is defined for\nyour visitor.\n\nThis has a few implications. The first is that if you return ``False`` from a\n``visit_<Node>`` method, we are guaranteed to call your decorated visit functions\nas well. Second, when modifying a node in both ``leave_<Node>`` and a visitor\ncreated with :func:`~libcst.matchers.leave`, the ``original_node`` will be unchanged\nfor both and the ``updated_node`` available to the decorated leave method will be\nthe node that is returned by the ``leave_<Node>`` method. Chaining modifications\nacross multiple leave functions is supported, but must be done with care.\n\n-------------\nMatcher Types\n-------------\n\nConcrete Matchers\n^^^^^^^^^^^^^^^^^\n\nFor each node found in :ref:`libcst-nodes`, a corresponding concrete matcher\nhas been generated. Each matcher has attributes identical to its LibCST node\ncounterpart. For example, :class:`libcst.Expr` includes the ``value`` and ``semicolon``\nattributes, and therefore :class:`libcst.matchers.Expr` similarly includes the same\nattributes. Just as :class:`libcst.Expr`'s ``value`` is typed as taking a\n:class:`libcst.BaseExpression`, :class:`libcst.matchers.Expr`'s ``value`` is typed\nas taking a :class:`libcst.matchers.BaseExpression`. For every node that exists in\nLibCST, both concrete and abstract, a corresponding matcher has been defined.\n\nThere are a few special cases to the rules laid out above. For starters, matchers\ndon't support evaluating :class:`~libcst.MaybeSentinel`. There is no way to specify\nthat you wish to match against a :class:`~libcst.MaybeSentinel` except with the\n:func:`~libcst.matchers.DoNotCare` matcher. This tends not to be an issue in\npractice because :class:`~libcst.MaybeSentinel` is only found on syntax nodes.\n\nWhile there are base classes such as :class:`libcst.matchers.BaseExpression`, you\ncannot match directly on them. They are provided for typing purposes only in order\nto exactly match the types on LibCST node attributes. If you need to match on\nall concrete subclasses of a base class, we recommend using the special matcher\n:class:`~libcst.matchers.OneOf`.\n\n.. autoclass:: libcst.matchers.BaseMatcherNode\n\nSpecial Matchers\n^^^^^^^^^^^^^^^^\n\nSpecial matchers are matchers that don't have a corresponding LibCST node. Concrete\nmatchers only match against their corresponding LibCST node, limiting their use\nunder certain circumstances. Special matchers fill in the gap by allowing\nhigher-level logic constructs such as inversion. You can use any special matcher\nin place of a concrete matcher when specifying matcher attributes. Additionally,\nyou can also use the :class:`~libcst.matchers.AllOf` and\n:class:`~libcst.matchers.OneOf` special matchers in place of a concrete matcher\nwhen calling :func:`~libcst.matchers.matches` or using decorators.\n\n.. autoclass:: libcst.matchers.OneOf\n.. autoclass:: libcst.matchers.AllOf\n.. autoclass:: libcst.matchers.TypeOf\n.. autofunction:: libcst.matchers.DoesNotMatch\n.. autoclass:: libcst.matchers.MatchIfTrue\n.. autofunction:: libcst.matchers.MatchRegex\n.. autoclass:: libcst.matchers.MatchMetadata\n.. autoclass:: libcst.matchers.MatchMetadataIfTrue\n.. autofunction:: libcst.matchers.SaveMatchedNode\n.. autofunction:: libcst.matchers.DoNotCare\n\nSequence Wildcard Matchers\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSequence wildcard matchers are matchers that only get used when constructing a\nsequence to match against. Not all LibCST nodes have attributes which are sequences,\nbut for those that do, sequence wildcard matchers offer a great degree of\nflexibility. Unlike all other matcher types, these allow you to match against\nmore than one LibCST node, much like wildcards in regular expressions do.\n\nLibCST does not implicitly match on partial sequences for you. So, when matching\nagainst a sequence you will need to provide a complete pattern. This often means\nusing helpers such as :func:`~libcst.matchers.ZeroOrMore` as the first and last\nelement of your sequence. Think of it as the difference between Python's\n`re.match <https://docs.python.org/3/library/re.html#re.match>`_ and\n`re.fullmatch <https://docs.python.org/3/library/re.html#re.fullmatch>`_ functions.\nLibCST matchers behave like the latter so that it is possible to specify sequences\nwhich must start with, end with or be exactly equal to some pattern.\n\n.. autoclass:: libcst.matchers.AtLeastN\n.. autofunction:: libcst.matchers.ZeroOrMore\n.. autoclass:: libcst.matchers.AtMostN\n.. autofunction:: libcst.matchers.ZeroOrOne\n"}]}
{"model":"gpt-3.5-turbo-16k","messages":[{"role":"system","content":"You are a Python Documentation specialist. \n                            clean up the documentation below and organize it into a python list of strings that will be turned into rows of a dataframe."},{"role":"user","content":"=======\nHelpers\n=======\n\nHelpers are higher level functions built for reducing recurring code boilerplate.\nWe add helpers as method of ``CSTNode`` or ``libcst.helpers`` package based on those principles:\n\n  - ``CSTNode`` method: simple, read-only and only require data of the direct children of a CSTNode.\n  - ``libcst.helpers``: node transforms or require recursively traversing the syntax tree.\n\nConstruction Helpers\n--------------------\n\nFunctions that assist in creating a new LibCST tree.\n\n.. autofunction:: libcst.helpers.parse_template_module\n.. autofunction:: libcst.helpers.parse_template_expression\n.. autofunction:: libcst.helpers.parse_template_statement\n\nTransformation Helpers\n----------------------\n\nFunctions that assist in transforming an existing LibCST node.\n\n.. autofunction:: libcst.helpers.insert_header_comments\n\nTraversing Helpers\n------------------\n\nFunctions that assist in traversing an existing LibCST tree.\n\n.. autofunction:: libcst.helpers.get_full_name_for_node\n.. autofunction:: libcst.helpers.get_full_name_for_node_or_raise\n.. autofunction:: libcst.helpers.ensure_type\n"}]}
