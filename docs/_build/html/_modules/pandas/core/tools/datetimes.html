<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pandas.core.tools.datetimes &mdash; BabyDragon  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            BabyDragon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tasks:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/llm_task.html">llm_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/multi_kernel_task.html">multi_kernel_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/base_task.html">base_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/topic_tree_task.html">topic_tree_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/embedding_task.html">embedding_task</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Kernels:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/memory_kernel.html">memory_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_clustering.html">kernel_clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel.html">multi_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel_visualization.html">multi_kernel_visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_utils.html">kernel_utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Threads:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/base_thread.html">base_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/fifo_thread.html">fifo_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/vector_thread.html">vector_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/todo/python_thread.html">python_thread</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Indexes:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/python_index.html">python_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/memory_index.html">memory_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/pandas_index.html">pandas_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/youtube_index.html">youtube_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/parquet_index.html">parquet_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/wiki_index.html">wiki_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/gutenberg_index.html">gutenberg_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/github_index.html">github_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/multi_index.html">multi_index</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Chat:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/base_chat.html">base_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/memory_chat.html">memory_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/chat.html">chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/prompts/perspective_prompt.html">perspective_prompt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/prompts/default_prompts.html">default_prompts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utils:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/multithreading.html">multithreading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/pandas.html">pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/hf_datasets.html">hf_datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/chatml.html">chatml</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/embedders:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/ada2.html">ada2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/sbert.html">sbert</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/generators:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/chatgpt.html">chatgpt</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Processors:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/github_processors.html">github_processors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/os_processor.html">os_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/git_metadata.html">git_metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html">visitors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html">python_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/subs_parser.html">subs_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/latex_parser.html">latex_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/md_parser.html">md_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/wiki_parser.html">wiki_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/git_processor.html">git_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/arxiv_processor.html">arxiv_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/wiki_processor.html">wiki_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/chatgpt_processor.html">chatgpt_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/mit_course_processor.html">mit_course_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/youtube_processor.html">youtube_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/pubmed_processor.html">pubmed_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/gutenberg_processor.html">gutenberg_processor</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Apps:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html">perspective</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">BabyDragon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pandas.core.tools.datetimes</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pandas.core.tools.datetimes</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">abc</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">TypedDict</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">lib</span><span class="p">,</span>
    <span class="n">tslib</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">OutOfBoundsDatetime</span><span class="p">,</span>
    <span class="n">Timedelta</span><span class="p">,</span>
    <span class="n">Timestamp</span><span class="p">,</span>
    <span class="n">astype_overflowsafe</span><span class="p">,</span>
    <span class="n">get_unit_from_dtype</span><span class="p">,</span>
    <span class="n">iNaT</span><span class="p">,</span>
    <span class="n">is_supported_unit</span><span class="p">,</span>
    <span class="n">nat_strings</span><span class="p">,</span>
    <span class="n">parsing</span><span class="p">,</span>
    <span class="n">timezones</span> <span class="k">as</span> <span class="n">libtimezones</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs.conversion</span> <span class="kn">import</span> <span class="n">precision_from_unit</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs.parsing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DateParseError</span><span class="p">,</span>
    <span class="n">guess_datetime_format</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs.strptime</span> <span class="kn">import</span> <span class="n">array_strptime</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AnyArrayLike</span><span class="p">,</span>
    <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">DateTimeErrorChoices</span><span class="p">,</span>
    <span class="n">npt</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._exceptions</span> <span class="kn">import</span> <span class="n">find_stack_level</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ensure_object</span><span class="p">,</span>
    <span class="n">is_datetime64_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64tz_dtype</span><span class="p">,</span>
    <span class="n">is_float</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span>
    <span class="n">is_integer_dtype</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_numeric_dtype</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ABCDataFrame</span><span class="p">,</span>
    <span class="n">ABCSeries</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="n">notna</span>

<span class="kn">from</span> <span class="nn">pandas.arrays</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DatetimeArray</span><span class="p">,</span>
    <span class="n">IntegerArray</span><span class="p">,</span>
    <span class="n">PandasArray</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="kn">import</span> <span class="n">algorithms</span>
<span class="kn">from</span> <span class="nn">pandas.core.algorithms</span> <span class="kn">import</span> <span class="n">unique</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.base</span> <span class="kn">import</span> <span class="n">ExtensionArray</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.datetimes</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">maybe_convert_dtype</span><span class="p">,</span>
    <span class="n">objects_to_datetime64ns</span><span class="p">,</span>
    <span class="n">tz_to_dtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.construction</span> <span class="kn">import</span> <span class="n">extract_array</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.base</span> <span class="kn">import</span> <span class="n">Index</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.datetimes</span> <span class="kn">import</span> <span class="n">DatetimeIndex</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas._libs.tslibs.nattype</span> <span class="kn">import</span> <span class="n">NaTType</span>
    <span class="kn">from</span> <span class="nn">pandas._libs.tslibs.timedeltas</span> <span class="kn">import</span> <span class="n">UnitChoices</span>

    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">Series</span><span class="p">,</span>
    <span class="p">)</span>

<span class="c1"># ---------------------------------------------------------------------</span>
<span class="c1"># types used in annotations</span>

<span class="n">ArrayConvertible</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">AnyArrayLike</span><span class="p">]</span>
<span class="n">Scalar</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">DatetimeScalar</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">datetime</span><span class="p">]</span>

<span class="n">DatetimeScalarOrArrayConvertible</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">DatetimeScalar</span><span class="p">,</span> <span class="n">ArrayConvertible</span><span class="p">]</span>

<span class="n">DatetimeDictArg</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Scalar</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Scalar</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">AnyArrayLike</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">YearMonthDayDict</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">year</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>
    <span class="n">month</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>
    <span class="n">day</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>


<span class="k">class</span> <span class="nc">FulldatetimeDict</span><span class="p">(</span><span class="n">YearMonthDayDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">hour</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>
    <span class="n">hours</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>
    <span class="n">minute</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>
    <span class="n">minutes</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>
    <span class="n">second</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>
    <span class="n">seconds</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>
    <span class="n">ms</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>
    <span class="n">us</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>
    <span class="n">ns</span><span class="p">:</span> <span class="n">DatetimeDictArg</span>


<span class="n">DictConvertible</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">FulldatetimeDict</span><span class="p">,</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">]</span>
<span class="n">start_caching_at</span> <span class="o">=</span> <span class="mi">50</span>


<span class="c1"># ---------------------------------------------------------------------</span>


<span class="k">def</span> <span class="nf">_guess_datetime_format_for_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dayfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Try to guess the format based on the first non-NaN element, return None if can&#39;t</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">first_non_null</span> <span class="o">:=</span> <span class="n">tslib</span><span class="o">.</span><span class="n">first_non_null</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">first_non_nan_element</span> <span class="o">:=</span> <span class="n">arr</span><span class="p">[</span><span class="n">first_non_null</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># GH#32264 np.str_ object</span>
            <span class="n">guessed_format</span> <span class="o">=</span> <span class="n">guess_datetime_format</span><span class="p">(</span>
                <span class="n">first_non_nan_element</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">guessed_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">guessed_format</span>
            <span class="c1"># If there are multiple non-null elements, warn about</span>
            <span class="c1"># how parsing might not be consistent</span>
            <span class="k">if</span> <span class="n">tslib</span><span class="o">.</span><span class="n">first_non_null</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">first_non_null</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Could not infer format, so each element will be parsed &quot;</span>
                    <span class="s2">&quot;individually, falling back to `dateutil`. To ensure parsing is &quot;</span>
                    <span class="s2">&quot;consistent and as-expected, please specify a format.&quot;</span><span class="p">,</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">should_cache</span><span class="p">(</span>
    <span class="n">arg</span><span class="p">:</span> <span class="n">ArrayConvertible</span><span class="p">,</span> <span class="n">unique_share</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">check_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decides whether to do caching.</span>

<span class="sd">    If the percent of unique elements among `check_count` elements less</span>
<span class="sd">    than `unique_share * 100` then we can do caching.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg: listlike, tuple, 1-d array, Series</span>
<span class="sd">    unique_share: float, default=0.7, optional</span>
<span class="sd">        0 &lt; unique_share &lt; 1</span>
<span class="sd">    check_count: int, optional</span>
<span class="sd">        0 &lt;= check_count &lt;= len(arg)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    do_caching: bool</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    By default for a sequence of less than 50 items in size, we don&#39;t do</span>
<span class="sd">    caching; for the number of elements less than 5000, we take ten percent of</span>
<span class="sd">    all elements to check for a uniqueness share; if the sequence size is more</span>
<span class="sd">    than 5000, then we check only the first 500 elements.</span>
<span class="sd">    All constants were chosen empirically by.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">do_caching</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># default realization</span>
    <span class="k">if</span> <span class="n">check_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># in this case, the gain from caching is negligible</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">start_caching_at</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5000</span><span class="p">:</span>
            <span class="n">check_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check_count</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">check_count</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;check_count must be in next bounds: [0; len(arg)]&quot;</span>
        <span class="k">if</span> <span class="n">check_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">unique_share</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;unique_share must be in next bounds: (0; 1)&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># We can&#39;t cache if the items are not hashable.</span>
        <span class="n">unique_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">check_count</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_elements</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">check_count</span> <span class="o">*</span> <span class="n">unique_share</span><span class="p">:</span>
        <span class="n">do_caching</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">do_caching</span>


<span class="k">def</span> <span class="nf">_maybe_cache</span><span class="p">(</span>
    <span class="n">arg</span><span class="p">:</span> <span class="n">ArrayConvertible</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">convert_listlike</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a cache of unique dates from an array of dates</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg : listlike, tuple, 1-d array, Series</span>
<span class="sd">    format : string</span>
<span class="sd">        Strftime format to parse time</span>
<span class="sd">    cache : bool</span>
<span class="sd">        True attempts to create a cache of converted values</span>
<span class="sd">    convert_listlike : function</span>
<span class="sd">        Conversion function to apply on dates</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cache_array : Series</span>
<span class="sd">        Cache of converted, unique dates. Can be empty</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

    <span class="n">cache_array</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
        <span class="c1"># Perform a quicker unique check</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">should_cache</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cache_array</span>

        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_dates</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">cache_dates</span> <span class="o">=</span> <span class="n">convert_listlike</span><span class="p">(</span><span class="n">unique_dates</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
            <span class="c1"># GH#45319</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cache_array</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">cache_dates</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">unique_dates</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">OutOfBoundsDatetime</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache_array</span>
            <span class="c1"># GH#39882 and GH#35888 in case of None and NaT we get duplicates</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cache_array</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                <span class="n">cache_array</span> <span class="o">=</span> <span class="n">cache_array</span><span class="p">[</span><span class="o">~</span><span class="n">cache_array</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()]</span>
    <span class="k">return</span> <span class="n">cache_array</span>


<span class="k">def</span> <span class="nf">_box_as_indexlike</span><span class="p">(</span>
    <span class="n">dt_array</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Properly boxes the ndarray of datetimes to DatetimeIndex</span>
<span class="sd">    if it is possible or to generic Index instead</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dt_array: 1-d array</span>
<span class="sd">        Array of datetimes to be wrapped in an Index.</span>
<span class="sd">    utc : bool</span>
<span class="sd">        Whether to convert/localize timestamps to UTC.</span>
<span class="sd">    name : string, default None</span>
<span class="sd">        Name for a resulting index</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : datetime of converted dates</span>
<span class="sd">        - DatetimeIndex if convertible to sole datetime64 type</span>
<span class="sd">        - general Index otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">dt_array</span><span class="p">):</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="s2">&quot;utc&quot;</span> <span class="k">if</span> <span class="n">utc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">dt_array</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">dt_array</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_convert_and_box_cache</span><span class="p">(</span>
    <span class="n">arg</span><span class="p">:</span> <span class="n">DatetimeScalarOrArrayConvertible</span><span class="p">,</span>
    <span class="n">cache_array</span><span class="p">:</span> <span class="n">Series</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert array of dates with a cache and wrap the result in an Index.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg : integer, float, string, datetime, list, tuple, 1-d array, Series</span>
<span class="sd">    cache_array : Series</span>
<span class="sd">        Cache of converted, unique dates</span>
<span class="sd">    name : string, default None</span>
<span class="sd">        Name for a DatetimeIndex</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : Index-like of converted dates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cache_array</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cache_array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_box_as_indexlike</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">utc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_return_parsed_timezone_results</span><span class="p">(</span>
    <span class="n">result</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">timezones</span><span class="p">,</span> <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">name</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return results from array_strptime if a %z or %Z directive was passed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    result : ndarray[int64]</span>
<span class="sd">        int64 date representations of the dates</span>
<span class="sd">    timezones : ndarray</span>
<span class="sd">        pytz timezone objects</span>
<span class="sd">    utc : bool</span>
<span class="sd">        Whether to convert/localize timestamps to UTC.</span>
<span class="sd">    name : string, default None</span>
<span class="sd">        Name for a DatetimeIndex</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tz_result : Index-like of parsed dates with timezone</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tz_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">zone</span> <span class="ow">in</span> <span class="n">unique</span><span class="p">(</span><span class="n">timezones</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">timezones</span> <span class="o">==</span> <span class="n">zone</span>
        <span class="n">dta</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">utc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dta</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dta</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="s2">&quot;utc&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dta</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s2">&quot;utc&quot;</span><span class="p">)</span>
        <span class="n">tz_results</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">dta</span>

    <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">tz_results</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_convert_listlike_datetimes</span><span class="p">(</span>
    <span class="n">arg</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">errors</span><span class="p">:</span> <span class="n">DateTimeErrorChoices</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="n">dayfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">yearfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for to_datetime. Performs the conversions of 1D listlike</span>
<span class="sd">    of dates</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg : list, tuple, ndarray, Series, Index</span>
<span class="sd">        date to be parsed</span>
<span class="sd">    name : object</span>
<span class="sd">        None or string for the Index name</span>
<span class="sd">    utc : bool</span>
<span class="sd">        Whether to convert/localize timestamps to UTC.</span>
<span class="sd">    unit : str</span>
<span class="sd">        None or string of the frequency of the passed data</span>
<span class="sd">    errors : str</span>
<span class="sd">        error handing behaviors from to_datetime, &#39;raise&#39;, &#39;coerce&#39;, &#39;ignore&#39;</span>
<span class="sd">    dayfirst : bool</span>
<span class="sd">        dayfirst parsing behavior from to_datetime</span>
<span class="sd">    yearfirst : bool</span>
<span class="sd">        yearfirst parsing behavior from to_datetime</span>
<span class="sd">    exact : bool, default True</span>
<span class="sd">        exact format matching behavior from to_datetime</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Index-like of parsed dates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;O&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">PandasArray</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="n">arg_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="c1"># these are shortcutable</span>
    <span class="n">tz</span> <span class="o">=</span> <span class="s2">&quot;utc&quot;</span> <span class="k">if</span> <span class="n">utc</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">arg_dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">DatetimeArray</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">utc</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="s2">&quot;utc&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg</span>

    <span class="k">elif</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">arg_dtype</span><span class="p">):</span>
        <span class="n">arg_dtype</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arg_dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_supported_unit</span><span class="p">(</span><span class="n">get_unit_from_dtype</span><span class="p">(</span><span class="n">arg_dtype</span><span class="p">)):</span>
            <span class="c1"># We go to closest supported reso, i.e. &quot;s&quot;</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">astype_overflowsafe</span><span class="p">(</span>
                <span class="c1"># TODO: looks like we incorrectly raise with errors==&quot;ignore&quot;</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arg</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;M8[s]&quot;</span><span class="p">),</span>
                <span class="n">is_coerce</span><span class="o">=</span><span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;coerce&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">DatetimeArray</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">utc</span><span class="p">:</span>
            <span class="c1"># DatetimeArray, DatetimeIndex</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="s2">&quot;utc&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">arg</span>

    <span class="k">elif</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot specify both format and unit&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_datetime_with_unit</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">utc</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;arg must be a string, datetime, list, tuple, 1-d array, or Series&quot;</span>
        <span class="p">)</span>

    <span class="c1"># warn if passing timedelta64, raise for PeriodDtype</span>
    <span class="c1"># NB: this must come after unit transformation</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">arg</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">maybe_convert_dtype</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">libtimezones</span><span class="o">.</span><span class="n">maybe_get_tz</span><span class="p">(</span><span class="n">tz</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;coerce&quot;</span><span class="p">:</span>
            <span class="n">npvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;NaT&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">npvalues</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;ignore&quot;</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">idx</span>
        <span class="k">raise</span>

    <span class="n">arg</span> <span class="o">=</span> <span class="n">ensure_object</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="n">_guess_datetime_format_for_array</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">)</span>

    <span class="c1"># `format` could be inferred, or user didn&#39;t ask for mixed-format parsing.</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">format</span> <span class="o">!=</span> <span class="s2">&quot;mixed&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_array_strptime_with_fallback</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">utc</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>

    <span class="n">result</span><span class="p">,</span> <span class="n">tz_parsed</span> <span class="o">=</span> <span class="n">objects_to_datetime64ns</span><span class="p">(</span>
        <span class="n">arg</span><span class="p">,</span>
        <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span>
        <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">,</span>
        <span class="n">utc</span><span class="o">=</span><span class="n">utc</span><span class="p">,</span>
        <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
        <span class="n">allow_object</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">tz_parsed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># We can take a shortcut since the datetime64 numpy array</span>
        <span class="c1"># is in UTC</span>
        <span class="n">dta</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tz_to_dtype</span><span class="p">(</span><span class="n">tz_parsed</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_box_as_indexlike</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">utc</span><span class="o">=</span><span class="n">utc</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_array_strptime_with_fallback</span><span class="p">(</span>
    <span class="n">arg</span><span class="p">,</span>
    <span class="n">name</span><span class="p">,</span>
    <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">fmt</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">exact</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Call array_strptime, with fallback behavior depending on &#39;errors&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">timezones</span> <span class="o">=</span> <span class="n">array_strptime</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exact</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="n">utc</span><span class="o">=</span><span class="n">utc</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">tz</span> <span class="ow">in</span> <span class="n">timezones</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_return_parsed_timezone_results</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">timezones</span><span class="p">,</span> <span class="n">utc</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_box_as_indexlike</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">utc</span><span class="o">=</span><span class="n">utc</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_to_datetime_with_unit</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    to_datetime specalized to the case where a &#39;unit&#39; is passed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># GH#30050 pass an ndarray to tslib.array_with_unit_to_datetime</span>
    <span class="c1"># because it expects an ndarray argument</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IntegerArray</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;datetime64[</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">tz_parsed</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">]:</span>
            <span class="c1"># Note we can&#39;t do &quot;f&quot; here because that could induce unwanted</span>
            <span class="c1">#  rounding GH#14156, GH#20445</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;datetime64[</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">astype_overflowsafe</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;M8[ns]&quot;</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">OutOfBoundsDatetime</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">_to_datetime_with_unit</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">utc</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
            <span class="n">tz_parsed</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">arg</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
            <span class="n">mult</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">precision_from_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="n">iNaT</span><span class="p">)</span>
            <span class="n">fvalues</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;f8&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">fvalues</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fvalues</span> <span class="o">&lt;</span> <span class="n">Timestamp</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">fvalues</span> <span class="o">&gt;</span> <span class="n">Timestamp</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">_value</span>
            <span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">errors</span> <span class="o">!=</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
                    <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">_to_datetime_with_unit</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">utc</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">OutOfBoundsDatetime</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot convert input with unit &#39;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

            <span class="n">arr</span> <span class="o">=</span> <span class="n">fvalues</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;M8[ns]&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;NaT&quot;</span><span class="p">,</span> <span class="s2">&quot;ns&quot;</span><span class="p">)</span>

            <span class="n">tz_parsed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">arr</span><span class="p">,</span> <span class="n">tz_parsed</span> <span class="o">=</span> <span class="n">tslib</span><span class="o">.</span><span class="n">array_with_unit_to_datetime</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;ignore&quot;</span><span class="p">:</span>
        <span class="c1"># Index constructor _may_ infer to DatetimeIndex</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Index</span><span class="o">.</span><span class="n">_with_infer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># GH#23758: We may still need to localize the result with tz</span>
    <span class="c1"># GH#25546: Apply tz_parsed first (from arg), then tz (from caller)</span>
    <span class="c1"># result will be naive but in UTC</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="s2">&quot;UTC&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">tz_parsed</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">utc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="s2">&quot;utc&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s2">&quot;utc&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_adjust_to_origin</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for to_datetime.</span>
<span class="sd">    Adjust input argument to the specified origin</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg : list, tuple, ndarray, Series, Index</span>
<span class="sd">        date to be adjusted</span>
<span class="sd">    origin : &#39;julian&#39; or Timestamp</span>
<span class="sd">        origin offset for the arg</span>
<span class="sd">    unit : str</span>
<span class="sd">        passed unit from to_datetime, must be &#39;D&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray or scalar of adjusted date(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s2">&quot;julian&quot;</span><span class="p">:</span>
        <span class="n">original</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="n">j0</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to_julian_date</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">!=</span> <span class="s2">&quot;D&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unit must be &#39;D&#39; for origin=&#39;julian&#39;&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">-</span> <span class="n">j0</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;incompatible &#39;arg&#39; type for given &#39;origin&#39;=&#39;julian&#39;&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># preemptively check this for a nice range</span>
        <span class="n">j_max</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">to_julian_date</span><span class="p">()</span> <span class="o">-</span> <span class="n">j0</span>
        <span class="n">j_min</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">to_julian_date</span><span class="p">()</span> <span class="o">-</span> <span class="n">j0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">arg</span> <span class="o">&gt;</span> <span class="n">j_max</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">arg</span> <span class="o">&lt;</span> <span class="n">j_min</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">OutOfBoundsDatetime</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">original</span><span class="si">}</span><span class="s2"> is Out of Bounds for origin=&#39;julian&#39;&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># arg must be numeric</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_integer</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_float</span><span class="p">(</span><span class="n">arg</span><span class="p">)))</span>
            <span class="ow">or</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">&#39; is not compatible with origin=&#39;</span><span class="si">{</span><span class="n">origin</span><span class="si">}</span><span class="s2">&#39;; &quot;</span>
                <span class="s2">&quot;it must be numeric with a unit specified&quot;</span>
            <span class="p">)</span>

        <span class="c1"># we are going to offset back to unix / epoch time</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">OutOfBoundsDatetime</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OutOfBoundsDatetime</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;origin </span><span class="si">{</span><span class="n">origin</span><span class="si">}</span><span class="s2"> is Out of Bounds&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;origin </span><span class="si">{</span><span class="n">origin</span><span class="si">}</span><span class="s2"> cannot be converted to a Timestamp&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="k">if</span> <span class="n">offset</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;origin offset </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2"> must be tz-naive&quot;</span><span class="p">)</span>
        <span class="n">td_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">Timestamp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># convert the offset to the unit of the arg</span>
        <span class="c1"># this should be lossless in terms of precision</span>
        <span class="n">ioffset</span> <span class="o">=</span> <span class="n">td_offset</span> <span class="o">//</span> <span class="n">Timedelta</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>

        <span class="c1"># scalars &amp; ndarray-like can handle the addition</span>
        <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="n">ioffset</span>
    <span class="k">return</span> <span class="n">arg</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">to_datetime</span><span class="p">(</span>
    <span class="n">arg</span><span class="p">:</span> <span class="n">DatetimeScalar</span><span class="p">,</span>
    <span class="n">errors</span><span class="p">:</span> <span class="n">DateTimeErrorChoices</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">dayfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">yearfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">exact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">infer_datetime_format</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">origin</span><span class="o">=...</span><span class="p">,</span>
    <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Timestamp</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">to_datetime</span><span class="p">(</span>
    <span class="n">arg</span><span class="p">:</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DictConvertible</span><span class="p">,</span>
    <span class="n">errors</span><span class="p">:</span> <span class="n">DateTimeErrorChoices</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">dayfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">yearfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">exact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">infer_datetime_format</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">origin</span><span class="o">=...</span><span class="p">,</span>
    <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">to_datetime</span><span class="p">(</span>
    <span class="n">arg</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="n">Index</span> <span class="o">|</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">errors</span><span class="p">:</span> <span class="n">DateTimeErrorChoices</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">dayfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">yearfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">exact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">infer_datetime_format</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">origin</span><span class="o">=...</span><span class="p">,</span>
    <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeIndex</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="to_datetime"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.to_datetime">[docs]</a><span class="k">def</span> <span class="nf">to_datetime</span><span class="p">(</span>
    <span class="n">arg</span><span class="p">:</span> <span class="n">DatetimeScalarOrArrayConvertible</span> <span class="o">|</span> <span class="n">DictConvertible</span><span class="p">,</span>
    <span class="n">errors</span><span class="p">:</span> <span class="n">DateTimeErrorChoices</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="n">dayfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">yearfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
    <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">infer_datetime_format</span><span class="p">:</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
    <span class="n">origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;unix&quot;</span><span class="p">,</span>
    <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeIndex</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DatetimeScalar</span> <span class="o">|</span> <span class="n">NaTType</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert argument to datetime.</span>

<span class="sd">    This function converts a scalar, array-like, :class:`Series` or</span>
<span class="sd">    :class:`DataFrame`/dict-like to a pandas datetime object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg : int, float, str, datetime, list, tuple, 1-d array, Series, DataFrame/dict-like</span>
<span class="sd">        The object to convert to a datetime. If a :class:`DataFrame` is provided, the</span>
<span class="sd">        method expects minimally the following columns: :const:`&quot;year&quot;`,</span>
<span class="sd">        :const:`&quot;month&quot;`, :const:`&quot;day&quot;`.</span>
<span class="sd">    errors : {&#39;ignore&#39;, &#39;raise&#39;, &#39;coerce&#39;}, default &#39;raise&#39;</span>
<span class="sd">        - If :const:`&#39;raise&#39;`, then invalid parsing will raise an exception.</span>
<span class="sd">        - If :const:`&#39;coerce&#39;`, then invalid parsing will be set as :const:`NaT`.</span>
<span class="sd">        - If :const:`&#39;ignore&#39;`, then invalid parsing will return the input.</span>
<span class="sd">    dayfirst : bool, default False</span>
<span class="sd">        Specify a date parse order if `arg` is str or is list-like.</span>
<span class="sd">        If :const:`True`, parses dates with the day first, e.g. :const:`&quot;10/11/12&quot;`</span>
<span class="sd">        is parsed as :const:`2012-11-10`.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            ``dayfirst=True`` is not strict, but will prefer to parse</span>
<span class="sd">            with day first.</span>

<span class="sd">    yearfirst : bool, default False</span>
<span class="sd">        Specify a date parse order if `arg` is str or is list-like.</span>

<span class="sd">        - If :const:`True` parses dates with the year first, e.g.</span>
<span class="sd">          :const:`&quot;10/11/12&quot;` is parsed as :const:`2010-11-12`.</span>
<span class="sd">        - If both `dayfirst` and `yearfirst` are :const:`True`, `yearfirst` is</span>
<span class="sd">          preceded (same as :mod:`dateutil`).</span>

<span class="sd">        .. warning::</span>

<span class="sd">            ``yearfirst=True`` is not strict, but will prefer to parse</span>
<span class="sd">            with year first.</span>

<span class="sd">    utc : bool, default False</span>
<span class="sd">        Control timezone-related parsing, localization and conversion.</span>

<span class="sd">        - If :const:`True`, the function *always* returns a timezone-aware</span>
<span class="sd">          UTC-localized :class:`Timestamp`, :class:`Series` or</span>
<span class="sd">          :class:`DatetimeIndex`. To do this, timezone-naive inputs are</span>
<span class="sd">          *localized* as UTC, while timezone-aware inputs are *converted* to UTC.</span>

<span class="sd">        - If :const:`False` (default), inputs will not be coerced to UTC.</span>
<span class="sd">          Timezone-naive inputs will remain naive, while timezone-aware ones</span>
<span class="sd">          will keep their time offsets. Limitations exist for mixed</span>
<span class="sd">          offsets (typically, daylight savings), see :ref:`Examples</span>
<span class="sd">          &lt;to_datetime_tz_examples&gt;` section for details.</span>

<span class="sd">        See also: pandas general documentation about `timezone conversion and</span>
<span class="sd">        localization</span>
<span class="sd">        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html</span>
<span class="sd">        #time-zone-handling&gt;`_.</span>

<span class="sd">    format : str, default None</span>
<span class="sd">        The strftime to parse time, e.g. :const:`&quot;%d/%m/%Y&quot;`. See</span>
<span class="sd">        `strftime documentation</span>
<span class="sd">        &lt;https://docs.python.org/3/library/datetime.html</span>
<span class="sd">        #strftime-and-strptime-behavior&gt;`_ for more information on choices, though</span>
<span class="sd">        note that :const:`&quot;%f&quot;` will parse all the way up to nanoseconds.</span>
<span class="sd">        You can also pass:</span>

<span class="sd">        - &quot;ISO8601&quot;, to parse any `ISO8601 &lt;https://en.wikipedia.org/wiki/ISO_8601&gt;`_</span>
<span class="sd">          time string (not necessarily in exactly the same format);</span>
<span class="sd">        - &quot;mixed&quot;, to infer the format for each element individually. This is risky,</span>
<span class="sd">          and you should probably use it along with `dayfirst`.</span>
<span class="sd">    exact : bool, default True</span>
<span class="sd">        Control how `format` is used:</span>

<span class="sd">        - If :const:`True`, require an exact `format` match.</span>
<span class="sd">        - If :const:`False`, allow the `format` to match anywhere in the target</span>
<span class="sd">          string.</span>

<span class="sd">        Cannot be used alongside ``format=&#39;ISO8601&#39;`` or ``format=&#39;mixed&#39;``.</span>
<span class="sd">    unit : str, default &#39;ns&#39;</span>
<span class="sd">        The unit of the arg (D,s,ms,us,ns) denote the unit, which is an</span>
<span class="sd">        integer or float number. This will be based off the origin.</span>
<span class="sd">        Example, with ``unit=&#39;ms&#39;`` and ``origin=&#39;unix&#39;``, this would calculate</span>
<span class="sd">        the number of milliseconds to the unix epoch start.</span>
<span class="sd">    infer_datetime_format : bool, default False</span>
<span class="sd">        If :const:`True` and no `format` is given, attempt to infer the format</span>
<span class="sd">        of the datetime strings based on the first non-NaN element,</span>
<span class="sd">        and if it can be inferred, switch to a faster method of parsing them.</span>
<span class="sd">        In some cases this can increase the parsing speed by ~5-10x.</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            A strict version of this argument is now the default, passing it has</span>
<span class="sd">            no effect.</span>

<span class="sd">    origin : scalar, default &#39;unix&#39;</span>
<span class="sd">        Define the reference date. The numeric values would be parsed as number</span>
<span class="sd">        of units (defined by `unit`) since this reference date.</span>

<span class="sd">        - If :const:`&#39;unix&#39;` (or POSIX) time; origin is set to 1970-01-01.</span>
<span class="sd">        - If :const:`&#39;julian&#39;`, unit must be :const:`&#39;D&#39;`, and origin is set to</span>
<span class="sd">          beginning of Julian Calendar. Julian day number :const:`0` is assigned</span>
<span class="sd">          to the day starting at noon on January 1, 4713 BC.</span>
<span class="sd">        - If Timestamp convertible (Timestamp, dt.datetime, np.datetimt64 or date</span>
<span class="sd">          string), origin is set to Timestamp identified by origin.</span>
<span class="sd">        - If a float or integer, origin is the millisecond difference</span>
<span class="sd">          relative to 1970-01-01.</span>
<span class="sd">    cache : bool, default True</span>
<span class="sd">        If :const:`True`, use a cache of unique, converted dates to apply the</span>
<span class="sd">        datetime conversion. May produce significant speed-up when parsing</span>
<span class="sd">        duplicate date strings, especially ones with timezone offsets. The cache</span>
<span class="sd">        is only used when there are at least 50 values. The presence of</span>
<span class="sd">        out-of-bounds values will render the cache unusable and may slow down</span>
<span class="sd">        parsing.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    datetime</span>
<span class="sd">        If parsing succeeded.</span>
<span class="sd">        Return type depends on input (types in parenthesis correspond to</span>
<span class="sd">        fallback in case of unsuccessful timezone or out-of-range timestamp</span>
<span class="sd">        parsing):</span>

<span class="sd">        - scalar: :class:`Timestamp` (or :class:`datetime.datetime`)</span>
<span class="sd">        - array-like: :class:`DatetimeIndex` (or :class:`Series` with</span>
<span class="sd">          :class:`object` dtype containing :class:`datetime.datetime`)</span>
<span class="sd">        - Series: :class:`Series` of :class:`datetime64` dtype (or</span>
<span class="sd">          :class:`Series` of :class:`object` dtype containing</span>
<span class="sd">          :class:`datetime.datetime`)</span>
<span class="sd">        - DataFrame: :class:`Series` of :class:`datetime64` dtype (or</span>
<span class="sd">          :class:`Series` of :class:`object` dtype containing</span>
<span class="sd">          :class:`datetime.datetime`)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParserError</span>
<span class="sd">        When parsing a date from string fails.</span>
<span class="sd">    ValueError</span>
<span class="sd">        When another datetime conversion error happens. For example when one</span>
<span class="sd">        of &#39;year&#39;, &#39;month&#39;, day&#39; columns is missing in a :class:`DataFrame`, or</span>
<span class="sd">        when a Timezone-aware :class:`datetime.datetime` is found in an array-like</span>
<span class="sd">        of mixed time offsets, and ``utc=False``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DataFrame.astype : Cast argument to a specified dtype.</span>
<span class="sd">    to_timedelta : Convert argument to timedelta.</span>
<span class="sd">    convert_dtypes : Convert dtypes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Many input types are supported, and lead to different output types:</span>

<span class="sd">    - **scalars** can be int, float, str, datetime object (from stdlib :mod:`datetime`</span>
<span class="sd">      module or :mod:`numpy`). They are converted to :class:`Timestamp` when</span>
<span class="sd">      possible, otherwise they are converted to :class:`datetime.datetime`.</span>
<span class="sd">      None/NaN/null scalars are converted to :const:`NaT`.</span>

<span class="sd">    - **array-like** can contain int, float, str, datetime objects. They are</span>
<span class="sd">      converted to :class:`DatetimeIndex` when possible, otherwise they are</span>
<span class="sd">      converted to :class:`Index` with :class:`object` dtype, containing</span>
<span class="sd">      :class:`datetime.datetime`. None/NaN/null entries are converted to</span>
<span class="sd">      :const:`NaT` in both cases.</span>

<span class="sd">    - **Series** are converted to :class:`Series` with :class:`datetime64`</span>
<span class="sd">      dtype when possible, otherwise they are converted to :class:`Series` with</span>
<span class="sd">      :class:`object` dtype, containing :class:`datetime.datetime`. None/NaN/null</span>
<span class="sd">      entries are converted to :const:`NaT` in both cases.</span>

<span class="sd">    - **DataFrame/dict-like** are converted to :class:`Series` with</span>
<span class="sd">      :class:`datetime64` dtype. For each row a datetime is created from assembling</span>
<span class="sd">      the various dataframe columns. Column keys can be common abbreviations</span>
<span class="sd">      like [‘year’, ‘month’, ‘day’, ‘minute’, ‘second’, ‘ms’, ‘us’, ‘ns’]) or</span>
<span class="sd">      plurals of the same.</span>

<span class="sd">    The following causes are responsible for :class:`datetime.datetime` objects</span>
<span class="sd">    being returned (possibly inside an :class:`Index` or a :class:`Series` with</span>
<span class="sd">    :class:`object` dtype) instead of a proper pandas designated type</span>
<span class="sd">    (:class:`Timestamp`, :class:`DatetimeIndex` or :class:`Series`</span>
<span class="sd">    with :class:`datetime64` dtype):</span>

<span class="sd">    - when any input element is before :const:`Timestamp.min` or after</span>
<span class="sd">      :const:`Timestamp.max`, see `timestamp limitations</span>
<span class="sd">      &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html</span>
<span class="sd">      #timeseries-timestamp-limits&gt;`_.</span>

<span class="sd">    - when ``utc=False`` (default) and the input is an array-like or</span>
<span class="sd">      :class:`Series` containing mixed naive/aware datetime, or aware with mixed</span>
<span class="sd">      time offsets. Note that this happens in the (quite frequent) situation when</span>
<span class="sd">      the timezone has a daylight savings policy. In that case you may wish to</span>
<span class="sd">      use ``utc=True``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    **Handling various input formats**</span>

<span class="sd">    Assembling a datetime from multiple columns of a :class:`DataFrame`. The keys</span>
<span class="sd">    can be common abbreviations like [&#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;minute&#39;, &#39;second&#39;,</span>
<span class="sd">    &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39;]) or plurals of the same</span>

<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame({&#39;year&#39;: [2015, 2016],</span>
<span class="sd">    ...                    &#39;month&#39;: [2, 3],</span>
<span class="sd">    ...                    &#39;day&#39;: [4, 5]})</span>
<span class="sd">    &gt;&gt;&gt; pd.to_datetime(df)</span>
<span class="sd">    0   2015-02-04</span>
<span class="sd">    1   2016-03-05</span>
<span class="sd">    dtype: datetime64[ns]</span>

<span class="sd">    Using a unix epoch time</span>

<span class="sd">    &gt;&gt;&gt; pd.to_datetime(1490195805, unit=&#39;s&#39;)</span>
<span class="sd">    Timestamp(&#39;2017-03-22 15:16:45&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pd.to_datetime(1490195805433502912, unit=&#39;ns&#39;)</span>
<span class="sd">    Timestamp(&#39;2017-03-22 15:16:45.433502912&#39;)</span>

<span class="sd">    .. warning:: For float arg, precision rounding might happen. To prevent</span>
<span class="sd">        unexpected behavior use a fixed-width exact type.</span>

<span class="sd">    Using a non-unix epoch origin</span>

<span class="sd">    &gt;&gt;&gt; pd.to_datetime([1, 2, 3], unit=&#39;D&#39;,</span>
<span class="sd">    ...                origin=pd.Timestamp(&#39;1960-01-01&#39;))</span>
<span class="sd">    DatetimeIndex([&#39;1960-01-02&#39;, &#39;1960-01-03&#39;, &#39;1960-01-04&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">    **Differences with strptime behavior**</span>

<span class="sd">    :const:`&quot;%f&quot;` will parse all the way up to nanoseconds.</span>

<span class="sd">    &gt;&gt;&gt; pd.to_datetime(&#39;2018-10-26 12:00:00.0000000011&#39;,</span>
<span class="sd">    ...                format=&#39;%Y-%m-%d %H:%M:%S.%f&#39;)</span>
<span class="sd">    Timestamp(&#39;2018-10-26 12:00:00.000000001&#39;)</span>

<span class="sd">    **Non-convertible date/times**</span>

<span class="sd">    If a date does not meet the `timestamp limitations</span>
<span class="sd">    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html</span>
<span class="sd">    #timeseries-timestamp-limits&gt;`_, passing ``errors=&#39;ignore&#39;``</span>
<span class="sd">    will return the original input instead of raising any exception.</span>

<span class="sd">    Passing ``errors=&#39;coerce&#39;`` will force an out-of-bounds date to :const:`NaT`,</span>
<span class="sd">    in addition to forcing non-dates (or non-parseable dates) to :const:`NaT`.</span>

<span class="sd">    &gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;ignore&#39;)</span>
<span class="sd">    &#39;13000101&#39;</span>
<span class="sd">    &gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;coerce&#39;)</span>
<span class="sd">    NaT</span>

<span class="sd">    .. _to_datetime_tz_examples:</span>

<span class="sd">    **Timezones and time offsets**</span>

<span class="sd">    The default behaviour (``utc=False``) is as follows:</span>

<span class="sd">    - Timezone-naive inputs are converted to timezone-naive :class:`DatetimeIndex`:</span>

<span class="sd">    &gt;&gt;&gt; pd.to_datetime([&#39;2018-10-26 12:00:00&#39;, &#39;2018-10-26 13:00:15&#39;])</span>
<span class="sd">    DatetimeIndex([&#39;2018-10-26 12:00:00&#39;, &#39;2018-10-26 13:00:15&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">    - Timezone-aware inputs *with constant time offset* are converted to</span>
<span class="sd">      timezone-aware :class:`DatetimeIndex`:</span>

<span class="sd">    &gt;&gt;&gt; pd.to_datetime([&#39;2018-10-26 12:00 -0500&#39;, &#39;2018-10-26 13:00 -0500&#39;])</span>
<span class="sd">    DatetimeIndex([&#39;2018-10-26 12:00:00-05:00&#39;, &#39;2018-10-26 13:00:00-05:00&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns, UTC-05:00]&#39;, freq=None)</span>

<span class="sd">    - However, timezone-aware inputs *with mixed time offsets* (for example</span>
<span class="sd">      issued from a timezone with daylight savings, such as Europe/Paris)</span>
<span class="sd">      are **not successfully converted** to a :class:`DatetimeIndex`. Instead a</span>
<span class="sd">      simple :class:`Index` containing :class:`datetime.datetime` objects is</span>
<span class="sd">      returned:</span>

<span class="sd">    &gt;&gt;&gt; pd.to_datetime([&#39;2020-10-25 02:00 +0200&#39;, &#39;2020-10-25 04:00 +0100&#39;])</span>
<span class="sd">    Index([2020-10-25 02:00:00+02:00, 2020-10-25 04:00:00+01:00],</span>
<span class="sd">          dtype=&#39;object&#39;)</span>

<span class="sd">    - A mix of timezone-aware and timezone-naive inputs is also converted to</span>
<span class="sd">      a simple :class:`Index` containing :class:`datetime.datetime` objects:</span>

<span class="sd">    &gt;&gt;&gt; from datetime import datetime</span>
<span class="sd">    &gt;&gt;&gt; pd.to_datetime([&quot;2020-01-01 01:00:00-01:00&quot;, datetime(2020, 1, 1, 3, 0)])</span>
<span class="sd">    Index([2020-01-01 01:00:00-01:00, 2020-01-01 03:00:00], dtype=&#39;object&#39;)</span>

<span class="sd">    |</span>

<span class="sd">    Setting ``utc=True`` solves most of the above issues:</span>

<span class="sd">    - Timezone-naive inputs are *localized* as UTC</span>

<span class="sd">    &gt;&gt;&gt; pd.to_datetime([&#39;2018-10-26 12:00&#39;, &#39;2018-10-26 13:00&#39;], utc=True)</span>
<span class="sd">    DatetimeIndex([&#39;2018-10-26 12:00:00+00:00&#39;, &#39;2018-10-26 13:00:00+00:00&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns, UTC]&#39;, freq=None)</span>

<span class="sd">    - Timezone-aware inputs are *converted* to UTC (the output represents the</span>
<span class="sd">      exact same datetime, but viewed from the UTC time offset `+00:00`).</span>

<span class="sd">    &gt;&gt;&gt; pd.to_datetime([&#39;2018-10-26 12:00 -0530&#39;, &#39;2018-10-26 12:00 -0500&#39;],</span>
<span class="sd">    ...                utc=True)</span>
<span class="sd">    DatetimeIndex([&#39;2018-10-26 17:30:00+00:00&#39;, &#39;2018-10-26 17:00:00+00:00&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns, UTC]&#39;, freq=None)</span>

<span class="sd">    - Inputs can contain both string or datetime, the above</span>
<span class="sd">      rules still apply</span>

<span class="sd">    &gt;&gt;&gt; pd.to_datetime([&#39;2018-10-26 12:00&#39;, datetime(2020, 1, 1, 18)], utc=True)</span>
<span class="sd">    DatetimeIndex([&#39;2018-10-26 12:00:00+00:00&#39;, &#39;2020-01-01 18:00:00+00:00&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns, UTC]&#39;, freq=None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span> <span class="ow">and</span> <span class="nb">format</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;mixed&quot;</span><span class="p">,</span> <span class="s2">&quot;ISO8601&quot;</span><span class="p">}:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use &#39;exact&#39; when &#39;format&#39; is &#39;mixed&#39; or &#39;ISO8601&#39;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">infer_datetime_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The argument &#39;infer_datetime_format&#39; is deprecated and will &quot;</span>
            <span class="s2">&quot;be removed in a future version. &quot;</span>
            <span class="s2">&quot;A strict version of it is now the default, see &quot;</span>
            <span class="s2">&quot;https://pandas.pydata.org/pdeps/0004-consistent-to-datetime-parsing.html. &quot;</span>
            <span class="s2">&quot;You can safely remove this argument.&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">origin</span> <span class="o">!=</span> <span class="s2">&quot;unix&quot;</span><span class="p">:</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">_adjust_to_origin</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

    <span class="n">convert_listlike</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">_convert_listlike_datetimes</span><span class="p">,</span>
        <span class="n">utc</span><span class="o">=</span><span class="n">utc</span><span class="p">,</span>
        <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
        <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span>
        <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">,</span>
        <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
        <span class="n">exact</span><span class="o">=</span><span class="n">exact</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># pylint: disable-next=used-before-assignment</span>
    <span class="n">result</span><span class="p">:</span> <span class="n">Timestamp</span> <span class="o">|</span> <span class="n">NaTType</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">Index</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">if</span> <span class="n">utc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s2">&quot;utc&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="s2">&quot;utc&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
        <span class="n">cache_array</span> <span class="o">=</span> <span class="n">_maybe_cache</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">convert_listlike</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cache_array</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cache_array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">convert_listlike</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">arg</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCDataFrame</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">)):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_assemble_from_unit_mappings</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">utc</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
        <span class="n">cache_array</span> <span class="o">=</span> <span class="n">_maybe_cache</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">convert_listlike</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cache_array</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_convert_and_box_cache</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">cache_array</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convert_listlike</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># error: Argument 1 to &quot;_maybe_cache&quot; has incompatible type</span>
            <span class="c1"># &quot;Union[float, str, datetime, List[Any], Tuple[Any, ...], ExtensionArray,</span>
            <span class="c1"># ndarray[Any, Any], Series]&quot;; expected &quot;Union[List[Any], Tuple[Any, ...],</span>
            <span class="c1"># Union[Union[ExtensionArray, ndarray[Any, Any]], Index, Series], Series]&quot;</span>
            <span class="n">argc</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="s2">&quot;Series&quot;</span><span class="p">,</span> <span class="n">Index</span><span class="p">],</span> <span class="n">arg</span>
            <span class="p">)</span>
            <span class="n">cache_array</span> <span class="o">=</span> <span class="n">_maybe_cache</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">convert_listlike</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">OutOfBoundsDatetime</span><span class="p">:</span>
            <span class="c1"># caching attempts to create a DatetimeIndex, which may raise</span>
            <span class="c1"># an OOB. If that&#39;s the desired behavior, then just reraise...</span>
            <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="c1"># ... otherwise, continue without the cache.</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

            <span class="n">cache_array</span> <span class="o">=</span> <span class="n">Series</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>  <span class="c1"># just an empty array</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cache_array</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_convert_and_box_cache</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">cache_array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convert_listlike</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">convert_listlike</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">arg</span><span class="p">]),</span> <span class="nb">format</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># TODO: avoid this kludge.</span>

    <span class="c1">#  error: Incompatible return value type (got &quot;Union[Timestamp, NaTType,</span>
    <span class="c1"># Series, Index]&quot;, expected &quot;Union[DatetimeIndex, Series, float, str,</span>
    <span class="c1"># NaTType, None]&quot;)</span>
    <span class="k">return</span> <span class="n">result</span>  <span class="c1"># type: ignore[return-value]</span></div>


<span class="c1"># mappings for assembling units</span>
<span class="n">_unit_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="s2">&quot;year&quot;</span><span class="p">,</span>
    <span class="s2">&quot;years&quot;</span><span class="p">:</span> <span class="s2">&quot;year&quot;</span><span class="p">,</span>
    <span class="s2">&quot;month&quot;</span><span class="p">:</span> <span class="s2">&quot;month&quot;</span><span class="p">,</span>
    <span class="s2">&quot;months&quot;</span><span class="p">:</span> <span class="s2">&quot;month&quot;</span><span class="p">,</span>
    <span class="s2">&quot;day&quot;</span><span class="p">:</span> <span class="s2">&quot;day&quot;</span><span class="p">,</span>
    <span class="s2">&quot;days&quot;</span><span class="p">:</span> <span class="s2">&quot;day&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hour&quot;</span><span class="p">:</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hours&quot;</span><span class="p">:</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span>
    <span class="s2">&quot;minute&quot;</span><span class="p">:</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span>
    <span class="s2">&quot;minutes&quot;</span><span class="p">:</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span>
    <span class="s2">&quot;second&quot;</span><span class="p">:</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span>
    <span class="s2">&quot;seconds&quot;</span><span class="p">:</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ms&quot;</span><span class="p">:</span> <span class="s2">&quot;ms&quot;</span><span class="p">,</span>
    <span class="s2">&quot;millisecond&quot;</span><span class="p">:</span> <span class="s2">&quot;ms&quot;</span><span class="p">,</span>
    <span class="s2">&quot;milliseconds&quot;</span><span class="p">:</span> <span class="s2">&quot;ms&quot;</span><span class="p">,</span>
    <span class="s2">&quot;us&quot;</span><span class="p">:</span> <span class="s2">&quot;us&quot;</span><span class="p">,</span>
    <span class="s2">&quot;microsecond&quot;</span><span class="p">:</span> <span class="s2">&quot;us&quot;</span><span class="p">,</span>
    <span class="s2">&quot;microseconds&quot;</span><span class="p">:</span> <span class="s2">&quot;us&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ns&quot;</span><span class="p">:</span> <span class="s2">&quot;ns&quot;</span><span class="p">,</span>
    <span class="s2">&quot;nanosecond&quot;</span><span class="p">:</span> <span class="s2">&quot;ns&quot;</span><span class="p">,</span>
    <span class="s2">&quot;nanoseconds&quot;</span><span class="p">:</span> <span class="s2">&quot;ns&quot;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_assemble_from_unit_mappings</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="n">DateTimeErrorChoices</span><span class="p">,</span> <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    assemble the unit specified fields from the arg (DataFrame)</span>
<span class="sd">    Return a Series for actual parsing</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg : DataFrame</span>
<span class="sd">    errors : {&#39;ignore&#39;, &#39;raise&#39;, &#39;coerce&#39;}, default &#39;raise&#39;</span>

<span class="sd">        - If :const:`&#39;raise&#39;`, then invalid parsing will raise an exception</span>
<span class="sd">        - If :const:`&#39;coerce&#39;`, then invalid parsing will be set as :const:`NaT`</span>
<span class="sd">        - If :const:`&#39;ignore&#39;`, then invalid parsing will return the input</span>
<span class="sd">    utc : bool</span>
<span class="sd">        Whether to convert/localize timestamps to UTC.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Series</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">to_numeric</span><span class="p">,</span>
        <span class="n">to_timedelta</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">arg</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arg</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot assemble with duplicate keys&quot;</span><span class="p">)</span>

    <span class="c1"># replace passed unit with _unit_map</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">_unit_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_unit_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>

        <span class="c1"># m is case significant</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">_unit_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_unit_map</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="n">unit</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="n">unit_rev</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">unit</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="c1"># we require at least Ymd</span>
    <span class="n">required</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="s2">&quot;month&quot;</span><span class="p">,</span> <span class="s2">&quot;day&quot;</span><span class="p">]</span>
    <span class="n">req</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">required</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">unit_rev</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">req</span><span class="p">):</span>
        <span class="n">_required</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;to assemble mappings requires at least that &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;[year, month, day] be specified: [</span><span class="si">{</span><span class="n">_required</span><span class="si">}</span><span class="s2">] is missing&quot;</span>
        <span class="p">)</span>

    <span class="c1"># keys we don&#39;t recognize</span>
    <span class="n">excess</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">unit_rev</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">_unit_map</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">excess</span><span class="p">):</span>
        <span class="n">_excess</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">excess</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;extra keys have been passed to the datetime assemblage: [</span><span class="si">{</span><span class="n">_excess</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">coerce</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="c1"># we allow coercion to if errors allows</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">to_numeric</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

        <span class="c1"># prevent overflow in case of int8 or int16</span>
        <span class="k">if</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="n">values</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">coerce</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">unit_rev</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]])</span> <span class="o">*</span> <span class="mi">10000</span>
        <span class="o">+</span> <span class="n">coerce</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">unit_rev</span><span class="p">[</span><span class="s2">&quot;month&quot;</span><span class="p">]])</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="o">+</span> <span class="n">coerce</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">unit_rev</span><span class="p">[</span><span class="s2">&quot;day&quot;</span><span class="p">]])</span>
    <span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="n">utc</span><span class="o">=</span><span class="n">utc</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot assemble the datetimes: </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

    <span class="n">units</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">UnitChoices</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;ms&quot;</span><span class="p">,</span> <span class="s2">&quot;us&quot;</span><span class="p">,</span> <span class="s2">&quot;ns&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">units</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">unit_rev</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">+=</span> <span class="n">to_timedelta</span><span class="p">(</span><span class="n">coerce</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">value</span><span class="p">]),</span> <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot assemble the datetimes [</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">]: </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
    <span class="k">return</span> <span class="n">values</span>


<span class="k">def</span> <span class="nf">_attempt_YYYYMMDD</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">],</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    try to parse the YYYYMMDD/%Y%m%d format, try to deal with NaT-like,</span>
<span class="sd">    arg is a passed in as an object dtype, but could really be ints/strings</span>
<span class="sd">    with nan-like/or floats (e.g. with nan)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg : np.ndarray[object]</span>
<span class="sd">    errors : {&#39;raise&#39;,&#39;ignore&#39;,&#39;coerce&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="n">carg</span><span class="p">):</span>
        <span class="c1"># calculate the actual result</span>
        <span class="n">carg</span> <span class="o">=</span> <span class="n">carg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">parsed</span> <span class="o">=</span> <span class="n">parsing</span><span class="o">.</span><span class="n">try_parse_year_month_day</span><span class="p">(</span>
            <span class="n">carg</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">carg</span> <span class="o">/</span> <span class="mi">100</span> <span class="o">%</span> <span class="mi">100</span><span class="p">,</span> <span class="n">carg</span> <span class="o">%</span> <span class="mi">100</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">tslib</span><span class="o">.</span><span class="n">array_to_datetime</span><span class="p">(</span><span class="n">parsed</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">calc_with_mask</span><span class="p">(</span><span class="n">carg</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">carg</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;M8[ns]&quot;</span><span class="p">)</span>
        <span class="n">iresult</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span>
        <span class="n">iresult</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">iNaT</span>

        <span class="n">masked_result</span> <span class="o">=</span> <span class="n">calc</span><span class="p">(</span><span class="n">carg</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">masked_result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;M8[ns]&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># try intlike / strings that are ints</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">calc</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c1"># a float with actual np.nan</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">carg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">calc_with_mask</span><span class="p">(</span><span class="n">carg</span><span class="p">,</span> <span class="n">notna</span><span class="p">(</span><span class="n">carg</span><span class="p">))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c1"># string with NaN-like</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># error: Argument 2 to &quot;isin&quot; has incompatible type &quot;List[Any]&quot;; expected</span>
        <span class="c1"># &quot;Union[Union[ExtensionArray, ndarray], Index, Series]&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">algorithms</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">nat_strings</span><span class="p">))</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="k">return</span> <span class="n">calc_with_mask</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="kc">None</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;DateParseError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;should_cache&quot;</span><span class="p">,</span>
    <span class="s2">&quot;to_datetime&quot;</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso Furlanello, and Daniel Hug.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>