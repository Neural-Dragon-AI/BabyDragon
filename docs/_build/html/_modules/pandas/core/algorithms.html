<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pandas.core.algorithms &mdash; BabyDragon  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            BabyDragon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tasks:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks/llm_task.html">llm_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks/multi_kernel_task.html">multi_kernel_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks/base_task.html">base_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks/topic_tree_task.html">topic_tree_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks/embedding_task.html">embedding_task</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Kernels:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/kernels/memory_kernel.html">memory_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/kernels/kernel_clustering.html">kernel_clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/kernels/multi_kernel.html">multi_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/kernels/multi_kernel_visualization.html">multi_kernel_visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/kernels/kernel_utils.html">kernel_utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Threads:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/threads/base_thread.html">base_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/threads/fifo_thread.html">fifo_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/threads/vector_thread.html">vector_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/threads/todo/python_thread.html">python_thread</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Indexes:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/python_index.html">python_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/memory_index.html">memory_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/pandas_index.html">pandas_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/todo/youtube_index.html">youtube_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/todo/parquet_index.html">parquet_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/todo/wiki_index.html">wiki_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/todo/gutenberg_index.html">gutenberg_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/todo/github_index.html">github_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory/indexes/todo/multi_index.html">multi_index</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Chat:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../chat/base_chat.html">base_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../chat/memory_chat.html">memory_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../chat/chat.html">chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../chat/prompts/perspective_prompt.html">perspective_prompt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../chat/prompts/default_prompts.html">default_prompts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utils:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/multithreading.html">multithreading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/pandas.html">pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/hf_datasets.html">hf_datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/chatml.html">chatml</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/embedders:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../models/embedders/ada2.html">ada2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/embedders/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/embedders/sbert.html">sbert</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/generators:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../models/generators/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/generators/chatgpt.html">chatgpt</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Processors:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/github_processors.html">github_processors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/os_processor.html">os_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/git_metadata.html">git_metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/visitors.html">visitors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/python_parser.html">python_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/todo/subs_parser.html">subs_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/todo/latex_parser.html">latex_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/todo/md_parser.html">md_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/todo/wiki_parser.html">wiki_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/parsers/todo/git_processor.html">git_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/todo/arxiv_processor.html">arxiv_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/todo/wiki_processor.html">wiki_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/todo/chatgpt_processor.html">chatgpt_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/todo/mit_course_processor.html">mit_course_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/todo/youtube_processor.html">youtube_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/todo/pubmed_processor.html">pubmed_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processors/todo/gutenberg_processor.html">gutenberg_processor</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Apps:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../apps/auto_perspective/perspective.html">perspective</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BabyDragon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pandas.core.algorithms</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pandas.core.algorithms</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Generic data algorithms. This module is experimental at the moment and not</span>
<span class="sd">intended for public consumption</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">algos</span><span class="p">,</span>
    <span class="n">hashtable</span> <span class="k">as</span> <span class="n">htable</span><span class="p">,</span>
    <span class="n">iNaT</span><span class="p">,</span>
    <span class="n">lib</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AnyArrayLike</span><span class="p">,</span>
    <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">AxisInt</span><span class="p">,</span>
    <span class="n">DtypeObj</span><span class="p">,</span>
    <span class="n">TakeIndexer</span><span class="p">,</span>
    <span class="n">npt</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="n">doc</span>
<span class="kn">from</span> <span class="nn">pandas.util._exceptions</span> <span class="kn">import</span> <span class="n">find_stack_level</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">construct_1d_object_array_from_listlike</span><span class="p">,</span>
    <span class="n">infer_dtype_from_array</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ensure_float64</span><span class="p">,</span>
    <span class="n">ensure_object</span><span class="p">,</span>
    <span class="n">ensure_platform_int</span><span class="p">,</span>
    <span class="n">is_array_like</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_categorical_dtype</span><span class="p">,</span>
    <span class="n">is_complex_dtype</span><span class="p">,</span>
    <span class="n">is_extension_array_dtype</span><span class="p">,</span>
    <span class="n">is_float_dtype</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span>
    <span class="n">is_integer_dtype</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_numeric_dtype</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">is_signed_integer_dtype</span><span class="p">,</span>
    <span class="n">needs_i8_conversion</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.concat</span> <span class="kn">import</span> <span class="n">concat_compat</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.dtypes</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BaseMaskedDtype</span><span class="p">,</span>
    <span class="n">ExtensionDtype</span><span class="p">,</span>
    <span class="n">PandasDtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ABCDatetimeArray</span><span class="p">,</span>
    <span class="n">ABCExtensionArray</span><span class="p">,</span>
    <span class="n">ABCIndex</span><span class="p">,</span>
    <span class="n">ABCMultiIndex</span><span class="p">,</span>
    <span class="n">ABCSeries</span><span class="p">,</span>
    <span class="n">ABCTimedeltaArray</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">isna</span><span class="p">,</span>
    <span class="n">na_value_for_dtype</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core.array_algos.take</span> <span class="kn">import</span> <span class="n">take_nd</span>
<span class="kn">from</span> <span class="nn">pandas.core.construction</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">array</span> <span class="k">as</span> <span class="n">pd_array</span><span class="p">,</span>
    <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">,</span>
    <span class="n">extract_array</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexers</span> <span class="kn">import</span> <span class="n">validate_indices</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">NumpySorter</span><span class="p">,</span>
        <span class="n">NumpyValueArrayLike</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">Categorical</span><span class="p">,</span>
        <span class="n">Index</span><span class="p">,</span>
        <span class="n">Series</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">BaseMaskedArray</span><span class="p">,</span>
        <span class="n">ExtensionArray</span><span class="p">,</span>
    <span class="p">)</span>


<span class="c1"># --------------- #</span>
<span class="c1"># dtype access    #</span>
<span class="c1"># --------------- #</span>
<span class="k">def</span> <span class="nf">_ensure_data</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    routine to ensure that our data is of the correct</span>
<span class="sd">    input dtype for lower-level routines</span>

<span class="sd">    This will coerce:</span>
<span class="sd">    - ints -&gt; int64</span>
<span class="sd">    - uint -&gt; uint64</span>
<span class="sd">    - bool -&gt; uint8</span>
<span class="sd">    - datetimelike -&gt; i8</span>
<span class="sd">    - datetime64tz -&gt; i8 (in local tz)</span>
<span class="sd">    - categorical -&gt; codes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : np.ndarray or ExtensionArray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
        <span class="c1"># extract_array would raise</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ensure_object</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">BaseMaskedDtype</span><span class="p">):</span>
        <span class="c1"># i.e. BooleanArray, FloatingArray, IntegerArray</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;BaseMaskedArray&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="o">.</span><span class="n">_hasna</span><span class="p">:</span>
            <span class="c1"># No pd.NAs -&gt; We can avoid an object-dtype cast (and copy) GH#41816</span>
            <span class="c1">#  recurse to avoid re-implementing logic for eg bool-&gt;uint8</span>
            <span class="k">return</span> <span class="n">_ensure_data</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># NB: cases that go through here should NOT be using _reconstruct_data</span>
        <span class="c1">#  on the back-end.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;Categorical&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">codes</span>

    <span class="k">elif</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># i.e. actually dtype == np.dtype(&quot;bool&quot;)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># e.g. Sparse[bool, False]  # TODO: no test cases get here</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># Note: checking `values.dtype == &quot;float128&quot;` raises on Windows and 32bit</span>
        <span class="c1"># error: Item &quot;ExtensionDtype&quot; of &quot;Union[Any, ExtensionDtype, dtype[Any]]&quot;</span>
        <span class="c1"># has no attribute &quot;itemsize&quot;</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">]:</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="c1"># we dont (yet) have float128 hashtable support</span>
            <span class="k">return</span> <span class="n">ensure_float64</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">is_complex_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="c1"># datetimelike</span>
    <span class="k">elif</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="n">npvalues</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span>
        <span class="n">npvalues</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">npvalues</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">npvalues</span>

    <span class="c1"># we have failed, return object</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ensure_object</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_reconstruct_data</span><span class="p">(</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeObj</span><span class="p">,</span> <span class="n">original</span><span class="p">:</span> <span class="n">AnyArrayLike</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reverse of _ensure_data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : np.ndarray or ExtensionArray</span>
<span class="sd">    dtype : np.dtype or ExtensionDtype</span>
<span class="sd">    original : AnyArrayLike</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ExtensionArray or np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ABCExtensionArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="c1"># Catch DatetimeArray/TimedeltaArray</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># i.e. ExtensionDtype; note we have ruled out above the possibility</span>
        <span class="c1">#  that values.dtype == dtype</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">construct_array_type</span><span class="p">()</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">values</span>


<span class="k">def</span> <span class="nf">_ensure_arraylike</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ensure that we are arraylike if not already</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_array_like</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="n">inferred</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mixed&quot;</span><span class="p">,</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed-integer&quot;</span><span class="p">]:</span>
            <span class="c1"># &quot;mixed-integer&quot; to ensure we do not cast [&quot;ss&quot;, 42] to str GH#22160</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">construct_1d_object_array_from_listlike</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span>


<span class="n">_hashtables</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;complex128&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">Complex128HashTable</span><span class="p">,</span>
    <span class="s2">&quot;complex64&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">Complex64HashTable</span><span class="p">,</span>
    <span class="s2">&quot;float64&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">Float64HashTable</span><span class="p">,</span>
    <span class="s2">&quot;float32&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">Float32HashTable</span><span class="p">,</span>
    <span class="s2">&quot;uint64&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">UInt64HashTable</span><span class="p">,</span>
    <span class="s2">&quot;uint32&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">UInt32HashTable</span><span class="p">,</span>
    <span class="s2">&quot;uint16&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">UInt16HashTable</span><span class="p">,</span>
    <span class="s2">&quot;uint8&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">UInt8HashTable</span><span class="p">,</span>
    <span class="s2">&quot;int64&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">Int64HashTable</span><span class="p">,</span>
    <span class="s2">&quot;int32&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">Int32HashTable</span><span class="p">,</span>
    <span class="s2">&quot;int16&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">Int16HashTable</span><span class="p">,</span>
    <span class="s2">&quot;int8&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">Int8HashTable</span><span class="p">,</span>
    <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">StringHashTable</span><span class="p">,</span>
    <span class="s2">&quot;object&quot;</span><span class="p">:</span> <span class="n">htable</span><span class="o">.</span><span class="n">PyObjectHashTable</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_get_hashtable_algo</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : np.ndarray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    htable : HashTable subclass</span>
<span class="sd">    values : ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_data</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="n">ndtype</span> <span class="o">=</span> <span class="n">_check_object_for_strings</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">hashtable</span> <span class="o">=</span> <span class="n">_hashtables</span><span class="p">[</span><span class="n">ndtype</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">values</span>


<span class="k">def</span> <span class="nf">_check_object_for_strings</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if we can use string hashtable instead of object hashtable.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : ndarray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndtype</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="n">ndtype</span> <span class="o">==</span> <span class="s2">&quot;object&quot;</span><span class="p">:</span>
        <span class="c1"># it&#39;s cheaper to use a String Hash Table than Object; we infer</span>
        <span class="c1"># including nulls because that is the only difference between</span>
        <span class="c1"># StringHashTable and ObjectHashtable</span>
        <span class="k">if</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;string&quot;</span><span class="p">]:</span>
            <span class="n">ndtype</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span>
    <span class="k">return</span> <span class="n">ndtype</span>


<span class="c1"># --------------- #</span>
<span class="c1"># top-level algos #</span>
<span class="c1"># --------------- #</span>


<div class="viewcode-block" id="unique"><a class="viewcode-back" href="../../../utils/pandas.html#pandas.unique">[docs]</a><span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return unique values based on a hash table.</span>

<span class="sd">    Uniques are returned in order of appearance. This does NOT sort.</span>

<span class="sd">    Significantly faster than numpy.unique for long enough sequences.</span>
<span class="sd">    Includes NA values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : 1d array-like</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray or ExtensionArray</span>

<span class="sd">        The return can be:</span>

<span class="sd">        * Index : when the input is an Index</span>
<span class="sd">        * Categorical : when the input is a Categorical dtype</span>
<span class="sd">        * ndarray : when the input is a Series/ndarray</span>

<span class="sd">        Return numpy.ndarray or ExtensionArray.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Index.unique : Return unique values from an Index.</span>
<span class="sd">    Series.unique : Return unique values of Series object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; pd.unique(pd.Series([2, 1, 3, 3]))</span>
<span class="sd">    array([2, 1, 3])</span>

<span class="sd">    &gt;&gt;&gt; pd.unique(pd.Series([2] + [1] * 5))</span>
<span class="sd">    array([2, 1])</span>

<span class="sd">    &gt;&gt;&gt; pd.unique(pd.Series([pd.Timestamp(&quot;20160101&quot;), pd.Timestamp(&quot;20160101&quot;)]))</span>
<span class="sd">    array([&#39;2016-01-01T00:00:00.000000000&#39;], dtype=&#39;datetime64[ns]&#39;)</span>

<span class="sd">    &gt;&gt;&gt; pd.unique(</span>
<span class="sd">    ...     pd.Series(</span>
<span class="sd">    ...         [</span>
<span class="sd">    ...             pd.Timestamp(&quot;20160101&quot;, tz=&quot;US/Eastern&quot;),</span>
<span class="sd">    ...             pd.Timestamp(&quot;20160101&quot;, tz=&quot;US/Eastern&quot;),</span>
<span class="sd">    ...         ]</span>
<span class="sd">    ...     )</span>
<span class="sd">    ... )</span>
<span class="sd">    &lt;DatetimeArray&gt;</span>
<span class="sd">    [&#39;2016-01-01 00:00:00-05:00&#39;]</span>
<span class="sd">    Length: 1, dtype: datetime64[ns, US/Eastern]</span>

<span class="sd">    &gt;&gt;&gt; pd.unique(</span>
<span class="sd">    ...     pd.Index(</span>
<span class="sd">    ...         [</span>
<span class="sd">    ...             pd.Timestamp(&quot;20160101&quot;, tz=&quot;US/Eastern&quot;),</span>
<span class="sd">    ...             pd.Timestamp(&quot;20160101&quot;, tz=&quot;US/Eastern&quot;),</span>
<span class="sd">    ...         ]</span>
<span class="sd">    ...     )</span>
<span class="sd">    ... )</span>
<span class="sd">    DatetimeIndex([&#39;2016-01-01 00:00:00-05:00&#39;],</span>
<span class="sd">            dtype=&#39;datetime64[ns, US/Eastern]&#39;,</span>
<span class="sd">            freq=None)</span>

<span class="sd">    &gt;&gt;&gt; pd.unique(list(&quot;baabc&quot;))</span>
<span class="sd">    array([&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], dtype=object)</span>

<span class="sd">    An unordered Categorical will return categories in the</span>
<span class="sd">    order of appearance.</span>

<span class="sd">    &gt;&gt;&gt; pd.unique(pd.Series(pd.Categorical(list(&quot;baabc&quot;))))</span>
<span class="sd">    [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="sd">    Categories (3, object): [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="sd">    &gt;&gt;&gt; pd.unique(pd.Series(pd.Categorical(list(&quot;baabc&quot;), categories=list(&quot;abc&quot;))))</span>
<span class="sd">    [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="sd">    Categories (3, object): [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="sd">    An ordered Categorical preserves the category ordering.</span>

<span class="sd">    &gt;&gt;&gt; pd.unique(</span>
<span class="sd">    ...     pd.Series(</span>
<span class="sd">    ...         pd.Categorical(list(&quot;baabc&quot;), categories=list(&quot;abc&quot;), ordered=True)</span>
<span class="sd">    ...     )</span>
<span class="sd">    ... )</span>
<span class="sd">    [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="sd">    Categories (3, object): [&#39;a&#39; &lt; &#39;b&#39; &lt; &#39;c&#39;]</span>

<span class="sd">    An array of tuples</span>

<span class="sd">    &gt;&gt;&gt; pd.unique([(&quot;a&quot;, &quot;b&quot;), (&quot;b&quot;, &quot;a&quot;), (&quot;a&quot;, &quot;c&quot;), (&quot;b&quot;, &quot;a&quot;)])</span>
<span class="sd">    array([(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;a&#39;), (&#39;a&#39;, &#39;c&#39;)], dtype=object)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">unique_with_mask</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">nunique_ints</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of unique values for integer array-likes.</span>

<span class="sd">    Significantly faster than pandas.unique for long enough sequences.</span>
<span class="sd">    No checks are done to ensure input is integral.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : 1d array-like</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int : The number of unique values in ``values``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_data</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="c1"># bincount requires intp</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;intp&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">unique_with_mask</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See algorithms.unique for docs. Takes a mask for masked arrays.&quot;&quot;&quot;</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_arraylike</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># Dispatch to extension dtype&#39;s unique.</span>
        <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="n">original</span> <span class="o">=</span> <span class="n">values</span>
    <span class="n">hashtable</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">_get_hashtable_algo</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="n">table</span> <span class="o">=</span> <span class="n">hashtable</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">uniques</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">uniques</span> <span class="o">=</span> <span class="n">_reconstruct_data</span><span class="p">(</span><span class="n">uniques</span><span class="p">,</span> <span class="n">original</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">original</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">uniques</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">uniques</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">uniques</span> <span class="o">=</span> <span class="n">_reconstruct_data</span><span class="p">(</span><span class="n">uniques</span><span class="p">,</span> <span class="n">original</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">original</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># for mypy</span>
        <span class="k">return</span> <span class="n">uniques</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>


<span class="n">unique1d</span> <span class="o">=</span> <span class="n">unique</span>


<span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="n">comps</span><span class="p">:</span> <span class="n">AnyArrayLike</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">AnyArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the isin boolean array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comps : array-like</span>
<span class="sd">    values : array-like</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray[bool]</span>
<span class="sd">        Same length as `comps`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">comps</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;only list-like objects are allowed to be passed &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;to isin(), you passed a [</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;only list-like objects are allowed to be passed &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;to isin(), you passed a [</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCIndex</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCExtensionArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">orig_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_arraylike</span><span class="p">(</span><span class="n">orig_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_signed_integer_dtype</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># GH#46485 Use object to avoid upcast to float64 later</span>
            <span class="c1"># TODO: Share with _find_common_type_compat</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">construct_1d_object_array_from_listlike</span><span class="p">(</span><span class="n">orig_values</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
        <span class="c1"># Avoid raising in extract_array</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extract_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">comps_array</span> <span class="o">=</span> <span class="n">_ensure_arraylike</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>
    <span class="n">comps_array</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">comps_array</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comps_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># i.e. Extension Array</span>
        <span class="k">return</span> <span class="n">comps_array</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">comps_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># Dispatch to DatetimeLikeArrayMixin.isin</span>
        <span class="k">return</span> <span class="n">pd_array</span><span class="p">(</span><span class="n">comps_array</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">comps_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># e.g. comps_array are integers and values are datetime64s</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">comps_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="c1"># TODO: not quite right ... Sparse/Categorical</span>
    <span class="k">elif</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">isin</span><span class="p">(</span><span class="n">comps_array</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ExtensionDtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">isin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">comps_array</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

    <span class="c1"># GH16012</span>
    <span class="c1"># Ensure np.in1d doesn&#39;t get object types or it *may* throw an exception</span>
    <span class="c1"># Albeit hashmap has O(1) look-up (vs. O(logn) in sorted array),</span>
    <span class="c1"># in1d is faster for small sizes</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">comps_array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1_000_000</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">26</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">comps_array</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="c1"># If the values include nan we need to check for nan explicitly</span>
        <span class="c1"># since np.nan it not equal to np.nan</span>
        <span class="k">if</span> <span class="n">isna</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>

            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">comps_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">comps_array</span> <span class="o">=</span> <span class="n">comps_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">htable</span><span class="o">.</span><span class="n">ismember</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">comps_array</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">factorize_array</span><span class="p">(</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">use_na_sentinel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">size_hint</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">na_value</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factorize a numpy array to codes and uniques.</span>

<span class="sd">    This doesn&#39;t do any coercion of types or unboxing before factorization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : ndarray</span>
<span class="sd">    use_na_sentinel : bool, default True</span>
<span class="sd">        If True, the sentinel -1 will be used for NaN values. If False,</span>
<span class="sd">        NaN values will be encoded as non-negative integers and will not drop the</span>
<span class="sd">        NaN from the uniques of the values.</span>
<span class="sd">    size_hint : int, optional</span>
<span class="sd">        Passed through to the hashtable&#39;s &#39;get_labels&#39; method</span>
<span class="sd">    na_value : object, optional</span>
<span class="sd">        A value in `values` to consider missing. Note: only use this</span>
<span class="sd">        parameter when you know that you don&#39;t have any values pandas would</span>
<span class="sd">        consider missing in the array (NaN for float data, iNaT for</span>
<span class="sd">        datetimes, etc.).</span>
<span class="sd">    mask : ndarray[bool], optional</span>
<span class="sd">        If not None, the mask is used as indicator for missing values</span>
<span class="sd">        (True = missing, False = valid) instead of `na_value` or</span>
<span class="sd">        condition &quot;val != val&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    codes : ndarray[np.intp]</span>
<span class="sd">    uniques : ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">values</span>
    <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">]:</span>
        <span class="c1"># _get_hashtable_algo will cast dt64/td64 to i8 via _ensure_data, so we</span>
        <span class="c1">#  need to do the same to na_value. We are assuming here that the passed</span>
        <span class="c1">#  na_value is an appropriately-typed NaT.</span>
        <span class="c1"># e.g. test_where_datetimelike_categorical</span>
        <span class="n">na_value</span> <span class="o">=</span> <span class="n">iNaT</span>

    <span class="n">hash_klass</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">_get_hashtable_algo</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="n">table</span> <span class="o">=</span> <span class="n">hash_klass</span><span class="p">(</span><span class="n">size_hint</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
    <span class="n">uniques</span><span class="p">,</span> <span class="n">codes</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span>
        <span class="n">values</span><span class="p">,</span>
        <span class="n">na_sentinel</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">na_value</span><span class="o">=</span><span class="n">na_value</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">ignore_na</span><span class="o">=</span><span class="n">use_na_sentinel</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># re-cast e.g. i8-&gt;dt64/td64, uint8-&gt;bool</span>
    <span class="n">uniques</span> <span class="o">=</span> <span class="n">_reconstruct_data</span><span class="p">(</span><span class="n">uniques</span><span class="p">,</span> <span class="n">original</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">original</span><span class="p">)</span>

    <span class="n">codes</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">codes</span><span class="p">,</span> <span class="n">uniques</span>


<div class="viewcode-block" id="factorize"><a class="viewcode-back" href="../../../utils/pandas.html#pandas.factorize">[docs]</a><span class="nd">@doc</span><span class="p">(</span>
    <span class="n">values</span><span class="o">=</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    values : sequence</span>
<span class="sd">        A 1-D sequence. Sequences that aren&#39;t pandas objects are</span>
<span class="sd">        coerced to ndarrays before factorization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="n">sort</span><span class="o">=</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    sort : bool, default False</span>
<span class="sd">        Sort `uniques` and shuffle `codes` to maintain the</span>
<span class="sd">        relationship.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="n">size_hint</span><span class="o">=</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    size_hint : int, optional</span>
<span class="sd">        Hint to the hashtable sizer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">),</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">factorize</span><span class="p">(</span>
    <span class="n">values</span><span class="p">,</span>
    <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">use_na_sentinel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">size_hint</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Index</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encode the object as an enumerated type or categorical variable.</span>

<span class="sd">    This method is useful for obtaining a numeric representation of an</span>
<span class="sd">    array when all that matters is identifying distinct values. `factorize`</span>
<span class="sd">    is available as both a top-level function :func:`pandas.factorize`,</span>
<span class="sd">    and as a method :meth:`Series.factorize` and :meth:`Index.factorize`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    {values}{sort}</span>
<span class="sd">    use_na_sentinel : bool, default True</span>
<span class="sd">        If True, the sentinel -1 will be used for NaN values. If False,</span>
<span class="sd">        NaN values will be encoded as non-negative integers and will not drop the</span>
<span class="sd">        NaN from the uniques of the values.</span>

<span class="sd">        .. versionadded:: 1.5.0</span>
<span class="sd">    {size_hint}\</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    codes : ndarray</span>
<span class="sd">        An integer ndarray that&#39;s an indexer into `uniques`.</span>
<span class="sd">        ``uniques.take(codes)`` will have the same values as `values`.</span>
<span class="sd">    uniques : ndarray, Index, or Categorical</span>
<span class="sd">        The unique valid values. When `values` is Categorical, `uniques`</span>
<span class="sd">        is a Categorical. When `values` is some other pandas object, an</span>
<span class="sd">        `Index` is returned. Otherwise, a 1-D ndarray is returned.</span>

<span class="sd">        .. note::</span>

<span class="sd">           Even if there&#39;s a missing value in `values`, `uniques` will</span>
<span class="sd">           *not* contain an entry for it.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cut : Discretize continuous-valued array.</span>
<span class="sd">    unique : Find the unique value in an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Reference :ref:`the user guide &lt;reshaping.factorize&gt;` for more examples.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    These examples all show factorize as a top-level method like</span>
<span class="sd">    ``pd.factorize(values)``. The results are identical for methods like</span>
<span class="sd">    :meth:`Series.factorize`.</span>

<span class="sd">    &gt;&gt;&gt; codes, uniques = pd.factorize([&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;])</span>
<span class="sd">    &gt;&gt;&gt; codes</span>
<span class="sd">    array([0, 0, 1, 2, 0])</span>
<span class="sd">    &gt;&gt;&gt; uniques</span>
<span class="sd">    array([&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], dtype=object)</span>

<span class="sd">    With ``sort=True``, the `uniques` will be sorted, and `codes` will be</span>
<span class="sd">    shuffled so that the relationship is the maintained.</span>

<span class="sd">    &gt;&gt;&gt; codes, uniques = pd.factorize([&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;], sort=True)</span>
<span class="sd">    &gt;&gt;&gt; codes</span>
<span class="sd">    array([1, 1, 0, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; uniques</span>
<span class="sd">    array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=object)</span>

<span class="sd">    When ``use_na_sentinel=True`` (the default), missing values are indicated in</span>
<span class="sd">    the `codes` with the sentinel value ``-1`` and missing values are not</span>
<span class="sd">    included in `uniques`.</span>

<span class="sd">    &gt;&gt;&gt; codes, uniques = pd.factorize([&#39;b&#39;, None, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;])</span>
<span class="sd">    &gt;&gt;&gt; codes</span>
<span class="sd">    array([ 0, -1,  1,  2,  0])</span>
<span class="sd">    &gt;&gt;&gt; uniques</span>
<span class="sd">    array([&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], dtype=object)</span>

<span class="sd">    Thus far, we&#39;ve only factorized lists (which are internally coerced to</span>
<span class="sd">    NumPy arrays). When factorizing pandas objects, the type of `uniques`</span>
<span class="sd">    will differ. For Categoricals, a `Categorical` is returned.</span>

<span class="sd">    &gt;&gt;&gt; cat = pd.Categorical([&#39;a&#39;, &#39;a&#39;, &#39;c&#39;], categories=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">    &gt;&gt;&gt; codes, uniques = pd.factorize(cat)</span>
<span class="sd">    &gt;&gt;&gt; codes</span>
<span class="sd">    array([0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; uniques</span>
<span class="sd">    [&#39;a&#39;, &#39;c&#39;]</span>
<span class="sd">    Categories (3, object): [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="sd">    Notice that ``&#39;b&#39;`` is in ``uniques.categories``, despite not being</span>
<span class="sd">    present in ``cat.values``.</span>

<span class="sd">    For all other pandas objects, an Index of the appropriate type is</span>
<span class="sd">    returned.</span>

<span class="sd">    &gt;&gt;&gt; cat = pd.Series([&#39;a&#39;, &#39;a&#39;, &#39;c&#39;])</span>
<span class="sd">    &gt;&gt;&gt; codes, uniques = pd.factorize(cat)</span>
<span class="sd">    &gt;&gt;&gt; codes</span>
<span class="sd">    array([0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; uniques</span>
<span class="sd">    Index([&#39;a&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">    If NaN is in the values, and we want to include NaN in the uniques of the</span>
<span class="sd">    values, it can be achieved by setting ``use_na_sentinel=False``.</span>

<span class="sd">    &gt;&gt;&gt; values = np.array([1, 2, 1, np.nan])</span>
<span class="sd">    &gt;&gt;&gt; codes, uniques = pd.factorize(values)  # default: use_na_sentinel=True</span>
<span class="sd">    &gt;&gt;&gt; codes</span>
<span class="sd">    array([ 0,  1,  0, -1])</span>
<span class="sd">    &gt;&gt;&gt; uniques</span>
<span class="sd">    array([1., 2.])</span>

<span class="sd">    &gt;&gt;&gt; codes, uniques = pd.factorize(values, use_na_sentinel=False)</span>
<span class="sd">    &gt;&gt;&gt; codes</span>
<span class="sd">    array([0, 1, 0, 2])</span>
<span class="sd">    &gt;&gt;&gt; uniques</span>
<span class="sd">    array([ 1.,  2., nan])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Implementation notes: This method is responsible for 3 things</span>
    <span class="c1"># 1.) coercing data to array-like (ndarray, Index, extension array)</span>
    <span class="c1"># 2.) factorizing codes and uniques</span>
    <span class="c1"># 3.) Maybe boxing the uniques in an Index</span>
    <span class="c1">#</span>
    <span class="c1"># Step 2 is dispatched to extension types (like Categorical). They are</span>
    <span class="c1"># responsible only for factorization. All data coercion, sorting and boxing</span>
    <span class="c1"># should happen here.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCIndex</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span> <span class="n">use_na_sentinel</span><span class="o">=</span><span class="n">use_na_sentinel</span><span class="p">)</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_arraylike</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCDatetimeArray</span><span class="p">,</span> <span class="n">ABCTimedeltaArray</span><span class="p">))</span>
        <span class="ow">and</span> <span class="n">values</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="c1"># The presence of &#39;freq&#39; means we can fast-path sorting and know there</span>
        <span class="c1">#  aren&#39;t NAs</span>
        <span class="n">codes</span><span class="p">,</span> <span class="n">uniques</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">codes</span><span class="p">,</span> <span class="n">uniques</span>

    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># i.e. ExtensionArray</span>
        <span class="n">codes</span><span class="p">,</span> <span class="n">uniques</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">use_na_sentinel</span><span class="o">=</span><span class="n">use_na_sentinel</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>  <span class="c1"># convert DTA/TDA/MultiIndex</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_na_sentinel</span> <span class="ow">and</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="c1"># factorize can now handle differentiating various types of null values.</span>
            <span class="c1"># These can only occur when the array has object dtype.</span>
            <span class="c1"># However, for backwards compatibility we only use the null for the</span>
            <span class="c1"># provided dtype. This may be revisited in the future, see GH#48476.</span>
            <span class="n">null_mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">null_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">na_value</span> <span class="o">=</span> <span class="n">na_value_for_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="c1"># Don&#39;t modify (potentially user-provided) array</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">null_mask</span><span class="p">,</span> <span class="n">na_value</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

        <span class="n">codes</span><span class="p">,</span> <span class="n">uniques</span> <span class="o">=</span> <span class="n">factorize_array</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span>
            <span class="n">use_na_sentinel</span><span class="o">=</span><span class="n">use_na_sentinel</span><span class="p">,</span>
            <span class="n">size_hint</span><span class="o">=</span><span class="n">size_hint</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">sort</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniques</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">uniques</span><span class="p">,</span> <span class="n">codes</span> <span class="o">=</span> <span class="n">safe_sort</span><span class="p">(</span>
            <span class="n">uniques</span><span class="p">,</span>
            <span class="n">codes</span><span class="p">,</span>
            <span class="n">use_na_sentinel</span><span class="o">=</span><span class="n">use_na_sentinel</span><span class="p">,</span>
            <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">uniques</span> <span class="o">=</span> <span class="n">_reconstruct_data</span><span class="p">(</span><span class="n">uniques</span><span class="p">,</span> <span class="n">original</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">original</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">codes</span><span class="p">,</span> <span class="n">uniques</span></div>


<div class="viewcode-block" id="value_counts"><a class="viewcode-back" href="../../../utils/pandas.html#pandas.value_counts">[docs]</a><span class="k">def</span> <span class="nf">value_counts</span><span class="p">(</span>
    <span class="n">values</span><span class="p">,</span>
    <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a histogram of the counts of non-null values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : ndarray (1-d)</span>
<span class="sd">    sort : bool, default True</span>
<span class="sd">        Sort by values</span>
<span class="sd">    ascending : bool, default False</span>
<span class="sd">        Sort in ascending order</span>
<span class="sd">    normalize: bool, default False</span>
<span class="sd">        If True then compute a relative histogram</span>
<span class="sd">    bins : integer, optional</span>
<span class="sd">        Rather than count values, group them into half-open bins,</span>
<span class="sd">        convenience for pd.cut, only works with numeric data</span>
<span class="sd">    dropna : bool, default True</span>
<span class="sd">        Don&#39;t include counts of NaN</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Series</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">Index</span><span class="p">,</span>
        <span class="n">Series</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">index_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;proportion&quot;</span> <span class="k">if</span> <span class="n">normalize</span> <span class="k">else</span> <span class="s2">&quot;count&quot;</span>

    <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.tile</span> <span class="kn">import</span> <span class="n">cut</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">include_lowest</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bins argument only works with numeric data.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># count, remove nulls (from the index), and but the bins</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ii</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">notna</span><span class="p">()]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;interval&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

        <span class="c1"># if we are dropna and we have NO values</span>
        <span class="k">if</span> <span class="n">dropna</span> <span class="ow">and</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># normalizing is by len of all (regardless of dropna)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="c1"># handle Categorical and sparse,</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">index_name</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_values</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># e.g. ArrowExtensionArray</span>
                <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="c1"># GH49558</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">nlevels</span><span class="p">))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
                <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>
                <span class="o">.</span><span class="n">size</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">names</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_values</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_arraylike</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">keys</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">value_counts_arraylike</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dropna</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keys</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">:</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="c1"># For backwards compatibility, we let Index do its normal type</span>
            <span class="c1">#  inference, _except_ for if if infers from object to bool.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">keys</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">idx</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">index_name</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">/</span> <span class="n">counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">result</span></div>


<span class="c1"># Called once from SparseArray, otherwise could be private</span>
<span class="k">def</span> <span class="nf">value_counts_arraylike</span><span class="p">(</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : np.ndarray</span>
<span class="sd">    dropna : bool</span>
<span class="sd">    mask : np.ndarray[bool] or None, default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    uniques : np.ndarray</span>
<span class="sd">    counts : np.ndarray[np.int64]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">values</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_data</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="n">keys</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">htable</span><span class="o">.</span><span class="n">value_count</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dropna</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># datetime, timedelta, or period</span>

        <span class="k">if</span> <span class="n">dropna</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">keys</span> <span class="o">!=</span> <span class="n">iNaT</span>
            <span class="n">keys</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

    <span class="n">res_keys</span> <span class="o">=</span> <span class="n">_reconstruct_data</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">original</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">original</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res_keys</span><span class="p">,</span> <span class="n">counts</span>


<span class="k">def</span> <span class="nf">duplicated</span><span class="p">(</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return boolean ndarray denoting duplicate values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : nd.array, ExtensionArray or Series</span>
<span class="sd">        Array over which to check for duplicate values.</span>
<span class="sd">    keep : {&#39;first&#39;, &#39;last&#39;, False}, default &#39;first&#39;</span>
<span class="sd">        - ``first`` : Mark duplicates as ``True`` except for the first</span>
<span class="sd">          occurrence.</span>
<span class="sd">        - ``last`` : Mark duplicates as ``True`` except for the last</span>
<span class="sd">          occurrence.</span>
<span class="sd">        - False : Mark all duplicates as ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    duplicated : ndarray[bool]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">BaseMaskedDtype</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;BaseMaskedArray&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">htable</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_data</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">htable</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mode</span><span class="p">(</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the mode(s) of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : array-like</span>
<span class="sd">        Array over which to check for duplicate values.</span>
<span class="sd">    dropna : bool, default True</span>
<span class="sd">        Don&#39;t consider counts of NaN/NaT.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray or ExtensionArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_arraylike</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">if</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># Got here with ndarray; dispatch to DatetimeArray/TimedeltaArray.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;ExtensionArray&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">_mode</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_data</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="n">npresult</span> <span class="o">=</span> <span class="n">htable</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">npresult</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">npresult</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unable to sort modes: </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">_reconstruct_data</span><span class="p">(</span><span class="n">npresult</span><span class="p">,</span> <span class="n">original</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">original</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">rank</span><span class="p">(</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span>
    <span class="n">na_option</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;keep&quot;</span><span class="p">,</span>
    <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pct</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rank the values along a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : np.ndarray or ExtensionArray</span>
<span class="sd">        Array whose values will be ranked. The number of dimensions in this</span>
<span class="sd">        array must not exceed 2.</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to perform rankings.</span>
<span class="sd">    method : {&#39;average&#39;, &#39;min&#39;, &#39;max&#39;, &#39;first&#39;, &#39;dense&#39;}, default &#39;average&#39;</span>
<span class="sd">        The method by which tiebreaks are broken during the ranking.</span>
<span class="sd">    na_option : {&#39;keep&#39;, &#39;top&#39;}, default &#39;keep&#39;</span>
<span class="sd">        The method by which NaNs are placed in the ranking.</span>
<span class="sd">        - ``keep``: rank each NaN value with a NaN ranking</span>
<span class="sd">        - ``top``: replace each NaN with either +/- inf so that they</span>
<span class="sd">                   there are ranked at the top</span>
<span class="sd">    ascending : bool, default True</span>
<span class="sd">        Whether or not the elements should be ranked in ascending order.</span>
<span class="sd">    pct : bool, default False</span>
<span class="sd">        Whether or not to the display the returned rankings in integer form</span>
<span class="sd">        (e.g. 1, 2, 3) or in percentile form (e.g. 0.333..., 0.666..., 1).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_datetimelike</span> <span class="o">=</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_data</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">rank_1d</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span>
            <span class="n">is_datetimelike</span><span class="o">=</span><span class="n">is_datetimelike</span><span class="p">,</span>
            <span class="n">ties_method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
            <span class="n">na_option</span><span class="o">=</span><span class="n">na_option</span><span class="p">,</span>
            <span class="n">pct</span><span class="o">=</span><span class="n">pct</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">rank_2d</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">is_datetimelike</span><span class="o">=</span><span class="n">is_datetimelike</span><span class="p">,</span>
            <span class="n">ties_method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
            <span class="n">na_option</span><span class="o">=</span><span class="n">na_option</span><span class="p">,</span>
            <span class="n">pct</span><span class="o">=</span><span class="n">pct</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Array with ndim &gt; 2 are not supported.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ranks</span>


<span class="k">def</span> <span class="nf">checked_add_with_arr</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span>
    <span class="n">arr_mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">b_mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform array addition that checks for underflow and overflow.</span>

<span class="sd">    Performs the addition of an int64 array and an int64 integer (or array)</span>
<span class="sd">    but checks that they do not result in overflow first. For elements that</span>
<span class="sd">    are indicated to be NaN, whether or not there is overflow for that element</span>
<span class="sd">    is automatically ignored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : np.ndarray[int64] addend.</span>
<span class="sd">    b : array or scalar addend.</span>
<span class="sd">    arr_mask : np.ndarray[bool] or None, default None</span>
<span class="sd">        array indicating which elements to exclude from checking</span>
<span class="sd">    b_mask : np.ndarray[bool] or None, default None</span>
<span class="sd">        array or scalar indicating which element(s) to exclude from checking</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum : An array for elements x + b for each element x in arr if b is</span>
<span class="sd">          a scalar or an array for elements x + y for each element pair</span>
<span class="sd">          (x, y) in (arr, b).</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    OverflowError if any x + y exceeds the maximum or minimum int64 value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For performance reasons, we broadcast &#39;b&#39; to the new array &#39;b2&#39;</span>
    <span class="c1"># so that it has the same size as &#39;arr&#39;.</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># We do the same broadcasting for b_mask as well.</span>
        <span class="n">b2_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">b_mask</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b2_mask</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># For elements that are NaN, regardless of their value, we should</span>
    <span class="c1"># ignore whether they overflow or not when doing the checked add.</span>
    <span class="k">if</span> <span class="n">arr_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b2_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">not_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">arr_mask</span> <span class="o">|</span> <span class="n">b2_mask</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">arr_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">not_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">arr_mask</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">b_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># error: Argument 1 to &quot;__call__&quot; of &quot;_UFunc_Nin1_Nout1&quot; has</span>
        <span class="c1"># incompatible type &quot;Optional[ndarray[Any, dtype[bool_]]]&quot;;</span>
        <span class="c1"># expected &quot;Union[_SupportsArray[dtype[Any]], _NestedSequence</span>
        <span class="c1"># [_SupportsArray[dtype[Any]]], bool, int, float, complex, str</span>
        <span class="c1"># , bytes, _NestedSequence[Union[bool, int, float, complex, str</span>
        <span class="c1"># , bytes]]]&quot;</span>
        <span class="n">not_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">b2_mask</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">not_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">not_nan</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># gh-14324: For each element in &#39;arr&#39; and its corresponding element</span>
    <span class="c1"># in &#39;b2&#39;, we check the sign of the element in &#39;b2&#39;. If it is positive,</span>
    <span class="c1"># we then check whether its sum with the element in &#39;arr&#39; exceeds</span>
    <span class="c1"># np.iinfo(np.int64).max. If so, we have an overflow error. If it</span>
    <span class="c1"># it is negative, we then check whether its sum with the element in</span>
    <span class="c1"># &#39;arr&#39; exceeds np.iinfo(np.int64).min. If so, we have an overflow</span>
    <span class="c1"># error as well.</span>
    <span class="n">i8max</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">i8max</span>
    <span class="n">i8min</span> <span class="o">=</span> <span class="n">iNaT</span>

    <span class="n">mask1</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">&lt;</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">mask1</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">to_raise</span> <span class="o">=</span> <span class="p">((</span><span class="n">i8min</span> <span class="o">-</span> <span class="n">b2</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">not_nan</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">mask2</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">to_raise</span> <span class="o">=</span> <span class="p">((</span><span class="n">i8max</span> <span class="o">-</span> <span class="n">b2</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">not_nan</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">to_raise</span> <span class="o">=</span> <span class="p">((</span><span class="n">i8max</span> <span class="o">-</span> <span class="n">b2</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">mask1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">not_nan</span><span class="p">[</span><span class="n">mask1</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">i8min</span> <span class="o">-</span> <span class="n">b2</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">mask2</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">not_nan</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">to_raise</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">OverflowError</span><span class="p">(</span><span class="s2">&quot;Overflow in int64 addition&quot;</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">if</span> <span class="n">arr_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">b2_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">~</span><span class="n">not_nan</span><span class="p">,</span> <span class="n">iNaT</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># ---- #</span>
<span class="c1"># take #</span>
<span class="c1"># ---- #</span>


<span class="k">def</span> <span class="nf">take</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">TakeIndexer</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">allow_fill</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take elements from an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array-like or scalar value</span>
<span class="sd">        Non array-likes (sequences/scalars without a dtype) are coerced</span>
<span class="sd">        to an ndarray.</span>
<span class="sd">    indices : sequence of int or one-dimensional np.ndarray of int</span>
<span class="sd">        Indices to be taken.</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        The axis over which to select values.</span>
<span class="sd">    allow_fill : bool, default False</span>
<span class="sd">        How to handle negative values in `indices`.</span>

<span class="sd">        * False: negative values in `indices` indicate positional indices</span>
<span class="sd">          from the right (the default). This is similar to :func:`numpy.take`.</span>

<span class="sd">        * True: negative values in `indices` indicate</span>
<span class="sd">          missing values. These values are set to `fill_value`. Any other</span>
<span class="sd">          negative values raise a ``ValueError``.</span>

<span class="sd">    fill_value : any, optional</span>
<span class="sd">        Fill value to use for NA-indices when `allow_fill` is True.</span>
<span class="sd">        This may be ``None``, in which case the default NA value for</span>
<span class="sd">        the type (``self.dtype.na_value``) is used.</span>

<span class="sd">        For multi-dimensional `arr`, each *element* is filled with</span>
<span class="sd">        `fill_value`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray or ExtensionArray</span>
<span class="sd">        Same type as the input.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    IndexError</span>
<span class="sd">        When `indices` is out of bounds for the array.</span>
<span class="sd">    ValueError</span>
<span class="sd">        When the indexer contains negative values other than ``-1``</span>
<span class="sd">        and `allow_fill` is True.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When `allow_fill` is False, `indices` may be whatever dimensionality</span>
<span class="sd">    is accepted by NumPy for `arr`.</span>

<span class="sd">    When `allow_fill` is True, `indices` should be 1-D.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.take : Take elements from an array along an axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>

<span class="sd">    With the default ``allow_fill=False``, negative numbers indicate</span>
<span class="sd">    positional indices from the right.</span>

<span class="sd">    &gt;&gt;&gt; pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1])</span>
<span class="sd">    array([10, 10, 30])</span>

<span class="sd">    Setting ``allow_fill=True`` will place `fill_value` in those positions.</span>

<span class="sd">    &gt;&gt;&gt; pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1], allow_fill=True)</span>
<span class="sd">    array([10., 10., nan])</span>

<span class="sd">    &gt;&gt;&gt; pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1], allow_fill=True,</span>
<span class="sd">    ...      fill_value=-10)</span>
<span class="sd">    array([ 10,  10, -10])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_array_like</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">allow_fill</span><span class="p">:</span>
        <span class="c1"># Pandas style, -1 means NA</span>
        <span class="n">validate_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">take_nd</span><span class="p">(</span>
            <span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">allow_fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># NumPy style</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># ------------ #</span>
<span class="c1"># searchsorted #</span>
<span class="c1"># ------------ #</span>


<span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">NumpyValueArrayLike</span> <span class="o">|</span> <span class="n">ExtensionArray</span><span class="p">,</span>
    <span class="n">side</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="n">sorter</span><span class="p">:</span> <span class="n">NumpySorter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find indices where elements should be inserted to maintain order.</span>

<span class="sd">    Find the indices into a sorted array `arr` (a) such that, if the</span>
<span class="sd">    corresponding elements in `value` were inserted before the indices,</span>
<span class="sd">    the order of `arr` would be preserved.</span>

<span class="sd">    Assuming that `arr` is sorted:</span>

<span class="sd">    ======  ================================</span>
<span class="sd">    `side`  returned index `i` satisfies</span>
<span class="sd">    ======  ================================</span>
<span class="sd">    left    ``arr[i-1] &lt; value &lt;= self[i]``</span>
<span class="sd">    right   ``arr[i-1] &lt;= value &lt; self[i]``</span>
<span class="sd">    ======  ================================</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr: np.ndarray, ExtensionArray, Series</span>
<span class="sd">        Input array. If `sorter` is None, then it must be sorted in</span>
<span class="sd">        ascending order, otherwise `sorter` must be an array of indices</span>
<span class="sd">        that sort it.</span>
<span class="sd">    value : array-like or scalar</span>
<span class="sd">        Values to insert into `arr`.</span>
<span class="sd">    side : {&#39;left&#39;, &#39;right&#39;}, optional</span>
<span class="sd">        If &#39;left&#39;, the index of the first suitable location found is given.</span>
<span class="sd">        If &#39;right&#39;, return the last such index.  If there is no suitable</span>
<span class="sd">        index, return either 0 or N (where N is the length of `self`).</span>
<span class="sd">    sorter : 1-D array-like, optional</span>
<span class="sd">        Optional array of integer indices that sort array a into ascending</span>
<span class="sd">        order. They are typically the result of argsort.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array of ints or int</span>
<span class="sd">        If value is array-like, array of insertion points.</span>
<span class="sd">        If value is scalar, a single integer.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.searchsorted : Similar method from NumPy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sorter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sorter</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">sorter</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="n">is_integer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
    <span class="p">):</span>
        <span class="c1"># if `arr` and `value` have different dtypes, `arr` would be</span>
        <span class="c1"># recast by numpy, causing a slow search.</span>
        <span class="c1"># Before searching below, we therefore try to give `value` the</span>
        <span class="c1"># same dtype as `arr`, while guarding against integer overflows.</span>
        <span class="n">iinfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="n">value_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span><span class="p">])</span> <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value_arr</span> <span class="o">&gt;=</span> <span class="n">iinfo</span><span class="o">.</span><span class="n">min</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">value_arr</span> <span class="o">&lt;=</span> <span class="n">iinfo</span><span class="o">.</span><span class="n">max</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="c1"># value within bounds, so no overflow, so can convert value dtype</span>
            <span class="c1"># to dtype of arr</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">value_arr</span><span class="o">.</span><span class="n">dtype</span>

        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="c1"># We know that value is int</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">pd_array</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># E.g. if `arr` is an array with dtype=&#39;datetime64[ns]&#39;</span>
        <span class="c1"># and `value` is a pd.Timestamp, we may need to convert value</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="c1"># Argument 1 to &quot;searchsorted&quot; of &quot;ndarray&quot; has incompatible type</span>
    <span class="c1"># &quot;Union[NumpyValueArrayLike, ExtensionArray]&quot;; expected &quot;NumpyValueArrayLike&quot;</span>
    <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">sorter</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>


<span class="c1"># ---- #</span>
<span class="c1"># diff #</span>
<span class="c1"># ---- #</span>

<span class="n">_diff_special</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;float64&quot;</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="s2">&quot;int64&quot;</span><span class="p">,</span> <span class="s2">&quot;int32&quot;</span><span class="p">,</span> <span class="s2">&quot;int16&quot;</span><span class="p">,</span> <span class="s2">&quot;int8&quot;</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    difference of n between self,</span>
<span class="sd">    analogous to s-s.shift(n)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray or ExtensionArray</span>
<span class="sd">    n : int</span>
<span class="sd">        number of periods</span>
<span class="sd">    axis : {0, 1}</span>
<span class="sd">        axis to shift on</span>
<span class="sd">    stacklevel : int, default 3</span>
<span class="sd">        The stacklevel for the lost dtype warning.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shifted</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">na</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span>

    <span class="n">is_bool</span> <span class="o">=</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_bool</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">xor</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">PandasDtype</span><span class="p">):</span>
        <span class="c1"># PandasArray cannot necessarily hold shifted versions of itself.</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># i.e ExtensionDtype</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;__</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">__&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot diff </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> on axis=</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> has no &#39;diff&#39; method. &quot;</span>
                <span class="s2">&quot;Convert to a suitable dtype prior to calling &#39;diff&#39;.&quot;</span>
            <span class="p">)</span>

    <span class="n">is_timedelta</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span>
        <span class="n">na</span> <span class="o">=</span> <span class="n">iNaT</span>
        <span class="n">is_timedelta</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">elif</span> <span class="n">is_bool</span><span class="p">:</span>
        <span class="c1"># We have to cast in order to be able to hold np.nan</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span>

    <span class="k">elif</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># We have to cast in order to be able to hold np.nan</span>

        <span class="c1"># int8, int16 are incompatible with float64,</span>
        <span class="c1"># see https://github.com/cython/cython/issues/2646</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;int8&quot;</span><span class="p">,</span> <span class="s2">&quot;int16&quot;</span><span class="p">]:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="n">orig_ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">orig_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># reshape so we can always use algos.diff_2d</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># TODO: require axis == 0</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">out_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">na_indexer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">na_indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">out_arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">na_indexer</span><span class="p">)]</span> <span class="o">=</span> <span class="n">na</span>

    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">_diff_special</span><span class="p">:</span>
        <span class="c1"># TODO: can diff_2d dtype specialization troubles be fixed by defining</span>
        <span class="c1">#  out_arr inside diff_2d?</span>
        <span class="n">algos</span><span class="o">.</span><span class="n">diff_2d</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">datetimelike</span><span class="o">=</span><span class="n">is_timedelta</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># To keep mypy happy, _res_indexer is a list while res_indexer is</span>
        <span class="c1">#  a tuple, ditto for lag_indexer.</span>
        <span class="n">_res_indexer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">_res_indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">res_indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_res_indexer</span><span class="p">)</span>

        <span class="n">_lag_indexer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">_lag_indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">lag_indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_lag_indexer</span><span class="p">)</span>

        <span class="n">out_arr</span><span class="p">[</span><span class="n">res_indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">res_indexer</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">lag_indexer</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">is_timedelta</span><span class="p">:</span>
        <span class="n">out_arr</span> <span class="o">=</span> <span class="n">out_arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;timedelta64[ns]&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">orig_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">out_arr</span> <span class="o">=</span> <span class="n">out_arr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out_arr</span>


<span class="c1"># --------------------------------------------------------------------</span>
<span class="c1"># Helper functions</span>


<span class="c1"># Note: safe_sort is in algorithms.py instead of sorting.py because it is</span>
<span class="c1">#  low-dependency, is used in this module, and used private methods from</span>
<span class="c1">#  this module.</span>
<span class="k">def</span> <span class="nf">safe_sort</span><span class="p">(</span>
    <span class="n">values</span><span class="p">,</span>
    <span class="n">codes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">use_na_sentinel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">assume_unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyArrayLike</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AnyArrayLike</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sort ``values`` and reorder corresponding ``codes``.</span>

<span class="sd">    ``values`` should be unique if ``codes`` is not None.</span>
<span class="sd">    Safe for use with mixed types (int, str), orders ints before strs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : list-like</span>
<span class="sd">        Sequence; must be unique if ``codes`` is not None.</span>
<span class="sd">    codes : list_like, optional</span>
<span class="sd">        Indices to ``values``. All out of bound indices are treated as</span>
<span class="sd">        &quot;not found&quot; and will be masked with ``-1``.</span>
<span class="sd">    use_na_sentinel : bool, default True</span>
<span class="sd">        If True, the sentinel -1 will be used for NaN values. If False,</span>
<span class="sd">        NaN values will be encoded as non-negative integers and will not drop the</span>
<span class="sd">        NaN from the uniques of the values.</span>
<span class="sd">    assume_unique : bool, default False</span>
<span class="sd">        When True, ``values`` are assumed to be unique, which can speed up</span>
<span class="sd">        the calculation. Ignored when ``codes`` is None.</span>
<span class="sd">    verify : bool, default True</span>
<span class="sd">        Check if codes are out of bound for the values and put out of bound</span>
<span class="sd">        codes equal to ``-1``. If ``verify=False``, it is assumed there</span>
<span class="sd">        are no out of bound codes. Ignored when ``codes`` is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ordered : AnyArrayLike</span>
<span class="sd">        Sorted ``values``</span>
<span class="sd">    new_codes : ndarray</span>
<span class="sd">        Reordered ``codes``; returned when ``codes`` is not None.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        * If ``values`` is not list-like or if ``codes`` is neither None</span>
<span class="sd">        nor list-like</span>
<span class="sd">        * If ``values`` cannot be sorted</span>
<span class="sd">    ValueError</span>
<span class="sd">        * If ``codes`` is not None and ``values`` contain duplicates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Only list-like objects are allowed to be passed to safe_sort as values&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_array_like</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="c1"># don&#39;t convert to string types</span>
        <span class="n">dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">infer_dtype_from_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="c1"># error: Argument &quot;dtype&quot; to &quot;asarray&quot; has incompatible type &quot;Union[dtype[Any],</span>
        <span class="c1"># ExtensionDtype]&quot;; expected &quot;Union[dtype[Any], None, type, _SupportsDType, str,</span>
        <span class="c1"># Union[Tuple[Any, int], Tuple[Any, Union[int, Sequence[int]]], List[Any],</span>
        <span class="c1"># _DTypeDict, Tuple[Any, Any]]]&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

    <span class="n">sorter</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ordered</span><span class="p">:</span> <span class="n">AnyArrayLike</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;mixed-integer&quot;</span>
    <span class="p">):</span>
        <span class="n">ordered</span> <span class="o">=</span> <span class="n">_sort_mixed</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
            <span class="n">ordered</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">sorter</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># Previous sorters failed or were not applicable, try `_sort_mixed`</span>
            <span class="c1"># which would work, but which fails for special case of 1d arrays</span>
            <span class="c1"># with tuples.</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">ordered</span> <span class="o">=</span> <span class="n">_sort_tuples</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ordered</span> <span class="o">=</span> <span class="n">_sort_mixed</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="c1"># codes:</span>

    <span class="k">if</span> <span class="n">codes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ordered</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">codes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Only list-like objects or None are allowed to &quot;</span>
            <span class="s2">&quot;be passed to safe_sort as codes&quot;</span>
        <span class="p">)</span>
    <span class="n">codes</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">codes</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_unique</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">values</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;values should be unique if codes is not None&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sorter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># mixed types</span>
        <span class="n">hash_klass</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">_get_hashtable_algo</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">hash_klass</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="n">t</span><span class="o">.</span><span class="n">map_locations</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">sorter</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ordered</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">use_na_sentinel</span><span class="p">:</span>
        <span class="c1"># take_nd is faster, but only works for na_sentinels of -1</span>
        <span class="n">order2</span> <span class="o">=</span> <span class="n">sorter</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        <span class="n">new_codes</span> <span class="o">=</span> <span class="n">take_nd</span><span class="p">(</span><span class="n">order2</span><span class="p">,</span> <span class="n">codes</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verify</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">codes</span> <span class="o">&lt;</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">codes</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reverse_indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorter</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
        <span class="n">reverse_indexer</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">sorter</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorter</span><span class="p">)))</span>
        <span class="c1"># Out of bound indices will be masked with `-1` next, so we</span>
        <span class="c1"># may deal with them here without performance loss using `mode=&#39;wrap&#39;`</span>
        <span class="n">new_codes</span> <span class="o">=</span> <span class="n">reverse_indexer</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_na_sentinel</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">codes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">verify</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="p">(</span><span class="n">codes</span> <span class="o">&lt;</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">codes</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">use_na_sentinel</span> <span class="ow">and</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">new_codes</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">new_codes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sort_mixed</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyArrayLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;order ints before strings before nulls in 1d arrays&quot;&quot;&quot;</span>
    <span class="n">str_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">null_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">num_pos</span> <span class="o">=</span> <span class="o">~</span><span class="n">str_pos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">null_pos</span>
    <span class="n">str_argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">str_pos</span><span class="p">])</span>
    <span class="n">num_argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">num_pos</span><span class="p">])</span>
    <span class="c1"># convert boolean arrays to positional indices, then order by underlying values</span>
    <span class="n">str_locs</span> <span class="o">=</span> <span class="n">str_pos</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">str_argsort</span><span class="p">)</span>
    <span class="n">num_locs</span> <span class="o">=</span> <span class="n">num_pos</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">num_argsort</span><span class="p">)</span>
    <span class="n">null_locs</span> <span class="o">=</span> <span class="n">null_pos</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">num_locs</span><span class="p">,</span> <span class="n">str_locs</span><span class="p">,</span> <span class="n">null_locs</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sort_tuples</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert array of tuples (1d) to array of arrays (2d).</span>
<span class="sd">    We need to keep the columns separately as they contain different types and</span>
<span class="sd">    nans (can&#39;t use `np.sort` as it may fail when str and nan are mixed in a</span>
<span class="sd">    column as types cannot be compared).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pandas.core.internals.construction</span> <span class="kn">import</span> <span class="n">to_arrays</span>
    <span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="kn">import</span> <span class="n">lexsort_indexer</span>

    <span class="n">arrays</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">to_arrays</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">indexer</span> <span class="o">=</span> <span class="n">lexsort_indexer</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">union_with_duplicates</span><span class="p">(</span>
    <span class="n">lvals</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">Index</span><span class="p">,</span> <span class="n">rvals</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">Index</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the union from lvals and rvals with respect to duplicates and nans in</span>
<span class="sd">    both arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lvals: np.ndarray or ExtensionArray</span>
<span class="sd">        left values which is ordered in front.</span>
<span class="sd">    rvals: np.ndarray or ExtensionArray</span>
<span class="sd">        right values ordered after lvals.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray or ExtensionArray</span>
<span class="sd">        Containing the unsorted union of both arrays.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Caller is responsible for ensuring lvals.dtype == rvals.dtype.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

    <span class="n">l_count</span> <span class="o">=</span> <span class="n">value_counts</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">r_count</span> <span class="o">=</span> <span class="n">value_counts</span><span class="p">(</span><span class="n">rvals</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">l_count</span><span class="p">,</span> <span class="n">r_count</span> <span class="o">=</span> <span class="n">l_count</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">r_count</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">final_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">l_count</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">r_count</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">final_count</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">final_count</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">l_count</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rvals</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
        <span class="n">unique_vals</span> <span class="o">=</span> <span class="n">lvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rvals</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">):</span>
            <span class="n">lvals</span> <span class="o">=</span> <span class="n">lvals</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rvals</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">):</span>
            <span class="n">rvals</span> <span class="o">=</span> <span class="n">rvals</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">unique_vals</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">concat_compat</span><span class="p">([</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">]))</span>
        <span class="n">unique_vals</span> <span class="o">=</span> <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">(</span><span class="n">unique_vals</span><span class="p">)</span>
    <span class="n">repeats</span> <span class="o">=</span> <span class="n">final_count</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">unique_vals</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">unique_vals</span><span class="p">,</span> <span class="n">repeats</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso Furlanello, and Daniel Hug.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>