<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pandas.core.groupby.generic &mdash; BabyDragon  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            BabyDragon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tasks:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/llm_task.html">llm_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/multi_kernel_task.html">multi_kernel_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/base_task.html">base_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/topic_tree_task.html">topic_tree_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/embedding_task.html">embedding_task</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Kernels:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/memory_kernel.html">memory_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_clustering.html">kernel_clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel.html">multi_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel_visualization.html">multi_kernel_visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_utils.html">kernel_utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Threads:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/base_thread.html">base_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/fifo_thread.html">fifo_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/vector_thread.html">vector_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/todo/python_thread.html">python_thread</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Indexes:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/python_index.html">python_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/memory_index.html">memory_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/pandas_index.html">pandas_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/youtube_index.html">youtube_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/parquet_index.html">parquet_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/wiki_index.html">wiki_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/gutenberg_index.html">gutenberg_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/github_index.html">github_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/multi_index.html">multi_index</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Chat:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/base_chat.html">base_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/memory_chat.html">memory_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/chat.html">chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/prompts/perspective_prompt.html">perspective_prompt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/prompts/default_prompts.html">default_prompts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utils:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/multithreading.html">multithreading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/pandas.html">pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/hf_datasets.html">hf_datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/chatml.html">chatml</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/embedders:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/ada2.html">ada2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/sbert.html">sbert</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/generators:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/chatgpt.html">chatgpt</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Processors:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/github_processors.html">github_processors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/os_processor.html">os_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/git_metadata.html">git_metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html">visitors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html">python_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/subs_parser.html">subs_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/latex_parser.html">latex_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/md_parser.html">md_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/wiki_parser.html">wiki_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/git_processor.html">git_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/arxiv_processor.html">arxiv_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/wiki_processor.html">wiki_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/chatgpt_processor.html">chatgpt_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/mit_course_processor.html">mit_course_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/youtube_processor.html">youtube_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/pubmed_processor.html">pubmed_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/gutenberg_processor.html">gutenberg_processor</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Apps:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html">perspective</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">BabyDragon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pandas.core.groupby.generic</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pandas.core.groupby.generic</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Define the SeriesGroupBy and DataFrameGroupBy</span>
<span class="sd">classes that hold the groupby interfaces (and some implementations).</span>

<span class="sd">These are user facing as the result of the ``df.groupby(...)`` operations,</span>
<span class="sd">which here returns a DataFrameGroupBy object.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">abc</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">NamedTuple</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Interval</span><span class="p">,</span>
    <span class="n">lib</span><span class="p">,</span>
    <span class="n">reduction</span> <span class="k">as</span> <span class="n">libreduction</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">Axis</span><span class="p">,</span>
    <span class="n">AxisInt</span><span class="p">,</span>
    <span class="n">CorrelationMethod</span><span class="p">,</span>
    <span class="n">FillnaOptions</span><span class="p">,</span>
    <span class="n">IndexLabel</span><span class="p">,</span>
    <span class="n">Manager</span><span class="p">,</span>
    <span class="n">Manager2D</span><span class="p">,</span>
    <span class="n">SingleManager</span><span class="p">,</span>
    <span class="n">TakeIndexer</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="n">SpecificationError</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Appender</span><span class="p">,</span>
    <span class="n">Substitution</span><span class="p">,</span>
    <span class="n">doc</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ensure_int64</span><span class="p">,</span>
    <span class="n">is_bool</span><span class="p">,</span>
    <span class="n">is_categorical_dtype</span><span class="p">,</span>
    <span class="n">is_dict_like</span><span class="p">,</span>
    <span class="n">is_integer_dtype</span><span class="p">,</span>
    <span class="n">is_interval_dtype</span><span class="p">,</span>
    <span class="n">is_numeric_dtype</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">isna</span><span class="p">,</span>
    <span class="n">notna</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="kn">import</span> <span class="n">algorithms</span>
<span class="kn">from</span> <span class="nn">pandas.core.apply</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GroupByApply</span><span class="p">,</span>
    <span class="n">maybe_mangle_lambdas</span><span class="p">,</span>
    <span class="n">reconstruct_func</span><span class="p">,</span>
    <span class="n">validate_func_kwargs</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">pandas.core.groupby</span> <span class="kn">import</span> <span class="n">base</span>
<span class="kn">from</span> <span class="nn">pandas.core.groupby.groupby</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GroupBy</span><span class="p">,</span>
    <span class="n">GroupByPlot</span><span class="p">,</span>
    <span class="n">_agg_template</span><span class="p">,</span>
    <span class="n">_apply_docs</span><span class="p">,</span>
    <span class="n">_transform_template</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.api</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Index</span><span class="p">,</span>
    <span class="n">MultiIndex</span><span class="p">,</span>
    <span class="n">all_indexes_same</span><span class="p">,</span>
    <span class="n">default_index</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.series</span> <span class="kn">import</span> <span class="n">Series</span>
<span class="kn">from</span> <span class="nn">pandas.core.util.numba_</span> <span class="kn">import</span> <span class="n">maybe_use_numba</span>

<span class="kn">from</span> <span class="nn">pandas.plotting</span> <span class="kn">import</span> <span class="n">boxplot_frame_groupby</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Categorical</span>
    <span class="kn">from</span> <span class="nn">pandas.core.generic</span> <span class="kn">import</span> <span class="n">NDFrame</span>

<span class="c1"># TODO(typing) the return value on this callable should be any *scalar*.</span>
<span class="n">AggScalar</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
<span class="c1"># TODO: validate types on ScalarResult and move to _typing</span>
<span class="c1"># Blocked from using by https://github.com/python/mypy/issues/1484</span>
<span class="c1"># See note at _mangle_lambda_list</span>
<span class="n">ScalarResult</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;ScalarResult&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="NamedAgg"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.NamedAgg">[docs]</a><span class="k">class</span> <span class="nc">NamedAgg</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper for column specific aggregation with control over output column names.</span>

<span class="sd">    Subclass of typing.NamedTuple.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : Hashable</span>
<span class="sd">        Column label in the DataFrame to apply aggfunc.</span>
<span class="sd">    aggfunc : function or str</span>
<span class="sd">        Function to apply to the provided column. If string, the name of a built-in</span>
<span class="sd">        pandas function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame({&quot;key&quot;: [1, 1, 2], &quot;a&quot;: [-1, 0, 1], 1: [10, 11, 12]})</span>
<span class="sd">    &gt;&gt;&gt; agg_a = pd.NamedAgg(column=&quot;a&quot;, aggfunc=&quot;min&quot;)</span>
<span class="sd">    &gt;&gt;&gt; agg_1 = pd.NamedAgg(column=1, aggfunc=np.mean)</span>
<span class="sd">    &gt;&gt;&gt; df.groupby(&quot;key&quot;).agg(result_a=agg_a, result_1=agg_1)</span>
<span class="sd">         result_a  result_1</span>
<span class="sd">    key</span>
<span class="sd">    1          -1      10.5</span>
<span class="sd">    2           1      12.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">column</span><span class="p">:</span> <span class="n">Hashable</span>
    <span class="n">aggfunc</span><span class="p">:</span> <span class="n">AggScalar</span></div>


<span class="k">class</span> <span class="nc">SeriesGroupBy</span><span class="p">(</span><span class="n">GroupBy</span><span class="p">[</span><span class="n">Series</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">_wrap_agged_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mgr</span><span class="p">:</span> <span class="n">Manager</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_data_to_aggregate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SingleManager</span><span class="p">:</span>
        <span class="n">ser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_obj</span>
        <span class="n">single</span> <span class="o">=</span> <span class="n">ser</span><span class="o">.</span><span class="n">_mgr</span>
        <span class="k">if</span> <span class="n">numeric_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># GH#41291 match Series behavior</span>
            <span class="n">kwd_name</span> <span class="o">=</span> <span class="s2">&quot;numeric_only&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot use </span><span class="si">{</span><span class="n">kwd_name</span><span class="si">}</span><span class="s2">=True with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> and non-numeric dtypes.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">single</span>

    <span class="k">def</span> <span class="nf">_iterate_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Series</span><span class="p">]:</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_obj</span>

    <span class="n">_agg_examples_doc</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])</span>

<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    0    1</span>
<span class="sd">    1    2</span>
<span class="sd">    2    3</span>
<span class="sd">    3    4</span>
<span class="sd">    dtype: int64</span>

<span class="sd">    &gt;&gt;&gt; s.groupby([1, 1, 2, 2]).min()</span>
<span class="sd">    1    1</span>
<span class="sd">    2    3</span>
<span class="sd">    dtype: int64</span>

<span class="sd">    &gt;&gt;&gt; s.groupby([1, 1, 2, 2]).agg(&#39;min&#39;)</span>
<span class="sd">    1    1</span>
<span class="sd">    2    3</span>
<span class="sd">    dtype: int64</span>

<span class="sd">    &gt;&gt;&gt; s.groupby([1, 1, 2, 2]).agg([&#39;min&#39;, &#39;max&#39;])</span>
<span class="sd">       min  max</span>
<span class="sd">    1    1    2</span>
<span class="sd">    2    3    4</span>

<span class="sd">    The output column names can be controlled by passing</span>
<span class="sd">    the desired column names and aggregations as keyword arguments.</span>

<span class="sd">    &gt;&gt;&gt; s.groupby([1, 1, 2, 2]).agg(</span>
<span class="sd">    ...     minimum=&#39;min&#39;,</span>
<span class="sd">    ...     maximum=&#39;max&#39;,</span>
<span class="sd">    ... )</span>
<span class="sd">       minimum  maximum</span>
<span class="sd">    1        1        2</span>
<span class="sd">    2        3        4</span>

<span class="sd">    .. versionchanged:: 1.3.0</span>

<span class="sd">        The resulting dtype will reflect the return value of the aggregating function.</span>

<span class="sd">    &gt;&gt;&gt; s.groupby([1, 1, 2, 2]).agg(lambda x: x.astype(float).min())</span>
<span class="sd">    1    1.0</span>
<span class="sd">    2    3.0</span>
<span class="sd">    dtype: float64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_apply_docs</span><span class="p">[</span><span class="s2">&quot;template&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">input</span><span class="o">=</span><span class="s2">&quot;series&quot;</span><span class="p">,</span> <span class="n">examples</span><span class="o">=</span><span class="n">_apply_docs</span><span class="p">[</span><span class="s2">&quot;series_examples&quot;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">_agg_template</span><span class="p">,</span> <span class="n">examples</span><span class="o">=</span><span class="n">_agg_examples_doc</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="s2">&quot;Series&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">engine_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">maybe_use_numba</span><span class="p">(</span><span class="n">engine</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_with_numba</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">engine_kwargs</span><span class="o">=</span><span class="n">engine_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="n">relabeling</span> <span class="o">=</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">relabeling</span><span class="p">:</span>
            <span class="n">columns</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">validate_func_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="c1"># Catch instances of lists / tuples</span>
            <span class="c1"># but not the class list / tuple itself.</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">maybe_mangle_lambdas</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_multiple_funcs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">relabeling</span><span class="p">:</span>
                <span class="c1"># columns is not narrowed by mypy from relabeling flag</span>
                <span class="k">assert</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># for mypy</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">cyfunc</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">get_cython_func</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cyfunc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">args</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cyfunc</span><span class="p">)()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngroups</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># e.g. test_evaluate_with_empty_groups without any groups to</span>
                <span class="c1">#  iterate over, we have no output on which to do dtype</span>
                <span class="c1">#  inference. We default to using the existing dtype.</span>
                <span class="c1">#  xref GH#51445</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                    <span class="p">[],</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">result_index</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">nkeys</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_agg_general</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_agg_general</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># KeyError raised in test_groupby.test_basic is bc the func does</span>
                <span class="c1">#  a dictionary lookup on group.name, but group name is not</span>
                <span class="c1">#  pinned in _python_agg_general, only in _aggregate_named</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_named</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="c1"># result is a dict whose keys are the elements of result_index</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">result_index</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_aggregated_output</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>

    <span class="n">agg</span> <span class="o">=</span> <span class="n">aggregate</span>

    <span class="k">def</span> <span class="nf">_python_agg_general</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">is_builtin_func</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">agg_series</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_aggregated_output</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_aggregate_multiple_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">:</span>
                <span class="c1"># GH 15931</span>
                <span class="k">raise</span> <span class="n">SpecificationError</span><span class="p">(</span><span class="s2">&quot;nested renamer is not supported&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># GH#50684 - This accidentally worked in 1.x</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># list of functions / function names</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">get_callable_name</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">or</span> <span class="n">f</span><span class="p">)</span>

            <span class="n">arg</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

        <span class="n">results</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">OutputKey</span><span class="p">,</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="n">com</span><span class="o">.</span><span class="n">temp_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;as_index&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="c1"># Combine results using the index, need to adjust index after</span>
            <span class="c1"># if as_index=False (GH#50724)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">OutputKey</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">concat</span>

            <span class="n">res_df</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span>
                <span class="n">results</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">res_df</span>

        <span class="n">indexed_output</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="o">.</span><span class="n">position</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor_expanddim</span><span class="p">(</span><span class="n">indexed_output</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">results</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_wrap_applied_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Series</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
        <span class="n">not_indexed_same</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">is_transform</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap the output of SeriesGroupBy.apply into the expected result.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : Series</span>
<span class="sd">            Input data for groupby operation.</span>
<span class="sd">        values : List[Any]</span>
<span class="sd">            Applied output for each group.</span>
<span class="sd">        not_indexed_same : bool, default False</span>
<span class="sd">            Whether the applied outputs are not indexed the same as the group axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># GH #6265</span>
            <span class="k">if</span> <span class="n">is_transform</span><span class="p">:</span>
                <span class="c1"># GH#47787 see test_group_on_empty_multiindex</span>
                <span class="n">res_index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">result_index</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="p">[],</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">res_index</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="n">values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># GH #823 #24880</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">result_index</span>
            <span class="n">res_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor_expanddim</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="n">res_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_output</span><span class="p">(</span><span class="n">res_df</span><span class="p">)</span>
            <span class="c1"># if self.observed is False,</span>
            <span class="c1"># keep all-NaN rows created while re-indexing</span>
            <span class="n">res_ser</span> <span class="o">=</span> <span class="n">res_df</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">)</span>
            <span class="n">res_ser</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span>
            <span class="k">return</span> <span class="n">res_ser</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concat_objects</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span>
                <span class="n">not_indexed_same</span><span class="o">=</span><span class="n">not_indexed_same</span><span class="p">,</span>
                <span class="n">is_transform</span><span class="o">=</span><span class="n">is_transform</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span> <span class="ow">and</span> <span class="n">not_indexed_same</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert_inaxis_grouper</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># GH #6265 #24880</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">result_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert_inaxis_grouper</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_output</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_aggregate_named</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Note: this is very similar to _aggregate_series_pure_python,</span>
        <span class="c1">#  but that does not pin group.name</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">initialized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">libreduction</span><span class="o">.</span><span class="n">extract_result</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">initialized</span><span class="p">:</span>
                <span class="c1"># We only do this validation on the first iteration</span>
                <span class="n">libreduction</span><span class="o">.</span><span class="n">check_result_array</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">group</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">initialized</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="n">__examples_series_doc</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; ser = pd.Series(</span>
<span class="sd">    ...    [390.0, 350.0, 30.0, 20.0],</span>
<span class="sd">    ...    index=[&quot;Falcon&quot;, &quot;Falcon&quot;, &quot;Parrot&quot;, &quot;Parrot&quot;],</span>
<span class="sd">    ...    name=&quot;Max Speed&quot;)</span>
<span class="sd">    &gt;&gt;&gt; grouped = ser.groupby([1, 1, 2, 2])</span>
<span class="sd">    &gt;&gt;&gt; grouped.transform(lambda x: (x - x.mean()) / x.std())</span>
<span class="sd">        Falcon    0.707107</span>
<span class="sd">        Falcon   -0.707107</span>
<span class="sd">        Parrot    0.707107</span>
<span class="sd">        Parrot   -0.707107</span>
<span class="sd">        Name: Max Speed, dtype: float64</span>

<span class="sd">    Broadcast result of the transformation</span>

<span class="sd">    &gt;&gt;&gt; grouped.transform(lambda x: x.max() - x.min())</span>
<span class="sd">    Falcon    40.0</span>
<span class="sd">    Falcon    40.0</span>
<span class="sd">    Parrot    10.0</span>
<span class="sd">    Parrot    10.0</span>
<span class="sd">    Name: Max Speed, dtype: float64</span>

<span class="sd">    &gt;&gt;&gt; grouped.transform(&quot;mean&quot;)</span>
<span class="sd">    Falcon    370.0</span>
<span class="sd">    Falcon    370.0</span>
<span class="sd">    Parrot     25.0</span>
<span class="sd">    Parrot     25.0</span>
<span class="sd">    Name: Max Speed, dtype: float64</span>

<span class="sd">    .. versionchanged:: 1.3.0</span>

<span class="sd">    The resulting dtype will reflect the return value of the passed ``func``,</span>
<span class="sd">    for example:</span>

<span class="sd">    &gt;&gt;&gt; grouped.transform(lambda x: x.astype(int).max())</span>
<span class="sd">    Falcon    390</span>
<span class="sd">    Falcon    390</span>
<span class="sd">    Parrot     30</span>
<span class="sd">    Parrot     30</span>
<span class="sd">    Name: Max Speed, dtype: int64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="s2">&quot;Series&quot;</span><span class="p">,</span> <span class="n">example</span><span class="o">=</span><span class="n">__examples_series_doc</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_transform_template</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">engine_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">engine_kwargs</span><span class="o">=</span><span class="n">engine_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cython_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="k">assert</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># handled by caller</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_obj</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">_cython_operation</span><span class="p">(</span>
                <span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="c1"># e.g. test_groupby_raises_string</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2"> is not supported for </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> dtype&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_transform_general</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform with a callable func`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">get_iterator</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selected_obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span>
        <span class="p">):</span>
            <span class="c1"># this setattr is needed for test_transform_lambda_with_datetimetz</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">klass</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

        <span class="c1"># check for empty &quot;results&quot; to avoid concat ValueError</span>
        <span class="k">if</span> <span class="n">results</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>

            <span class="n">concatenated</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_result_index_ordered</span><span class="p">(</span><span class="n">concatenated</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter elements from groups that don&#39;t satisfy a criterion.</span>

<span class="sd">        Elements from groups are filtered if they do not satisfy the</span>
<span class="sd">        boolean criterion specified by func.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Criterion to apply to each group. Should return True or False.</span>
<span class="sd">        dropna : bool</span>
<span class="sd">            Drop groups that do not pass the filter. True by default; if False,</span>
<span class="sd">            groups that evaluate False are filled with NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Functions that mutate the passed object can produce unexpected</span>
<span class="sd">        behavior or errors and are not supported. See :ref:`gotchas.udf-mutation`</span>
<span class="sd">        for more details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39; : [&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;bar&#39;,</span>
<span class="sd">        ...                           &#39;foo&#39;, &#39;bar&#39;],</span>
<span class="sd">        ...                    &#39;B&#39; : [1, 2, 3, 4, 5, 6],</span>
<span class="sd">        ...                    &#39;C&#39; : [2.0, 5., 8., 1., 2., 9.]})</span>
<span class="sd">        &gt;&gt;&gt; grouped = df.groupby(&#39;A&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(&#39;A&#39;).B.filter(lambda x: x.mean() &gt; 3.)</span>
<span class="sd">        1    2</span>
<span class="sd">        3    4</span>
<span class="sd">        5    6</span>
<span class="sd">        Name: B, dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">wrapper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wrapper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Interpret np.nan as False.</span>
        <span class="k">def</span> <span class="nf">true_and_notna</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">notna</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">true_and_notna</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;the filter must return a boolean result&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="n">filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dropna</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filtered</span>

    <span class="k">def</span> <span class="nf">nunique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of unique elements in the group.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Number of unique values within each group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">group_info</span>

        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_values</span>

        <span class="n">codes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">sorter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">codes</span><span class="p">,</span> <span class="n">ids</span><span class="p">))</span>
        <span class="n">codes</span> <span class="o">=</span> <span class="n">codes</span><span class="p">[</span><span class="n">sorter</span><span class="p">]</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">sorter</span><span class="p">]</span>

        <span class="c1"># group boundaries are where group ids change</span>
        <span class="c1"># unique observations are where sorted values change</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">ids</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">codes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># 1st item of each group is a new unique observation</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">codes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">dropna</span><span class="p">:</span>
            <span class="n">inc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">inc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inc</span><span class="p">[</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">inc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>
            <span class="c1"># NaN/NaT group exists if the head of ids is -1,</span>
            <span class="c1"># so remove it from res and exclude its index from idx</span>
            <span class="k">if</span> <span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">result_index</span>

        <span class="c1"># we might have duplications among the bins</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ri</span><span class="p">):</span>
            <span class="n">res</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ri</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">res</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># GH#21334s</span>
                <span class="n">res</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">out</span>

        <span class="n">result</span><span class="p">:</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="n">res</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">ri</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert_inaxis_grouper</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_output</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">describe</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">value_counts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;proportion&quot;</span> <span class="k">if</span> <span class="n">normalize</span> <span class="k">else</span> <span class="s2">&quot;count&quot;</span>

        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_counts</span><span class="p">(</span>
                <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span>
            <span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="kn">from</span> <span class="nn">pandas.core.reshape.merge</span> <span class="kn">import</span> <span class="n">get_join_indexers</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.tile</span> <span class="kn">import</span> <span class="n">cut</span>

        <span class="n">ids</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">group_info</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_values</span>

        <span class="n">index_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">names</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># scalar bins cannot be done at top level</span>
            <span class="c1"># in a backward compatible way</span>
            <span class="c1"># GH38672 relates to categorical dtype</span>
            <span class="n">ser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="n">Series</span><span class="o">.</span><span class="n">value_counts</span><span class="p">,</span>
                <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
                <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ser</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">ser</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">index_names</span>
            <span class="k">return</span> <span class="n">ser</span>

        <span class="c1"># groupby removes null keys from groupings</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ids</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">ids</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">val</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lab</span><span class="p">,</span> <span class="n">lev</span> <span class="o">=</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">llab</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">lab</span><span class="p">,</span> <span class="n">inc</span><span class="p">:</span> <span class="n">lab</span><span class="p">[</span><span class="n">inc</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># lab is a Categorical with categories an IntervalIndex</span>
            <span class="n">cat_ser</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">Series</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">bins</span><span class="p">,</span> <span class="n">include_lowest</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">cat_obj</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;Categorical&quot;</span><span class="p">,</span> <span class="n">cat_ser</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
            <span class="n">lev</span> <span class="o">=</span> <span class="n">cat_obj</span><span class="o">.</span><span class="n">categories</span>
            <span class="n">lab</span> <span class="o">=</span> <span class="n">lev</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
                <span class="n">cat_obj</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span>
                <span class="n">allow_fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">lev</span><span class="o">.</span><span class="n">_na_value</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">llab</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">lab</span><span class="p">,</span> <span class="n">inc</span><span class="p">:</span> <span class="n">lab</span><span class="p">[</span><span class="n">inc</span><span class="p">]</span><span class="o">.</span><span class="n">_multiindex</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="n">lab</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># TODO: should we do this inside II?</span>
            <span class="n">lab_interval</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Interval</span><span class="p">,</span> <span class="n">lab</span><span class="p">)</span>

            <span class="n">sorter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">lab_interval</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">lab_interval</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">ids</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">lab</span><span class="p">,</span> <span class="n">ids</span><span class="p">))</span>

        <span class="n">ids</span><span class="p">,</span> <span class="n">lab</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">sorter</span><span class="p">],</span> <span class="n">lab</span><span class="p">[</span><span class="n">sorter</span><span class="p">]</span>

        <span class="c1"># group boundaries are where group ids change</span>
        <span class="n">idchanges</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">ids</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idchanges</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idchanges</span>

        <span class="c1"># new values are where sorted labels change</span>
        <span class="n">lchanges</span> <span class="o">=</span> <span class="n">llab</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="o">!=</span> <span class="n">llab</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="n">lchanges</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">inc</span> <span class="o">=</span> <span class="n">lchanges</span>
        <span class="n">inc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># group boundaries are also new values</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">inc</span><span class="p">,</span> <span class="kc">True</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># value counts</span>

        <span class="c1"># num. of times each group should be repeated</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>

        <span class="c1"># multi-index components</span>
        <span class="n">codes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">reconstructed_codes</span>
        <span class="n">codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">rep</span><span class="p">(</span><span class="n">level_codes</span><span class="p">)</span> <span class="k">for</span> <span class="n">level_codes</span> <span class="ow">in</span> <span class="n">codes</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">llab</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">inc</span><span class="p">)]</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">ping</span><span class="o">.</span><span class="n">group_index</span> <span class="k">for</span> <span class="n">ping</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">groupings</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">lev</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dropna</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">codes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">dropna</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="p">,</span> <span class="n">codes</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="p">[</span><span class="n">level_codes</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">level_codes</span> <span class="ow">in</span> <span class="n">codes</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)])</span>
            <span class="k">if</span> <span class="n">dropna</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">lab</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">rep</span><span class="p">(</span><span class="n">d</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">rep</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">/=</span> <span class="n">acc</span>

        <span class="k">if</span> <span class="n">sort</span> <span class="ow">and</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">inc</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="k">if</span> <span class="n">dropna</span> <span class="k">else</span> <span class="n">ids</span><span class="p">[</span><span class="n">inc</span><span class="p">]</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">out</span> <span class="k">if</span> <span class="n">ascending</span> <span class="k">else</span> <span class="o">-</span><span class="n">out</span><span class="p">,</span> <span class="n">cat</span><span class="p">))</span>
            <span class="n">out</span><span class="p">,</span> <span class="n">codes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">sorter</span><span class="p">],</span> <span class="n">codes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">sorter</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># for compat. with libgroupby.value_counts need to ensure every</span>
            <span class="c1"># bin is present at every index level, null filled with zeros</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">level_codes</span> <span class="ow">in</span> <span class="n">codes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">diff</span> <span class="o">|=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="n">level_codes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">level_codes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">ncat</span><span class="p">,</span> <span class="n">nbin</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncat</span><span class="p">),</span> <span class="n">nbin</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbin</span><span class="p">),</span> <span class="n">ncat</span><span class="p">)]</span>

            <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">diff</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">codes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_join_indexers</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
                <span class="n">sorter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">out</span> <span class="k">if</span> <span class="n">ascending</span> <span class="k">else</span> <span class="o">-</span><span class="n">out</span><span class="p">,</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">out</span><span class="p">,</span> <span class="n">left</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">sorter</span><span class="p">],</span> <span class="n">left</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">sorter</span><span class="p">]</span>

            <span class="c1"># build the multi-index w/ full levels</span>
            <span class="k">def</span> <span class="nf">build_codes</span><span class="p">(</span><span class="n">lev_codes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">lev_codes</span><span class="p">[</span><span class="n">diff</span><span class="p">],</span> <span class="n">nbin</span><span class="p">)</span>

            <span class="n">codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">build_codes</span><span class="p">(</span><span class="n">lev_codes</span><span class="p">)</span> <span class="k">for</span> <span class="n">lev_codes</span> <span class="ow">in</span> <span class="n">codes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">codes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">mi</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="p">(</span>
            <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">codes</span><span class="o">=</span><span class="n">codes</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">index_names</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">ensure_int64</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">mi</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="nb">object</span> <span class="o">|</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NA/NaN values using the specified method within groups.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, dict, Series, or DataFrame</span>
<span class="sd">            Value to use to fill holes (e.g. 0), alternately a</span>
<span class="sd">            dict/Series/DataFrame of values specifying which value to use for</span>
<span class="sd">            each index (for a Series) or column (for a DataFrame).  Values not</span>
<span class="sd">            in the dict/Series/DataFrame will not be filled. This value cannot</span>
<span class="sd">            be a list. Users wanting to use the ``value`` argument and not ``method``</span>
<span class="sd">            should prefer :meth:`.Series.fillna` as this</span>
<span class="sd">            will produce the same result and be more performant.</span>
<span class="sd">        method : {{&#39;bfill&#39;, &#39;ffill&#39;, None}}, default None</span>
<span class="sd">            Method to use for filling holes. ``&#39;ffill&#39;`` will propagate</span>
<span class="sd">            the last valid observation forward within a group.</span>
<span class="sd">            ``&#39;bfill&#39;`` will use next valid observation to fill the gap.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}</span>
<span class="sd">            Unused, only for compatibility with :meth:`DataFrameGroupBy.fillna`.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Broken. Do not set to True.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            If method is specified, this is the maximum number of consecutive</span>
<span class="sd">            NaN values to forward/backward fill within a group. In other words,</span>
<span class="sd">            if there is a gap with more than this number of consecutive NaNs,</span>
<span class="sd">            it will only be partially filled. If method is not specified, this is the</span>
<span class="sd">            maximum number of entries along the entire axis where NaNs will be</span>
<span class="sd">            filled. Must be greater than 0 if not None.</span>
<span class="sd">        downcast : dict, default is None</span>
<span class="sd">            A dict of item-&gt;dtype of what to downcast if possible,</span>
<span class="sd">            or the string &#39;infer&#39; which will try to downcast to an appropriate</span>
<span class="sd">            equal type (e.g. float64 to int64 if possible).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Object with missing values filled within groups.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ffill : Forward fill values within a group.</span>
<span class="sd">        bfill : Backward fill values within a group.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ser = pd.Series([np.nan, np.nan, 2, 3, np.nan, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; ser</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    3.0</span>
<span class="sd">        4    NaN</span>
<span class="sd">        5    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Propagate non-null values forward or backward within each group.</span>

<span class="sd">        &gt;&gt;&gt; ser.groupby([0, 0, 0, 1, 1, 1]).fillna(method=&quot;ffill&quot;)</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    3.0</span>
<span class="sd">        4    3.0</span>
<span class="sd">        5    3.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; ser.groupby([0, 0, 0, 1, 1, 1]).fillna(method=&quot;bfill&quot;)</span>
<span class="sd">        0    2.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    3.0</span>
<span class="sd">        4    NaN</span>
<span class="sd">        5    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Only replace the first NaN element within a group.</span>

<span class="sd">        &gt;&gt;&gt; ser.groupby([0, 0, 0, 1, 1, 1]).fillna(method=&quot;ffill&quot;, limit=1)</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    3.0</span>
<span class="sd">        4    3.0</span>
<span class="sd">        5    NaN</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;fillna&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="n">TakeIndexer</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the elements in the given *positional* indices in each group.</span>

<span class="sd">        This means that we are not indexing according to actual values in</span>
<span class="sd">        the index attribute of the object. We are indexing according to the</span>
<span class="sd">        actual position of the element in the object.</span>

<span class="sd">        If a requested index does not exist for some group, this method will raise.</span>
<span class="sd">        To get similar behavior that ignores indices that don&#39;t exist, see</span>
<span class="sd">        :meth:`.SeriesGroupBy.nth`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : array-like</span>
<span class="sd">            An array of ints indicating which positions to take in each group.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default 0</span>
<span class="sd">            The axis on which to select elements. ``0`` means that we are</span>
<span class="sd">            selecting rows, ``1`` means that we are selecting columns.</span>
<span class="sd">            For `SeriesGroupBy` this parameter is unused and defaults to 0.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            For compatibility with :meth:`numpy.take`. Has no effect on the</span>
<span class="sd">            output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            A Series containing the elements taken from each group.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.take : Take elements from a Series along an axis.</span>
<span class="sd">        Series.loc : Select a subset of a DataFrame by labels.</span>
<span class="sd">        Series.iloc : Select a subset of a DataFrame by positions.</span>
<span class="sd">        numpy.take : Take elements from an array along an axis.</span>
<span class="sd">        SeriesGroupBy.nth : Similar to take, won&#39;t raise if indices don&#39;t exist.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;falcon&#39;, &#39;bird&#39;, 389.0),</span>
<span class="sd">        ...                    (&#39;parrot&#39;, &#39;bird&#39;, 24.0),</span>
<span class="sd">        ...                    (&#39;lion&#39;, &#39;mammal&#39;, 80.5),</span>
<span class="sd">        ...                    (&#39;monkey&#39;, &#39;mammal&#39;, np.nan),</span>
<span class="sd">        ...                    (&#39;rabbit&#39;, &#39;mammal&#39;, 15.0)],</span>
<span class="sd">        ...                   columns=[&#39;name&#39;, &#39;class&#39;, &#39;max_speed&#39;],</span>
<span class="sd">        ...                   index=[4, 3, 2, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        4  falcon    bird      389.0</span>
<span class="sd">        3  parrot    bird       24.0</span>
<span class="sd">        2    lion  mammal       80.5</span>
<span class="sd">        1  monkey  mammal        NaN</span>
<span class="sd">        0  rabbit  mammal       15.0</span>
<span class="sd">        &gt;&gt;&gt; gb = df[&quot;name&quot;].groupby([1, 1, 2, 2, 2])</span>

<span class="sd">        Take elements at positions 0 and 1 along the axis 0 in each group (default).</span>

<span class="sd">        &gt;&gt;&gt; gb.take([0, 1])</span>
<span class="sd">        1  4    falcon</span>
<span class="sd">           3    parrot</span>
<span class="sd">        2  2      lion</span>
<span class="sd">           1    monkey</span>
<span class="sd">        Name: name, dtype: object</span>

<span class="sd">        We may take elements using negative integers for positive indices,</span>
<span class="sd">        starting from the end of the object, just like with Python lists.</span>

<span class="sd">        &gt;&gt;&gt; gb.take([-1, -2])</span>
<span class="sd">        1  3    parrot</span>
<span class="sd">           4    falcon</span>
<span class="sd">        2  0    rabbit</span>
<span class="sd">           1    monkey</span>
<span class="sd">        Name: name, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span><span class="s2">&quot;take&quot;</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return unbiased skew within groups.</span>

<span class="sd">        Normalized by N-1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default 0</span>
<span class="sd">            Axis for the function to be applied on.</span>
<span class="sd">            This parameter is only for compatibility with DataFrame and is unused.</span>

<span class="sd">        skipna : bool, default True</span>
<span class="sd">            Exclude NA/null values when computing the result.</span>

<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            Include only float, int, boolean columns. Not implemented for Series.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to be passed to the function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.skew : Return unbiased skew over requested axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ser = pd.Series([390., 350., 357., np.nan, 22., 20., 30.],</span>
<span class="sd">        ...                 index=[&#39;Falcon&#39;, &#39;Falcon&#39;, &#39;Falcon&#39;, &#39;Falcon&#39;,</span>
<span class="sd">        ...                        &#39;Parrot&#39;, &#39;Parrot&#39;, &#39;Parrot&#39;],</span>
<span class="sd">        ...                 name=&quot;Max Speed&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ser</span>
<span class="sd">        Falcon    390.0</span>
<span class="sd">        Falcon    350.0</span>
<span class="sd">        Falcon    357.0</span>
<span class="sd">        Falcon      NaN</span>
<span class="sd">        Parrot     22.0</span>
<span class="sd">        Parrot     20.0</span>
<span class="sd">        Parrot     30.0</span>
<span class="sd">        Name: Max Speed, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; ser.groupby(level=0).skew()</span>
<span class="sd">        Falcon    1.525174</span>
<span class="sd">        Parrot    1.457863</span>
<span class="sd">        Name: Max Speed, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; ser.groupby(level=0).skew(skipna=False)</span>
<span class="sd">        Falcon         NaN</span>
<span class="sd">        Parrot    1.457863</span>
<span class="sd">        Name: Max Speed, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;skew&quot;</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">GroupByPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">nlargest</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">nlargest</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">nlargest</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_obj</span>
        <span class="c1"># Don&#39;t change behavior if result index happens to be the same, i.e.</span>
        <span class="c1"># already ordered and n &gt;= all group sizes.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_apply_general</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">not_indexed_same</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">nsmallest</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">nsmallest</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_obj</span>
        <span class="c1"># Don&#39;t change behavior if result index happens to be the same, i.e.</span>
        <span class="c1"># already ordered and n &gt;= all group sizes.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_apply_general</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">not_indexed_same</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">idxmin</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">idxmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span><span class="s2">&quot;idxmin&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">idxmax</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">idxmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span><span class="s2">&quot;idxmax&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">corr</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Series</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">CorrelationMethod</span> <span class="o">=</span> <span class="s2">&quot;pearson&quot;</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;corr&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Series</span><span class="p">,</span> <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_monotonic_increasing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ser</span><span class="p">:</span> <span class="n">ser</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_monotonic_decreasing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ser</span><span class="p">:</span> <span class="n">ser</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">xlabelsize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">xrot</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ylabelsize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">yrot</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;hist&quot;</span><span class="p">,</span>
            <span class="n">by</span><span class="o">=</span><span class="n">by</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">xlabelsize</span><span class="o">=</span><span class="n">xlabelsize</span><span class="p">,</span>
            <span class="n">xrot</span><span class="o">=</span><span class="n">xrot</span><span class="p">,</span>
            <span class="n">ylabelsize</span><span class="o">=</span><span class="n">ylabelsize</span><span class="p">,</span>
            <span class="n">yrot</span><span class="o">=</span><span class="n">yrot</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
            <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span>
            <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span>
            <span class="n">legend</span><span class="o">=</span><span class="n">legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ser</span><span class="p">:</span> <span class="n">ser</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">unique</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span><span class="s2">&quot;unique&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">DataFrameGroupBy</span><span class="p">(</span><span class="n">GroupBy</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">]):</span>
    <span class="n">_agg_examples_doc</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame(</span>
<span class="sd">    ...     {</span>
<span class="sd">    ...         &quot;A&quot;: [1, 1, 2, 2],</span>
<span class="sd">    ...         &quot;B&quot;: [1, 2, 3, 4],</span>
<span class="sd">    ...         &quot;C&quot;: [0.362838, 0.227877, 1.267767, -0.562860],</span>
<span class="sd">    ...     }</span>
<span class="sd">    ... )</span>

<span class="sd">    &gt;&gt;&gt; df</span>
<span class="sd">       A  B         C</span>
<span class="sd">    0  1  1  0.362838</span>
<span class="sd">    1  1  2  0.227877</span>
<span class="sd">    2  2  3  1.267767</span>
<span class="sd">    3  2  4 -0.562860</span>

<span class="sd">    The aggregation is for each column.</span>

<span class="sd">    &gt;&gt;&gt; df.groupby(&#39;A&#39;).agg(&#39;min&#39;)</span>
<span class="sd">       B         C</span>
<span class="sd">    A</span>
<span class="sd">    1  1  0.227877</span>
<span class="sd">    2  3 -0.562860</span>

<span class="sd">    Multiple aggregations</span>

<span class="sd">    &gt;&gt;&gt; df.groupby(&#39;A&#39;).agg([&#39;min&#39;, &#39;max&#39;])</span>
<span class="sd">        B             C</span>
<span class="sd">      min max       min       max</span>
<span class="sd">    A</span>
<span class="sd">    1   1   2  0.227877  0.362838</span>
<span class="sd">    2   3   4 -0.562860  1.267767</span>

<span class="sd">    Select a column for aggregation</span>

<span class="sd">    &gt;&gt;&gt; df.groupby(&#39;A&#39;).B.agg([&#39;min&#39;, &#39;max&#39;])</span>
<span class="sd">       min  max</span>
<span class="sd">    A</span>
<span class="sd">    1    1    2</span>
<span class="sd">    2    3    4</span>

<span class="sd">    User-defined function for aggregation</span>

<span class="sd">    &gt;&gt;&gt; df.groupby(&#39;A&#39;).agg(lambda x: sum(x) + 2)</span>
<span class="sd">        B	       C</span>
<span class="sd">    A</span>
<span class="sd">    1	5	2.590715</span>
<span class="sd">    2	9	2.704907</span>

<span class="sd">    Different aggregations per column</span>

<span class="sd">    &gt;&gt;&gt; df.groupby(&#39;A&#39;).agg({&#39;B&#39;: [&#39;min&#39;, &#39;max&#39;], &#39;C&#39;: &#39;sum&#39;})</span>
<span class="sd">        B             C</span>
<span class="sd">      min max       sum</span>
<span class="sd">    A</span>
<span class="sd">    1   1   2  0.590715</span>
<span class="sd">    2   3   4  0.704907</span>

<span class="sd">    To control the output names with different aggregations per column,</span>
<span class="sd">    pandas supports &quot;named aggregation&quot;</span>

<span class="sd">    &gt;&gt;&gt; df.groupby(&quot;A&quot;).agg(</span>
<span class="sd">    ...     b_min=pd.NamedAgg(column=&quot;B&quot;, aggfunc=&quot;min&quot;),</span>
<span class="sd">    ...     c_sum=pd.NamedAgg(column=&quot;C&quot;, aggfunc=&quot;sum&quot;))</span>
<span class="sd">       b_min     c_sum</span>
<span class="sd">    A</span>
<span class="sd">    1      1  0.590715</span>
<span class="sd">    2      3  0.704907</span>

<span class="sd">    - The keywords are the *output* column names</span>
<span class="sd">    - The values are tuples whose first element is the column to select</span>
<span class="sd">      and the second element is the aggregation to apply to that column.</span>
<span class="sd">      Pandas provides the ``pandas.NamedAgg`` namedtuple with the fields</span>
<span class="sd">      ``[&#39;column&#39;, &#39;aggfunc&#39;]`` to make it clearer what the arguments are.</span>
<span class="sd">      As usual, the aggregation can be a callable or a string alias.</span>

<span class="sd">    See :ref:`groupby.aggregate.named` for more.</span>

<span class="sd">    .. versionchanged:: 1.3.0</span>

<span class="sd">        The resulting dtype will reflect the return value of the aggregating function.</span>

<span class="sd">    &gt;&gt;&gt; df.groupby(&quot;A&quot;)[[&quot;B&quot;]].agg(lambda x: x.astype(float).min())</span>
<span class="sd">          B</span>
<span class="sd">    A</span>
<span class="sd">    1   1.0</span>
<span class="sd">    2   3.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">_agg_template</span><span class="p">,</span> <span class="n">examples</span><span class="o">=</span><span class="n">_agg_examples_doc</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">engine_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">maybe_use_numba</span><span class="p">(</span><span class="n">engine</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_with_numba</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">engine_kwargs</span><span class="o">=</span><span class="n">engine_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="n">relabeling</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">reconstruct_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">maybe_mangle_lambdas</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">GroupByApply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">agg</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">elif</span> <span class="n">relabeling</span><span class="p">:</span>
            <span class="c1"># this should be the only (non-raising) case with relabeling</span>
            <span class="c1"># used reordered index of columns</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">order</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="c1"># error: Incompatible types in assignment (expression has type</span>
            <span class="c1"># &quot;Optional[List[str]]&quot;, variable has type</span>
            <span class="c1"># &quot;Union[Union[Union[ExtensionArray, ndarray[Any, Any]],</span>
            <span class="c1"># Index, Series], Sequence[Any]]&quot;)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>  <span class="c1"># type: ignore[assignment]</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># grouper specific aggregations</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">nkeys</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># test_groupby_as_index_series_scalar gets here with &#39;not self.as_index&#39;</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_agg_general</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">args</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="c1"># test_pass_args_kwargs gets here (with and without as_index)</span>
                <span class="c1"># can&#39;t return early</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_frame</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># _aggregate_multiple_funcs does not allow self.axis == 1</span>
                <span class="c1"># Note: axis == 1 precludes &#39;not self.as_index&#39;, see __init__</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_frame</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># try to treat as if we are passing a list</span>
                <span class="n">gba</span> <span class="o">=</span> <span class="n">GroupByApply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">func</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{})</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">gba</span><span class="o">.</span><span class="n">agg</span><span class="p">()</span>

                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;No objects to concatenate&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">):</span>
                        <span class="k">raise</span>
                    <span class="c1"># _aggregate_frame can fail with e.g. func=Series.mode,</span>
                    <span class="c1"># where it expects 1D values but would be getting 2D values</span>
                    <span class="c1"># In other tests, using aggregate_frame instead of GroupByApply</span>
                    <span class="c1">#  would give correct values but incorrect dtypes</span>
                    <span class="c1">#  object vs float64 in test_cython_agg_empty_buckets</span>
                    <span class="c1">#  float64 vs int64 in test_category_order_apply</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_frame</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># GH#32040, GH#35246</span>
                    <span class="c1"># e.g. test_groupby_as_index_select_column_sum_empty_df</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert_inaxis_grouper</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="n">agg</span> <span class="o">=</span> <span class="n">aggregate</span>

    <span class="k">def</span> <span class="nf">_python_agg_general</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">is_builtin_func</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># iterate through &quot;columns&quot; ex exclusions to populate output dict</span>
        <span class="n">output</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">OutputKey</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngroups</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># e.g. test_evaluate_with_empty_groups different path gets different</span>
            <span class="c1">#  result dtype in empty case.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_apply_general</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_obj</span><span class="p">,</span> <span class="n">is_agg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iterate_slices</span><span class="p">()):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">agg_series</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">OutputKey</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">output</span><span class="p">:</span>
            <span class="c1"># e.g. test_margins_no_values_no_cols</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_apply_general</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_obj</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexed_output_to_ndframe</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_aggregated_output</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iterate_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Series</span><span class="p">]:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_obj</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">:</span>
            <span class="c1"># Occurs when doing DataFrameGroupBy(...)[&quot;X&quot;]</span>
            <span class="k">yield</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">:</span>
                    <span class="c1"># Note: if we tried to just iterate over _obj_with_exclusions,</span>
                    <span class="c1">#  we would break test_wrap_agg_out by yielding a column</span>
                    <span class="c1">#  that is skipped here but not dropped from obj_with_exclusions</span>
                    <span class="k">continue</span>

                <span class="k">yield</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_aggregate_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">nkeys</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Number of keys must be 1&quot;</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span>

        <span class="n">result</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">NDFrame</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">grp_df</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">get_iterator</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">):</span>
            <span class="n">fres</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">grp_df</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fres</span>

        <span class="n">result_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">result_index</span>
        <span class="n">other_ax</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">other_ax</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">result_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_wrap_applied_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
        <span class="n">not_indexed_same</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">is_transform</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_transform</span><span class="p">:</span>
                <span class="c1"># GH#47787 see test_group_on_empty_multiindex</span>
                <span class="n">res_index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">result_index</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">res_index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtypes</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># GH12824</span>
        <span class="c1"># using values[0] here breaks test_groupby_apply_none_first</span>
        <span class="n">first_not_none</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">not_none</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">first_not_none</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># GH9684 - All values are None, return an empty frame.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_not_none</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concat_objects</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span>
                <span class="n">not_indexed_same</span><span class="o">=</span><span class="n">not_indexed_same</span><span class="p">,</span>
                <span class="n">is_transform</span><span class="o">=</span><span class="n">is_transform</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">key_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">result_index</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_not_none</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
            <span class="c1"># GH#1738: values is list of arrays of unequal lengths</span>
            <span class="c1">#  fall through to the outer else clause</span>
            <span class="c1"># TODO: sure this is right?  we used to do this</span>
            <span class="c1">#  after raising AttributeError above</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">key_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_selection</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_not_none</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="c1"># values are not series or array-like but scalars</span>
            <span class="c1"># self._selection not passed through to Series as the</span>
            <span class="c1"># result should not take the name of original selection</span>
            <span class="c1"># of columns</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">key_index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_selection</span><span class="p">])</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert_inaxis_grouper</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># values are Series</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_applied_output_series</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span>
                <span class="n">not_indexed_same</span><span class="p">,</span>
                <span class="n">first_not_none</span><span class="p">,</span>
                <span class="n">key_index</span><span class="p">,</span>
                <span class="n">is_transform</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_wrap_applied_output_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Series</span><span class="p">],</span>
        <span class="n">not_indexed_same</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">first_not_none</span><span class="p">,</span>
        <span class="n">key_index</span><span class="p">:</span> <span class="n">Index</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">is_transform</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">first_not_none</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">()</span>
        <span class="n">backup</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">backup</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

        <span class="n">all_indexed_same</span> <span class="o">=</span> <span class="n">all_indexes_same</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_indexed_same</span><span class="p">:</span>
            <span class="c1"># GH 8467</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concat_objects</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span>
                <span class="n">not_indexed_same</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">is_transform</span><span class="o">=</span><span class="n">is_transform</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Combine values</span>
        <span class="c1"># vstack+constructor is faster than concat and handles MI-columns</span>
        <span class="n">stacked_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">key_index</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">first_not_none</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># GH6124 - propagate name of Series when it&#39;s consistent</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">}</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">first_not_none</span><span class="o">.</span><span class="n">index</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">key_index</span>
            <span class="n">stacked_values</span> <span class="o">=</span> <span class="n">stacked_values</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">stacked_values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
            <span class="c1"># We&#39;ll have the DataFrame constructor do inference</span>
            <span class="n">stacked_values</span> <span class="o">=</span> <span class="n">stacked_values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">stacked_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert_inaxis_grouper</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_output</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cython_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># handled by caller</span>

        <span class="c1"># With self.axis == 0, we have multi-block tests</span>
        <span class="c1">#  e.g. test_rank_min_int, test_cython_transform_frame</span>
        <span class="c1">#  test_transform_numeric_ret</span>
        <span class="c1"># With self.axis == 1, _get_data_to_aggregate does a transpose</span>
        <span class="c1">#  so we always have a single block.</span>
        <span class="n">mgr</span><span class="p">:</span> <span class="n">Manager2D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data_to_aggregate</span><span class="p">(</span>
            <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">how</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">arr_func</span><span class="p">(</span><span class="n">bvalues</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">_cython_operation</span><span class="p">(</span>
                <span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="n">bvalues</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="c1"># We could use `mgr.apply` here and not have to set_axis, but</span>
        <span class="c1">#  we would have to do shape gymnastics for ArrayManager compat</span>
        <span class="n">res_mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">grouped_reduce</span><span class="p">(</span><span class="n">arr_func</span><span class="p">)</span>
        <span class="n">res_mgr</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mgr</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">res_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_mgr</span><span class="p">)</span>
        <span class="n">res_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_transpose_result</span><span class="p">(</span><span class="n">res_df</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res_df</span>

    <span class="k">def</span> <span class="nf">_transform_general</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>

        <span class="n">applied</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">get_iterator</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">fast_path</span><span class="p">,</span> <span class="n">slow_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_define_paths</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Determine whether to use slow or fast path by evaluating on the first group.</span>
        <span class="c1"># Need to handle the case of an empty generator and process the result so that</span>
        <span class="c1"># it does not need to be computed again.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">path</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_path</span><span class="p">(</span><span class="n">fast_path</span><span class="p">,</span> <span class="n">slow_path</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="c1"># e.g. test_transform_with_non_scalar_group</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;transform must return a scalar value for each group&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
            <span class="k">if</span> <span class="n">group</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">_wrap_transform_general_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
                <span class="n">applied</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="c1"># Compute and process with the remaining groups</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">group</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">path</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">_wrap_transform_general_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
            <span class="n">applied</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="n">concat_index</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">obj</span><span class="o">.</span><span class="n">index</span>
        <span class="n">other_axis</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>  <span class="c1"># switches between 0 &amp; 1</span>
        <span class="n">concatenated</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">applied</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">concatenated</span> <span class="o">=</span> <span class="n">concatenated</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">concat_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">other_axis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_result_index_ordered</span><span class="p">(</span><span class="n">concatenated</span><span class="p">)</span>

    <span class="n">__examples_dataframe_doc</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39; : [&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;bar&#39;,</span>
<span class="sd">    ...                           &#39;foo&#39;, &#39;bar&#39;],</span>
<span class="sd">    ...                    &#39;B&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,</span>
<span class="sd">    ...                           &#39;two&#39;, &#39;two&#39;],</span>
<span class="sd">    ...                    &#39;C&#39; : [1, 5, 5, 2, 5, 5],</span>
<span class="sd">    ...                    &#39;D&#39; : [2.0, 5., 8., 1., 2., 9.]})</span>
<span class="sd">    &gt;&gt;&gt; grouped = df.groupby(&#39;A&#39;)[[&#39;C&#39;, &#39;D&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; grouped.transform(lambda x: (x - x.mean()) / x.std())</span>
<span class="sd">            C         D</span>
<span class="sd">    0 -1.154701 -0.577350</span>
<span class="sd">    1  0.577350  0.000000</span>
<span class="sd">    2  0.577350  1.154701</span>
<span class="sd">    3 -1.154701 -1.000000</span>
<span class="sd">    4  0.577350 -0.577350</span>
<span class="sd">    5  0.577350  1.000000</span>

<span class="sd">    Broadcast result of the transformation</span>

<span class="sd">    &gt;&gt;&gt; grouped.transform(lambda x: x.max() - x.min())</span>
<span class="sd">        C    D</span>
<span class="sd">    0  4.0  6.0</span>
<span class="sd">    1  3.0  8.0</span>
<span class="sd">    2  4.0  6.0</span>
<span class="sd">    3  3.0  8.0</span>
<span class="sd">    4  4.0  6.0</span>
<span class="sd">    5  3.0  8.0</span>

<span class="sd">    &gt;&gt;&gt; grouped.transform(&quot;mean&quot;)</span>
<span class="sd">        C    D</span>
<span class="sd">    0  3.666667  4.0</span>
<span class="sd">    1  4.000000  5.0</span>
<span class="sd">    2  3.666667  4.0</span>
<span class="sd">    3  4.000000  5.0</span>
<span class="sd">    4  3.666667  4.0</span>
<span class="sd">    5  4.000000  5.0</span>

<span class="sd">    .. versionchanged:: 1.3.0</span>

<span class="sd">    The resulting dtype will reflect the return value of the passed ``func``,</span>
<span class="sd">    for example:</span>

<span class="sd">    &gt;&gt;&gt; grouped.transform(lambda x: x.astype(int).max())</span>
<span class="sd">    C  D</span>
<span class="sd">    0  5  8</span>
<span class="sd">    1  5  9</span>
<span class="sd">    2  5  8</span>
<span class="sd">    3  5  9</span>
<span class="sd">    4  5  8</span>
<span class="sd">    5  5  9</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span> <span class="n">example</span><span class="o">=</span><span class="n">__examples_dataframe_doc</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_transform_template</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">engine_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">engine_kwargs</span><span class="o">=</span><span class="n">engine_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_define_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fast_path</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">func</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">slow_path</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fast_path</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">slow_path</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">fast_path</span><span class="p">,</span> <span class="n">slow_path</span>

    <span class="k">def</span> <span class="nf">_choose_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fast_path</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">slow_path</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">slow_path</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">slow_path</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngroups</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># no need to evaluate multiple paths when only</span>
            <span class="c1"># a single group exists</span>
            <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span>

        <span class="c1"># if we make it here, test if we can use the fast path</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">res_fast</span> <span class="o">=</span> <span class="n">fast_path</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">raise</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># GH#29631 For user-defined function, we can&#39;t predict what may be</span>
            <span class="c1">#  raised; see test_transform.test_transform_fastpath_raises</span>
            <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span>

        <span class="c1"># verify fast path returns either:</span>
        <span class="c1"># a DataFrame with columns equal to group.columns</span>
        <span class="c1"># OR a Series with index equal to group.columns</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res_fast</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">res_fast</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res_fast</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">res_fast</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span>

        <span class="k">if</span> <span class="n">res_fast</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">fast_path</span>

        <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter elements from groups that don&#39;t satisfy a criterion.</span>

<span class="sd">        Elements from groups are filtered if they do not satisfy the</span>
<span class="sd">        boolean criterion specified by func.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Criterion to apply to each group. Should return True or False.</span>
<span class="sd">        dropna : bool</span>
<span class="sd">            Drop groups that do not pass the filter. True by default; if False,</span>
<span class="sd">            groups that evaluate False are filled with NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Each subframe is endowed the attribute &#39;name&#39; in case you need to know</span>
<span class="sd">        which group you are working on.</span>

<span class="sd">        Functions that mutate the passed object can produce unexpected</span>
<span class="sd">        behavior or errors and are not supported. See :ref:`gotchas.udf-mutation`</span>
<span class="sd">        for more details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39; : [&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;bar&#39;,</span>
<span class="sd">        ...                           &#39;foo&#39;, &#39;bar&#39;],</span>
<span class="sd">        ...                    &#39;B&#39; : [1, 2, 3, 4, 5, 6],</span>
<span class="sd">        ...                    &#39;C&#39; : [2.0, 5., 8., 1., 2., 9.]})</span>
<span class="sd">        &gt;&gt;&gt; grouped = df.groupby(&#39;A&#39;)</span>
<span class="sd">        &gt;&gt;&gt; grouped.filter(lambda x: x[&#39;B&#39;].mean() &gt; 3.)</span>
<span class="sd">             A  B    C</span>
<span class="sd">        1  bar  2  5.0</span>
<span class="sd">        3  bar  4  1.0</span>
<span class="sd">        5  bar  6  9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_obj</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">get_iterator</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># allow e.g., scalars and frames to pass</span>
                <span class="k">pass</span>

            <span class="c1"># interpret the result of the filter</span>
            <span class="k">if</span> <span class="n">is_bool</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isna</span><span class="p">(</span><span class="n">res</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">notna</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="ow">and</span> <span class="n">res</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># non scalars aren&#39;t allowed</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;filter function returned a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;but expected a scalar bool&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dropna</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrameGroupBy</span> <span class="o">|</span> <span class="n">SeriesGroupBy</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># GH 37725</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot subset columns when using axis=1&quot;</span><span class="p">)</span>
        <span class="c1"># per GH 23566</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># if len == 1, then it becomes a SeriesGroupBy and this is actually</span>
            <span class="c1"># valid syntax, so don&#39;t raise</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot subset columns with a tuple with more than one element. &quot;</span>
                <span class="s2">&quot;Use a list instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gotitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ndim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sub-classes to define</span>
<span class="sd">        return a sliced object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : string / list of selections</span>
<span class="sd">        ndim : {1, 2}</span>
<span class="sd">            requested ndim of result</span>
<span class="sd">        subset : object, default None</span>
<span class="sd">            subset to act on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span>
            <span class="k">return</span> <span class="n">DataFrameGroupBy</span><span class="p">(</span>
                <span class="n">subset</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span>
                <span class="n">grouper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="p">,</span>
                <span class="n">exclusions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">,</span>
                <span class="n">selection</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                <span class="n">as_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">,</span>
                <span class="n">group_keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">group_keys</span><span class="p">,</span>
                <span class="n">observed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">,</span>
                <span class="n">dropna</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dropna</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">SeriesGroupBy</span><span class="p">(</span>
                <span class="n">subset</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span>
                <span class="n">grouper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="p">,</span>
                <span class="n">exclusions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">,</span>
                <span class="n">selection</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                <span class="n">as_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">,</span>
                <span class="n">group_keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">group_keys</span><span class="p">,</span>
                <span class="n">observed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">,</span>
                <span class="n">dropna</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dropna</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;invalid ndim for _gotitem&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_data_to_aggregate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Manager2D</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">_mgr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_mgr</span>

        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">get_numeric_data</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mgr</span>

    <span class="k">def</span> <span class="nf">_indexed_output_to_ndframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">OutputKey</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap the dict result of a GroupBy aggregation into a DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexed_output</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="o">.</span><span class="n">position</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">output</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">Index</span><span class="p">([</span><span class="n">key</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">output</span><span class="p">])</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">_set_names</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">indexed_output</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_wrap_agged_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mgr</span><span class="p">:</span> <span class="n">Manager2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iterate_column_groupbys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">colname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">colname</span><span class="p">,</span> <span class="n">SeriesGroupBy</span><span class="p">(</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                <span class="n">selection</span><span class="o">=</span><span class="n">colname</span><span class="p">,</span>
                <span class="n">grouper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="p">,</span>
                <span class="n">exclusions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">,</span>
                <span class="n">observed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_to_column_groupbys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">func</span><span class="p">(</span><span class="n">col_groupby</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">col_groupby</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iterate_column_groupbys</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
            <span class="c1"># concat would raise</span>
            <span class="k">return</span> <span class="n">DataFrame</span><span class="p">([],</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">result_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nunique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return DataFrame with counts of unique elements in each position.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dropna : bool, default True</span>
<span class="sd">            Don&#39;t include NaN in the counts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nunique: DataFrame</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;id&#39;: [&#39;spam&#39;, &#39;egg&#39;, &#39;egg&#39;, &#39;spam&#39;,</span>
<span class="sd">        ...                           &#39;ham&#39;, &#39;ham&#39;],</span>
<span class="sd">        ...                    &#39;value1&#39;: [1, 5, 5, 2, 5, 5],</span>
<span class="sd">        ...                    &#39;value2&#39;: list(&#39;abbaxy&#39;)})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             id  value1 value2</span>
<span class="sd">        0  spam       1      a</span>
<span class="sd">        1   egg       5      b</span>
<span class="sd">        2   egg       5      b</span>
<span class="sd">        3  spam       2      a</span>
<span class="sd">        4   ham       5      x</span>
<span class="sd">        5   ham       5      y</span>

<span class="sd">        &gt;&gt;&gt; df.groupby(&#39;id&#39;).nunique()</span>
<span class="sd">              value1  value2</span>
<span class="sd">        id</span>
<span class="sd">        egg        1       1</span>
<span class="sd">        ham        1       2</span>
<span class="sd">        spam       2       1</span>

<span class="sd">        Check for rows with the same id but conflicting values:</span>

<span class="sd">        &gt;&gt;&gt; df.groupby(&#39;id&#39;).filter(lambda g: (g.nunique() &gt; 1).any())</span>
<span class="sd">             id  value1 value2</span>
<span class="sd">        0  spam       1      a</span>
<span class="sd">        3  spam       2      a</span>
<span class="sd">        4   ham       5      x</span>
<span class="sd">        5   ham       5      y</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># see test_groupby_crash_on_nunique</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_apply_general</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">sgb</span><span class="p">:</span> <span class="n">sgb</span><span class="o">.</span><span class="n">nunique</span><span class="p">(</span><span class="n">dropna</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span><span class="p">,</span> <span class="n">is_agg</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_column_groupbys</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">sgb</span><span class="p">:</span> <span class="n">sgb</span><span class="o">.</span><span class="n">nunique</span><span class="p">(</span><span class="n">dropna</span><span class="p">),</span> <span class="n">obj</span><span class="o">=</span><span class="n">obj</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_index</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">))</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert_inaxis_grouper</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">idxmax</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index of first occurrence of maximum over requested axis.</span>

<span class="sd">        NA/null values are excluded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;}}, default None</span>
<span class="sd">            The axis to use. 0 or &#39;index&#39; for row-wise, 1 or &#39;columns&#39; for column-wise.</span>
<span class="sd">            If axis is not provided, grouper&#39;s axis is used.</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>

<span class="sd">        skipna : bool, default True</span>
<span class="sd">            Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="sd">            will be NA.</span>
<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            Include only `float`, `int` or `boolean` data.</span>

<span class="sd">            .. versionadded:: 1.5.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Indexes of maxima along the specified axis.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * If the row/column is empty</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.idxmax : Return index of the maximum element.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is the DataFrame version of ``ndarray.argmax``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider a dataset containing food consumption in Argentina.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;consumption&#39;: [10.51, 103.11, 55.48],</span>
<span class="sd">        ...                    &#39;co2_emissions&#39;: [37.2, 19.66, 1712]},</span>
<span class="sd">        ...                    index=[&#39;Pork&#39;, &#39;Wheat Products&#39;, &#39;Beef&#39;])</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                        consumption  co2_emissions</span>
<span class="sd">        Pork                  10.51         37.20</span>
<span class="sd">        Wheat Products       103.11         19.66</span>
<span class="sd">        Beef                  55.48       1712.00</span>

<span class="sd">        By default, it returns the index for the maximum value in each column.</span>

<span class="sd">        &gt;&gt;&gt; df.idxmax()</span>
<span class="sd">        consumption     Wheat Products</span>
<span class="sd">        co2_emissions             Beef</span>
<span class="sd">        dtype: object</span>

<span class="sd">        To return the index for the maximum value in each row, use ``axis=&quot;columns&quot;``.</span>

<span class="sd">        &gt;&gt;&gt; df.idxmax(axis=&quot;columns&quot;)</span>
<span class="sd">        Pork              co2_emissions</span>
<span class="sd">        Wheat Products     consumption</span>
<span class="sd">        Beef              co2_emissions</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">idxmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">)</span>

        <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">&quot;idxmax&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_apply_general</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span><span class="p">,</span> <span class="n">not_indexed_same</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">idxmin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index of first occurrence of minimum over requested axis.</span>

<span class="sd">        NA/null values are excluded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {{0 or &#39;index&#39;, 1 or &#39;columns&#39;}}, default None</span>
<span class="sd">            The axis to use. 0 or &#39;index&#39; for row-wise, 1 or &#39;columns&#39; for column-wise.</span>
<span class="sd">            If axis is not provided, grouper&#39;s axis is used.</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>

<span class="sd">        skipna : bool, default True</span>
<span class="sd">            Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="sd">            will be NA.</span>
<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            Include only `float`, `int` or `boolean` data.</span>

<span class="sd">            .. versionadded:: 1.5.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Indexes of minima along the specified axis.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * If the row/column is empty</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.idxmin : Return index of the minimum element.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is the DataFrame version of ``ndarray.argmin``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider a dataset containing food consumption in Argentina.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;consumption&#39;: [10.51, 103.11, 55.48],</span>
<span class="sd">        ...                    &#39;co2_emissions&#39;: [37.2, 19.66, 1712]},</span>
<span class="sd">        ...                    index=[&#39;Pork&#39;, &#39;Wheat Products&#39;, &#39;Beef&#39;])</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                        consumption  co2_emissions</span>
<span class="sd">        Pork                  10.51         37.20</span>
<span class="sd">        Wheat Products       103.11         19.66</span>
<span class="sd">        Beef                  55.48       1712.00</span>

<span class="sd">        By default, it returns the index for the minimum value in each column.</span>

<span class="sd">        &gt;&gt;&gt; df.idxmin()</span>
<span class="sd">        consumption                Pork</span>
<span class="sd">        co2_emissions    Wheat Products</span>
<span class="sd">        dtype: object</span>

<span class="sd">        To return the index for the minimum value in each row, use ``axis=&quot;columns&quot;``.</span>

<span class="sd">        &gt;&gt;&gt; df.idxmin(axis=&quot;columns&quot;)</span>
<span class="sd">        Pork                consumption</span>
<span class="sd">        Wheat Products    co2_emissions</span>
<span class="sd">        Beef                consumption</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">idxmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">)</span>

        <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">&quot;idxmin&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_apply_general</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_with_exclusions</span><span class="p">,</span> <span class="n">not_indexed_same</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">boxplot</span> <span class="o">=</span> <span class="n">boxplot_frame_groupby</span>

    <span class="k">def</span> <span class="nf">value_counts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Series or DataFrame containing counts of unique rows.</span>

<span class="sd">        .. versionadded:: 1.4.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : list-like, optional</span>
<span class="sd">            Columns to use when counting unique combinations.</span>
<span class="sd">        normalize : bool, default False</span>
<span class="sd">            Return proportions rather than frequencies.</span>
<span class="sd">        sort : bool, default True</span>
<span class="sd">            Sort by frequencies.</span>
<span class="sd">        ascending : bool, default False</span>
<span class="sd">            Sort in ascending order.</span>
<span class="sd">        dropna : bool, default True</span>
<span class="sd">            Don’t include counts of rows that contain NA values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Series if the groupby as_index is True, otherwise DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.value_counts: Equivalent method on Series.</span>
<span class="sd">        DataFrame.value_counts: Equivalent method on DataFrame.</span>
<span class="sd">        SeriesGroupBy.value_counts: Equivalent method on SeriesGroupBy.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If the groupby as_index is True then the returned Series will have a</span>
<span class="sd">          MultiIndex with one level per input column.</span>
<span class="sd">        - If the groupby as_index is False then the returned DataFrame will have an</span>
<span class="sd">          additional column with the value_counts. The column is labelled &#39;count&#39; or</span>
<span class="sd">          &#39;proportion&#39;, depending on the ``normalize`` parameter.</span>

<span class="sd">        By default, rows that contain any NA values are omitted from</span>
<span class="sd">        the result.</span>

<span class="sd">        By default, the result will be in descending order so that the</span>
<span class="sd">        first element of each group is the most frequently-occurring row.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...    &#39;gender&#39;: [&#39;male&#39;, &#39;male&#39;, &#39;female&#39;, &#39;male&#39;, &#39;female&#39;, &#39;male&#39;],</span>
<span class="sd">        ...    &#39;education&#39;: [&#39;low&#39;, &#39;medium&#39;, &#39;high&#39;, &#39;low&#39;, &#39;high&#39;, &#39;low&#39;],</span>
<span class="sd">        ...    &#39;country&#39;: [&#39;US&#39;, &#39;FR&#39;, &#39;US&#39;, &#39;FR&#39;, &#39;FR&#39;, &#39;FR&#39;]</span>
<span class="sd">        ... })</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                gender  education   country</span>
<span class="sd">        0       male    low         US</span>
<span class="sd">        1       male    medium      FR</span>
<span class="sd">        2       female  high        US</span>
<span class="sd">        3       male    low         FR</span>
<span class="sd">        4       female  high        FR</span>
<span class="sd">        5       male    low         FR</span>

<span class="sd">        &gt;&gt;&gt; df.groupby(&#39;gender&#39;).value_counts()</span>
<span class="sd">        gender  education  country</span>
<span class="sd">        female  high       FR         1</span>
<span class="sd">                           US         1</span>
<span class="sd">        male    low        FR         2</span>
<span class="sd">                           US         1</span>
<span class="sd">                medium     FR         1</span>
<span class="sd">        Name: count, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.groupby(&#39;gender&#39;).value_counts(ascending=True)</span>
<span class="sd">        gender  education  country</span>
<span class="sd">        female  high       FR         1</span>
<span class="sd">                           US         1</span>
<span class="sd">        male    low        US         1</span>
<span class="sd">                medium     FR         1</span>
<span class="sd">                low        FR         2</span>
<span class="sd">        Name: count, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.groupby(&#39;gender&#39;).value_counts(normalize=True)</span>
<span class="sd">        gender  education  country</span>
<span class="sd">        female  high       FR         0.50</span>
<span class="sd">                           US         0.50</span>
<span class="sd">        male    low        FR         0.50</span>
<span class="sd">                           US         0.25</span>
<span class="sd">                medium     FR         0.25</span>
<span class="sd">        Name: proportion, dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; df.groupby(&#39;gender&#39;, as_index=False).value_counts()</span>
<span class="sd">           gender education country  count</span>
<span class="sd">        0  female      high      FR      1</span>
<span class="sd">        1  female      high      US      1</span>
<span class="sd">        2    male       low      FR      2</span>
<span class="sd">        3    male       low      US      1</span>
<span class="sd">        4    male    medium      FR      1</span>

<span class="sd">        &gt;&gt;&gt; df.groupby(&#39;gender&#39;, as_index=False).value_counts(normalize=True)</span>
<span class="sd">           gender education country  proportion</span>
<span class="sd">        0  female      high      FR        0.50</span>
<span class="sd">        1  female      high      US        0.50</span>
<span class="sd">        2    male       low      FR        0.50</span>
<span class="sd">        3    male       low      US        0.25</span>
<span class="sd">        4    male    medium      FR        0.25</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_counts</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">normalize</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">ascending</span><span class="p">,</span> <span class="n">dropna</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NA/NaN values using the specified method within groups.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, dict, Series, or DataFrame</span>
<span class="sd">            Value to use to fill holes (e.g. 0), alternately a</span>
<span class="sd">            dict/Series/DataFrame of values specifying which value to use for</span>
<span class="sd">            each index (for a Series) or column (for a DataFrame).  Values not</span>
<span class="sd">            in the dict/Series/DataFrame will not be filled. This value cannot</span>
<span class="sd">            be a list. Users wanting to use the ``value`` argument and not ``method``</span>
<span class="sd">            should prefer :meth:`.DataFrame.fillna` as this</span>
<span class="sd">            will produce the same result and be more performant.</span>
<span class="sd">        method : {{&#39;bfill&#39;, &#39;ffill&#39;, None}}, default None</span>
<span class="sd">            Method to use for filling holes. ``&#39;ffill&#39;`` will propagate</span>
<span class="sd">            the last valid observation forward within a group.</span>
<span class="sd">            ``&#39;bfill&#39;`` will use next valid observation to fill the gap.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}</span>
<span class="sd">            Axis along which to fill missing values. When the :class:`DataFrameGroupBy`</span>
<span class="sd">            ``axis`` argument is ``0``, using ``axis=1`` here will produce</span>
<span class="sd">            the same results as :meth:`.DataFrame.fillna`. When the</span>
<span class="sd">            :class:`DataFrameGroupBy` ``axis`` argument is ``1``, using ``axis=0``</span>
<span class="sd">            or ``axis=1`` here will produce the same results.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Broken. Do not set to True.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            If method is specified, this is the maximum number of consecutive</span>
<span class="sd">            NaN values to forward/backward fill within a group. In other words,</span>
<span class="sd">            if there is a gap with more than this number of consecutive NaNs,</span>
<span class="sd">            it will only be partially filled. If method is not specified, this is the</span>
<span class="sd">            maximum number of entries along the entire axis where NaNs will be</span>
<span class="sd">            filled. Must be greater than 0 if not None.</span>
<span class="sd">        downcast : dict, default is None</span>
<span class="sd">            A dict of item-&gt;dtype of what to downcast if possible,</span>
<span class="sd">            or the string &#39;infer&#39; which will try to downcast to an appropriate</span>
<span class="sd">            equal type (e.g. float64 to int64 if possible).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Object with missing values filled.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ffill : Forward fill values within a group.</span>
<span class="sd">        bfill : Backward fill values within a group.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(</span>
<span class="sd">        ...     {</span>
<span class="sd">        ...         &quot;key&quot;: [0, 0, 1, 1, 1],</span>
<span class="sd">        ...         &quot;A&quot;: [np.nan, 2, np.nan, 3, np.nan],</span>
<span class="sd">        ...         &quot;B&quot;: [2, 3, np.nan, np.nan, np.nan],</span>
<span class="sd">        ...         &quot;C&quot;: [np.nan, np.nan, 2, np.nan, np.nan],</span>
<span class="sd">        ...     }</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           key    A    B   C</span>
<span class="sd">        0    0  NaN  2.0 NaN</span>
<span class="sd">        1    0  2.0  3.0 NaN</span>
<span class="sd">        2    1  NaN  NaN 2.0</span>
<span class="sd">        3    1  3.0  NaN NaN</span>
<span class="sd">        4    1  NaN  NaN NaN</span>

<span class="sd">        Propagate non-null values forward or backward within each group along columns.</span>

<span class="sd">        &gt;&gt;&gt; df.groupby(&quot;key&quot;).fillna(method=&quot;ffill&quot;)</span>
<span class="sd">             A    B   C</span>
<span class="sd">        0  NaN  2.0 NaN</span>
<span class="sd">        1  2.0  3.0 NaN</span>
<span class="sd">        2  NaN  NaN 2.0</span>
<span class="sd">        3  3.0  NaN 2.0</span>
<span class="sd">        4  3.0  NaN 2.0</span>

<span class="sd">        &gt;&gt;&gt; df.groupby(&quot;key&quot;).fillna(method=&quot;bfill&quot;)</span>
<span class="sd">             A    B   C</span>
<span class="sd">        0  2.0  2.0 NaN</span>
<span class="sd">        1  2.0  3.0 NaN</span>
<span class="sd">        2  3.0  NaN 2.0</span>
<span class="sd">        3  3.0  NaN NaN</span>
<span class="sd">        4  NaN  NaN NaN</span>

<span class="sd">        Propagate non-null values forward or backward within each group along rows.</span>

<span class="sd">        &gt;&gt;&gt; df.groupby([0, 0, 1, 1], axis=1).fillna(method=&quot;ffill&quot;)</span>
<span class="sd">           key    A    B    C</span>
<span class="sd">        0  0.0  0.0  2.0  2.0</span>
<span class="sd">        1  0.0  2.0  3.0  3.0</span>
<span class="sd">        2  1.0  1.0  NaN  2.0</span>
<span class="sd">        3  1.0  3.0  NaN  NaN</span>
<span class="sd">        4  1.0  1.0  NaN  NaN</span>

<span class="sd">        &gt;&gt;&gt; df.groupby([0, 0, 1, 1], axis=1).fillna(method=&quot;bfill&quot;)</span>
<span class="sd">           key    A    B    C</span>
<span class="sd">        0  0.0  NaN  2.0  NaN</span>
<span class="sd">        1  0.0  2.0  3.0  NaN</span>
<span class="sd">        2  1.0  NaN  2.0  2.0</span>
<span class="sd">        3  1.0  3.0  NaN  NaN</span>
<span class="sd">        4  1.0  NaN  NaN  NaN</span>

<span class="sd">        Only replace the first NaN element within a group along rows.</span>

<span class="sd">        &gt;&gt;&gt; df.groupby(&quot;key&quot;).fillna(method=&quot;ffill&quot;, limit=1)</span>
<span class="sd">             A    B    C</span>
<span class="sd">        0  NaN  2.0  NaN</span>
<span class="sd">        1  2.0  3.0  NaN</span>
<span class="sd">        2  NaN  NaN  2.0</span>
<span class="sd">        3  3.0  NaN  2.0</span>
<span class="sd">        4  3.0  NaN  NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;fillna&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="n">TakeIndexer</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the elements in the given *positional* indices in each group.</span>

<span class="sd">        This means that we are not indexing according to actual values in</span>
<span class="sd">        the index attribute of the object. We are indexing according to the</span>
<span class="sd">        actual position of the element in the object.</span>

<span class="sd">        If a requested index does not exist for some group, this method will raise.</span>
<span class="sd">        To get similar behavior that ignores indices that don&#39;t exist, see</span>
<span class="sd">        :meth:`.DataFrameGroupBy.nth`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : array-like</span>
<span class="sd">            An array of ints indicating which positions to take.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default 0</span>
<span class="sd">            The axis on which to select elements. ``0`` means that we are</span>
<span class="sd">            selecting rows, ``1`` means that we are selecting columns.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            For compatibility with :meth:`numpy.take`. Has no effect on the</span>
<span class="sd">            output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            An DataFrame containing the elements taken from each group.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.take : Take elements from a Series along an axis.</span>
<span class="sd">        DataFrame.loc : Select a subset of a DataFrame by labels.</span>
<span class="sd">        DataFrame.iloc : Select a subset of a DataFrame by positions.</span>
<span class="sd">        numpy.take : Take elements from an array along an axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;falcon&#39;, &#39;bird&#39;, 389.0),</span>
<span class="sd">        ...                    (&#39;parrot&#39;, &#39;bird&#39;, 24.0),</span>
<span class="sd">        ...                    (&#39;lion&#39;, &#39;mammal&#39;, 80.5),</span>
<span class="sd">        ...                    (&#39;monkey&#39;, &#39;mammal&#39;, np.nan),</span>
<span class="sd">        ...                    (&#39;rabbit&#39;, &#39;mammal&#39;, 15.0)],</span>
<span class="sd">        ...                   columns=[&#39;name&#39;, &#39;class&#39;, &#39;max_speed&#39;],</span>
<span class="sd">        ...                   index=[4, 3, 2, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        4  falcon    bird      389.0</span>
<span class="sd">        3  parrot    bird       24.0</span>
<span class="sd">        2    lion  mammal       80.5</span>
<span class="sd">        1  monkey  mammal        NaN</span>
<span class="sd">        0  rabbit  mammal       15.0</span>
<span class="sd">        &gt;&gt;&gt; gb = df.groupby([1, 1, 2, 2, 2])</span>

<span class="sd">        Take elements at positions 0 and 1 along the axis 0 (default).</span>

<span class="sd">        Note how the indices selected in the result do not correspond to</span>
<span class="sd">        our input indices 0 and 1. That&#39;s because we are selecting the 0th</span>
<span class="sd">        and 1st rows, not rows whose indices equal 0 and 1.</span>

<span class="sd">        &gt;&gt;&gt; gb.take([0, 1])</span>
<span class="sd">               name   class  max_speed</span>
<span class="sd">        1 4  falcon    bird      389.0</span>
<span class="sd">          3  parrot    bird       24.0</span>
<span class="sd">        2 2    lion  mammal       80.5</span>
<span class="sd">          1  monkey  mammal        NaN</span>

<span class="sd">        The order of the specified indices influences the order in the result.</span>
<span class="sd">        Here, the order is swapped from the previous example.</span>

<span class="sd">        &gt;&gt;&gt; gb.take([1, 0])</span>
<span class="sd">               name   class  max_speed</span>
<span class="sd">        1 3  parrot    bird       24.0</span>
<span class="sd">          4  falcon    bird      389.0</span>
<span class="sd">        2 1  monkey  mammal        NaN</span>
<span class="sd">          2    lion  mammal       80.5</span>

<span class="sd">        Take elements at indices 1 and 2 along the axis 1 (column selection).</span>

<span class="sd">        We may take elements using negative integers for positive indices,</span>
<span class="sd">        starting from the end of the object, just like with Python lists.</span>

<span class="sd">        &gt;&gt;&gt; gb.take([-1, -2])</span>
<span class="sd">               name   class  max_speed</span>
<span class="sd">        1 3  parrot    bird       24.0</span>
<span class="sd">          4  falcon    bird      389.0</span>
<span class="sd">        2 0  rabbit  mammal       15.0</span>
<span class="sd">          1  monkey  mammal        NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span><span class="s2">&quot;take&quot;</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return unbiased skew within groups.</span>

<span class="sd">        Normalized by N-1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default 0</span>
<span class="sd">            Axis for the function to be applied on.</span>

<span class="sd">            Specifying ``axis=None`` will apply the aggregation across both axes.</span>

<span class="sd">            .. versionadded:: 2.0.0</span>

<span class="sd">        skipna : bool, default True</span>
<span class="sd">            Exclude NA/null values when computing the result.</span>

<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            Include only float, int, boolean columns.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to be passed to the function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.skew : Return unbiased skew over requested axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arrays = [[&#39;falcon&#39;, &#39;parrot&#39;, &#39;cockatoo&#39;, &#39;kiwi&#39;,</span>
<span class="sd">        ...            &#39;lion&#39;, &#39;monkey&#39;, &#39;rabbit&#39;],</span>
<span class="sd">        ...           [&#39;bird&#39;, &#39;bird&#39;, &#39;bird&#39;, &#39;bird&#39;,</span>
<span class="sd">        ...            &#39;mammal&#39;, &#39;mammal&#39;, &#39;mammal&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(arrays, names=(&#39;name&#39;, &#39;class&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;max_speed&#39;: [389.0, 24.0, 70.0, np.nan,</span>
<span class="sd">        ...                                  80.5, 21.5, 15.0]},</span>
<span class="sd">        ...                   index=index)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                        max_speed</span>
<span class="sd">        name     class</span>
<span class="sd">        falcon   bird        389.0</span>
<span class="sd">        parrot   bird         24.0</span>
<span class="sd">        cockatoo bird         70.0</span>
<span class="sd">        kiwi     bird          NaN</span>
<span class="sd">        lion     mammal       80.5</span>
<span class="sd">        monkey   mammal       21.5</span>
<span class="sd">        rabbit   mammal       15.0</span>
<span class="sd">        &gt;&gt;&gt; gb = df.groupby([&quot;class&quot;])</span>
<span class="sd">        &gt;&gt;&gt; gb.skew()</span>
<span class="sd">                max_speed</span>
<span class="sd">        class</span>
<span class="sd">        bird     1.628296</span>
<span class="sd">        mammal   1.669046</span>
<span class="sd">        &gt;&gt;&gt; gb.skew(skipna=False)</span>
<span class="sd">                max_speed</span>
<span class="sd">        class</span>
<span class="sd">        bird          NaN</span>
<span class="sd">        mammal   1.669046</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;skew&quot;</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GroupByPlot</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">GroupByPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">corr</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;pearson&quot;</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;corr&quot;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">column</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">xlabelsize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">xrot</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ylabelsize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">yrot</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sharex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sharey</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">figsize</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">layout</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;hist&quot;</span><span class="p">,</span>
            <span class="n">column</span><span class="o">=</span><span class="n">column</span><span class="p">,</span>
            <span class="n">by</span><span class="o">=</span><span class="n">by</span><span class="p">,</span>
            <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">xlabelsize</span><span class="o">=</span><span class="n">xlabelsize</span><span class="p">,</span>
            <span class="n">xrot</span><span class="o">=</span><span class="n">xrot</span><span class="p">,</span>
            <span class="n">ylabelsize</span><span class="o">=</span><span class="n">ylabelsize</span><span class="p">,</span>
            <span class="n">yrot</span><span class="o">=</span><span class="n">yrot</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">sharex</span><span class="o">=</span><span class="n">sharex</span><span class="p">,</span>
            <span class="n">sharey</span><span class="o">=</span><span class="n">sharey</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
            <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span>
            <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span>
            <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span>
            <span class="n">legend</span><span class="o">=</span><span class="n">legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="c1"># error: Incompatible return value type (got &quot;DataFrame&quot;, expected &quot;Series&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>  <span class="c1"># type: ignore[return-value]</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">corrwith</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">corrwith</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">CorrelationMethod</span> <span class="o">=</span> <span class="s2">&quot;pearson&quot;</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_via_apply</span><span class="p">(</span>
            <span class="s2">&quot;corrwith&quot;</span><span class="p">,</span>
            <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">drop</span><span class="o">=</span><span class="n">drop</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_wrap_transform_general_frame</span><span class="p">(</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">concat</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
        <span class="c1"># we need to broadcast across the</span>
        <span class="c1"># other dimension; this will preserve dtypes</span>
        <span class="c1"># GH14457</span>
        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">res_frame</span> <span class="o">=</span> <span class="n">concat</span><span class="p">([</span><span class="n">res</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">res_frame</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">columns</span>
            <span class="n">res_frame</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res_frame</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="mi">1</span><span class="p">)),</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res_frame</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res_frame</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span><span class="n">group</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso Furlanello, and Daniel Hug.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>