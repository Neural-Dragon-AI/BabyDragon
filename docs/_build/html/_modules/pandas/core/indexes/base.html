<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pandas.core.indexes.base &mdash; BabyDragon  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            BabyDragon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tasks:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/llm_task.html">llm_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/multi_kernel_task.html">multi_kernel_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/base_task.html">base_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/topic_tree_task.html">topic_tree_task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/embedding_task.html">embedding_task</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Kernels:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/memory_kernel.html">memory_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_clustering.html">kernel_clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel.html">multi_kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel_visualization.html">multi_kernel_visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_utils.html">kernel_utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Threads:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/base_thread.html">base_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/fifo_thread.html">fifo_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/vector_thread.html">vector_thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/todo/python_thread.html">python_thread</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Indexes:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/python_index.html">python_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/memory_index.html">memory_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/pandas_index.html">pandas_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/youtube_index.html">youtube_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/parquet_index.html">parquet_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/wiki_index.html">wiki_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/gutenberg_index.html">gutenberg_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/github_index.html">github_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/todo/multi_index.html">multi_index</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Chat:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/base_chat.html">base_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/memory_chat.html">memory_chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/chat.html">chat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/prompts/perspective_prompt.html">perspective_prompt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/prompts/default_prompts.html">default_prompts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utils:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/multithreading.html">multithreading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/pandas.html">pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/hf_datasets.html">hf_datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/chatml.html">chatml</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/embedders:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/ada2.html">ada2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/sbert.html">sbert</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/generators:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/chatgpt.html">chatgpt</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Processors:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/github_processors.html">github_processors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/os_processor.html">os_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/git_metadata.html">git_metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html">visitors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html">python_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/subs_parser.html">subs_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/latex_parser.html">latex_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/md_parser.html">md_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/wiki_parser.html">wiki_parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/todo/git_processor.html">git_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/arxiv_processor.html">arxiv_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/wiki_processor.html">wiki_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/chatgpt_processor.html">chatgpt_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/mit_course_processor.html">mit_course_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/youtube_processor.html">youtube_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/pubmed_processor.html">pubmed_processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/todo/gutenberg_processor.html">gutenberg_processor</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Apps:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html">perspective</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">BabyDragon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pandas.core.indexes.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pandas.core.indexes.base</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">zip_longest</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">ClassVar</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">NoReturn</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">final</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._config</span> <span class="kn">import</span> <span class="n">get_option</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">NaT</span><span class="p">,</span>
    <span class="n">algos</span> <span class="k">as</span> <span class="n">libalgos</span><span class="p">,</span>
    <span class="n">index</span> <span class="k">as</span> <span class="n">libindex</span><span class="p">,</span>
    <span class="n">lib</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._libs.internals</span> <span class="kn">import</span> <span class="n">BlockValuesRefs</span>
<span class="kn">import</span> <span class="nn">pandas._libs.join</span> <span class="k">as</span> <span class="nn">libjoin</span>
<span class="kn">from</span> <span class="nn">pandas._libs.lib</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">is_datetime_array</span><span class="p">,</span>
    <span class="n">no_default</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._libs.missing</span> <span class="kn">import</span> <span class="n">is_float_nan</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IncompatibleFrequency</span><span class="p">,</span>
    <span class="n">OutOfBoundsDatetime</span><span class="p">,</span>
    <span class="n">Timestamp</span><span class="p">,</span>
    <span class="n">tz_compare</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AnyAll</span><span class="p">,</span>
    <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">Axes</span><span class="p">,</span>
    <span class="n">Axis</span><span class="p">,</span>
    <span class="n">DropKeep</span><span class="p">,</span>
    <span class="n">DtypeObj</span><span class="p">,</span>
    <span class="n">F</span><span class="p">,</span>
    <span class="n">IgnoreRaise</span><span class="p">,</span>
    <span class="n">IndexLabel</span><span class="p">,</span>
    <span class="n">JoinHow</span><span class="p">,</span>
    <span class="n">Level</span><span class="p">,</span>
    <span class="n">Shape</span><span class="p">,</span>
    <span class="n">npt</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="kn">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DuplicateLabelError</span><span class="p">,</span>
    <span class="n">InvalidIndexError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Appender</span><span class="p">,</span>
    <span class="n">cache_readonly</span><span class="p">,</span>
    <span class="n">doc</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">find_stack_level</span><span class="p">,</span>
    <span class="n">rewrite_exception</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.astype</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">astype_array</span><span class="p">,</span>
    <span class="n">astype_is_view</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">LossySetitemError</span><span class="p">,</span>
    <span class="n">can_hold_element</span><span class="p">,</span>
    <span class="n">common_dtype_categorical_compat</span><span class="p">,</span>
    <span class="n">find_result_type</span><span class="p">,</span>
    <span class="n">infer_dtype_from</span><span class="p">,</span>
    <span class="n">maybe_cast_pointwise_result</span><span class="p">,</span>
    <span class="n">np_can_hold_element</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ensure_int64</span><span class="p">,</span>
    <span class="n">ensure_object</span><span class="p">,</span>
    <span class="n">ensure_platform_int</span><span class="p">,</span>
    <span class="n">is_any_real_numeric_dtype</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_categorical_dtype</span><span class="p">,</span>
    <span class="n">is_dtype_equal</span><span class="p">,</span>
    <span class="n">is_ea_or_datetimelike_dtype</span><span class="p">,</span>
    <span class="n">is_extension_array_dtype</span><span class="p">,</span>
    <span class="n">is_float</span><span class="p">,</span>
    <span class="n">is_float_dtype</span><span class="p">,</span>
    <span class="n">is_hashable</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span>
    <span class="n">is_integer_dtype</span><span class="p">,</span>
    <span class="n">is_interval_dtype</span><span class="p">,</span>
    <span class="n">is_iterator</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_numeric_dtype</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">is_signed_integer_dtype</span><span class="p">,</span>
    <span class="n">is_string_dtype</span><span class="p">,</span>
    <span class="n">needs_i8_conversion</span><span class="p">,</span>
    <span class="n">pandas_dtype</span><span class="p">,</span>
    <span class="n">validate_all_hashable</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.concat</span> <span class="kn">import</span> <span class="n">concat_compat</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.dtypes</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CategoricalDtype</span><span class="p">,</span>
    <span class="n">DatetimeTZDtype</span><span class="p">,</span>
    <span class="n">ExtensionDtype</span><span class="p">,</span>
    <span class="n">IntervalDtype</span><span class="p">,</span>
    <span class="n">PeriodDtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ABCDataFrame</span><span class="p">,</span>
    <span class="n">ABCDatetimeIndex</span><span class="p">,</span>
    <span class="n">ABCMultiIndex</span><span class="p">,</span>
    <span class="n">ABCPeriodIndex</span><span class="p">,</span>
    <span class="n">ABCSeries</span><span class="p">,</span>
    <span class="n">ABCTimedeltaIndex</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.inference</span> <span class="kn">import</span> <span class="n">is_dict_like</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">array_equivalent</span><span class="p">,</span>
    <span class="n">is_valid_na_for_dtype</span><span class="p">,</span>
    <span class="n">isna</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">arraylike</span><span class="p">,</span>
    <span class="n">ops</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.accessor</span> <span class="kn">import</span> <span class="n">CachedAccessor</span>
<span class="kn">import</span> <span class="nn">pandas.core.algorithms</span> <span class="k">as</span> <span class="nn">algos</span>
<span class="kn">from</span> <span class="nn">pandas.core.array_algos.putmask</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">setitem_datetimelike_compat</span><span class="p">,</span>
    <span class="n">validate_putmask</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ArrowExtensionArray</span><span class="p">,</span>
    <span class="n">BaseMaskedArray</span><span class="p">,</span>
    <span class="n">Categorical</span><span class="p">,</span>
    <span class="n">ExtensionArray</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.string_</span> <span class="kn">import</span> <span class="n">StringArray</span>
<span class="kn">from</span> <span class="nn">pandas.core.base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IndexOpsMixin</span><span class="p">,</span>
    <span class="n">PandasObject</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">from</span> <span class="nn">pandas.core.construction</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">,</span>
    <span class="n">extract_array</span><span class="p">,</span>
    <span class="n">sanitize_array</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexers</span> <span class="kn">import</span> <span class="n">disallow_ndim_indexing</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.frozen</span> <span class="kn">import</span> <span class="n">FrozenList</span>
<span class="kn">from</span> <span class="nn">pandas.core.missing</span> <span class="kn">import</span> <span class="n">clean_reindex_fill_method</span>
<span class="kn">from</span> <span class="nn">pandas.core.ops</span> <span class="kn">import</span> <span class="n">get_op_result_name</span>
<span class="kn">from</span> <span class="nn">pandas.core.ops.invalid</span> <span class="kn">import</span> <span class="n">make_invalid_op</span>
<span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ensure_key_mapped</span><span class="p">,</span>
    <span class="n">get_group_index_sorter</span><span class="p">,</span>
    <span class="n">nargsort</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.strings.accessor</span> <span class="kn">import</span> <span class="n">StringMethods</span>

<span class="kn">from</span> <span class="nn">pandas.io.formats.printing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">PrettyDict</span><span class="p">,</span>
    <span class="n">default_pprint</span><span class="p">,</span>
    <span class="n">format_object_summary</span><span class="p">,</span>
    <span class="n">pprint_thing</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">CategoricalIndex</span><span class="p">,</span>
        <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">MultiIndex</span><span class="p">,</span>
        <span class="n">Series</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="n">PeriodArray</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">]</span>

<span class="n">_unsortable_types</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">((</span><span class="s2">&quot;mixed&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed-integer&quot;</span><span class="p">))</span>

<span class="n">_index_doc_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">,</span>
    <span class="s2">&quot;inplace&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;target_klass&quot;</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">,</span>
    <span class="s2">&quot;raises_section&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;unique&quot;</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">,</span>
    <span class="s2">&quot;duplicated&quot;</span><span class="p">:</span> <span class="s2">&quot;np.ndarray&quot;</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">_index_shared_docs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">str_t</span> <span class="o">=</span> <span class="nb">str</span>


<span class="n">_dtype_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>

<span class="n">_masked_engines</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;Complex128&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedComplex128Engine</span><span class="p">,</span>
    <span class="s2">&quot;Complex64&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedComplex64Engine</span><span class="p">,</span>
    <span class="s2">&quot;Float64&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedFloat64Engine</span><span class="p">,</span>
    <span class="s2">&quot;Float32&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedFloat32Engine</span><span class="p">,</span>
    <span class="s2">&quot;UInt64&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedUInt64Engine</span><span class="p">,</span>
    <span class="s2">&quot;UInt32&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedUInt32Engine</span><span class="p">,</span>
    <span class="s2">&quot;UInt16&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedUInt16Engine</span><span class="p">,</span>
    <span class="s2">&quot;UInt8&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedUInt8Engine</span><span class="p">,</span>
    <span class="s2">&quot;Int64&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedInt64Engine</span><span class="p">,</span>
    <span class="s2">&quot;Int32&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedInt32Engine</span><span class="p">,</span>
    <span class="s2">&quot;Int16&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedInt16Engine</span><span class="p">,</span>
    <span class="s2">&quot;Int8&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedInt8Engine</span><span class="p">,</span>
    <span class="s2">&quot;boolean&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedBoolEngine</span><span class="p">,</span>
    <span class="s2">&quot;double[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedFloat64Engine</span><span class="p">,</span>
    <span class="s2">&quot;float64[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedFloat64Engine</span><span class="p">,</span>
    <span class="s2">&quot;float32[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedFloat32Engine</span><span class="p">,</span>
    <span class="s2">&quot;float[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedFloat32Engine</span><span class="p">,</span>
    <span class="s2">&quot;uint64[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedUInt64Engine</span><span class="p">,</span>
    <span class="s2">&quot;uint32[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedUInt32Engine</span><span class="p">,</span>
    <span class="s2">&quot;uint16[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedUInt16Engine</span><span class="p">,</span>
    <span class="s2">&quot;uint8[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedUInt8Engine</span><span class="p">,</span>
    <span class="s2">&quot;int64[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedInt64Engine</span><span class="p">,</span>
    <span class="s2">&quot;int32[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedInt32Engine</span><span class="p">,</span>
    <span class="s2">&quot;int16[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedInt16Engine</span><span class="p">,</span>
    <span class="s2">&quot;int8[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedInt8Engine</span><span class="p">,</span>
    <span class="s2">&quot;bool[pyarrow]&quot;</span><span class="p">:</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedBoolEngine</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_maybe_return_indexers</span><span class="p">(</span><span class="n">meth</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">F</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to simplify &#39;return_indexers&#39; checks in Index.join.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">JoinHow</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_indexers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_indexers</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">join_index</span>

        <span class="k">if</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lidx</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">lidx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ridx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ridx</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">ridx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span>

    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">join</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_new_Index</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is called upon unpickling, rather than the default which doesn&#39;t</span>
<span class="sd">    have arguments and breaks __new__.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># required for backward compat, because PI can&#39;t be instantiated with</span>
    <span class="c1"># ordinals through __new__ GH #13277</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCPeriodIndex</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.indexes.period</span> <span class="kn">import</span> <span class="n">_new_PeriodIndex</span>

        <span class="k">return</span> <span class="n">_new_PeriodIndex</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">d</span> <span class="ow">and</span> <span class="s2">&quot;codes&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="c1"># GH#23752 &quot;labels&quot; kwarg has been replaced with &quot;codes&quot;</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;codes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;labels&quot;</span><span class="p">)</span>

        <span class="c1"># Since this was a valid MultiIndex at pickle-time, we don&#39;t need to</span>
        <span class="c1">#  check validty at un-pickle time.</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;verify_integrity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">elif</span> <span class="s2">&quot;dtype&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span> <span class="ow">and</span> <span class="s2">&quot;data&quot;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="c1"># Prevent Index.__new__ from conducting inference;</span>
        <span class="c1">#  &quot;data&quot; key not in RangeIndex</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>


<span class="n">_IndexT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_IndexT&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Index&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Index"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index">[docs]</a><span class="k">class</span> <span class="nc">Index</span><span class="p">(</span><span class="n">IndexOpsMixin</span><span class="p">,</span> <span class="n">PandasObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Immutable sequence used for indexing and alignment.</span>

<span class="sd">    The basic object storing axis labels for all pandas objects.</span>

<span class="sd">    .. versionchanged:: 2.0.0</span>

<span class="sd">       Index can hold all numpy numeric dtypes (except float16). Previously only</span>
<span class="sd">       int64/uint64/float64 dtypes were accepted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like (1-dimensional)</span>
<span class="sd">    dtype : NumPy dtype (default: object)</span>
<span class="sd">        If dtype is None, we find the dtype that best fits the data.</span>
<span class="sd">        If an actual dtype is provided, we coerce to that dtype if it&#39;s safe.</span>
<span class="sd">        Otherwise, an error will be raised.</span>
<span class="sd">    copy : bool</span>
<span class="sd">        Make a copy of input ndarray.</span>
<span class="sd">    name : object</span>
<span class="sd">        Name to be stored in the index.</span>
<span class="sd">    tupleize_cols : bool (default: True)</span>
<span class="sd">        When True, attempt to create a MultiIndex if possible.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    RangeIndex : Index implementing a monotonic integer range.</span>
<span class="sd">    CategoricalIndex : Index of :class:`Categorical` s.</span>
<span class="sd">    MultiIndex : A multi-level, or hierarchical Index.</span>
<span class="sd">    IntervalIndex : An Index of :class:`Interval` s.</span>
<span class="sd">    DatetimeIndex : Index of datetime64 data.</span>
<span class="sd">    TimedeltaIndex : Index of timedelta64 data.</span>
<span class="sd">    PeriodIndex : Index of Period data.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    An Index instance can **only** contain hashable objects.</span>
<span class="sd">    An Index instance *can not* hold numpy float16 dtype.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; pd.Index([1, 2, 3])</span>
<span class="sd">    Index([1, 2, 3], dtype=&#39;int64&#39;)</span>

<span class="sd">    &gt;&gt;&gt; pd.Index(list(&#39;abc&#39;))</span>
<span class="sd">    Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">    &gt;&gt;&gt; pd.Index([1, 2, 3], dtype=&quot;uint8&quot;)</span>
<span class="sd">    Index([1, 2, 3], dtype=&#39;uint8&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># To hand over control to subclasses</span>
    <span class="n">_join_precedence</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Cython methods; see github.com/cython/cython/issues/2647</span>
    <span class="c1">#  for why we need to wrap these instead of making them class attributes</span>
    <span class="c1"># Moreover, cython will choose the appropriate-dtyped sub-function</span>
    <span class="c1">#  given the dtypes of the passed arguments</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_left_indexer_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
        <span class="c1"># Caller is responsible for ensuring other.dtype == self.dtype</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_join_target</span><span class="p">()</span>
        <span class="n">ov</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_join_target</span><span class="p">()</span>
        <span class="c1"># can_use_libjoin assures sv and ov are ndarrays</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sv</span><span class="p">)</span>
        <span class="n">ov</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
        <span class="c1"># similar but not identical to ov.searchsorted(sv)</span>
        <span class="k">return</span> <span class="n">libjoin</span><span class="o">.</span><span class="n">left_join_indexer_unique</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_left_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">_IndexT</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]]:</span>
        <span class="c1"># Caller is responsible for ensuring other.dtype == self.dtype</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_join_target</span><span class="p">()</span>
        <span class="n">ov</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_join_target</span><span class="p">()</span>
        <span class="c1"># can_use_libjoin assures sv and ov are ndarrays</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sv</span><span class="p">)</span>
        <span class="n">ov</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
        <span class="n">joined_ndarray</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">libjoin</span><span class="o">.</span><span class="n">left_join_indexer</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
        <span class="n">joined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_join_target</span><span class="p">(</span><span class="n">joined_ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">joined</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_inner_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">_IndexT</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]]:</span>
        <span class="c1"># Caller is responsible for ensuring other.dtype == self.dtype</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_join_target</span><span class="p">()</span>
        <span class="n">ov</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_join_target</span><span class="p">()</span>
        <span class="c1"># can_use_libjoin assures sv and ov are ndarrays</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sv</span><span class="p">)</span>
        <span class="n">ov</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
        <span class="n">joined_ndarray</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">libjoin</span><span class="o">.</span><span class="n">inner_join_indexer</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
        <span class="n">joined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_join_target</span><span class="p">(</span><span class="n">joined_ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">joined</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_outer_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">_IndexT</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]]:</span>
        <span class="c1"># Caller is responsible for ensuring other.dtype == self.dtype</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_join_target</span><span class="p">()</span>
        <span class="n">ov</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_join_target</span><span class="p">()</span>
        <span class="c1"># can_use_libjoin assures sv and ov are ndarrays</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sv</span><span class="p">)</span>
        <span class="n">ov</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
        <span class="n">joined_ndarray</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">libjoin</span><span class="o">.</span><span class="n">outer_join_indexer</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
        <span class="n">joined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_join_target</span><span class="p">(</span><span class="n">joined_ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">joined</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span>

    <span class="n">_typ</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;index&quot;</span>
    <span class="n">_data</span><span class="p">:</span> <span class="n">ExtensionArray</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">_data_cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">ExtensionArray</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">type</span><span class="p">[</span><span class="n">ExtensionArray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">ExtensionArray</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">_id</span><span class="p">:</span> <span class="nb">object</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># MultiIndex.levels previously allowed setting the index name. We</span>
    <span class="c1"># don&#39;t allow this anymore, and raise if it happens rather than</span>
    <span class="c1"># failing silently.</span>
    <span class="n">_no_setting_name</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_comparables</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
    <span class="n">_attributes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_can_hold_strings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_engine_types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span> <span class="o">|</span> <span class="n">ExtensionDtype</span><span class="p">,</span> <span class="nb">type</span><span class="p">[</span><span class="n">libindex</span><span class="o">.</span><span class="n">IndexEngine</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">Int8Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">Int16Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">Int32Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">Int64Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">UInt8Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">UInt16Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">UInt32Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">UInt64Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">Float32Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">Float64Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">Complex64Engine</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">):</span> <span class="n">libindex</span><span class="o">.</span><span class="n">Complex128Engine</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_engine_type</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">[</span><span class="n">libindex</span><span class="o">.</span><span class="n">IndexEngine</span><span class="p">]</span> <span class="o">|</span> <span class="nb">type</span><span class="p">[</span><span class="n">libindex</span><span class="o">.</span><span class="n">ExtensionEngine</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine_types</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">libindex</span><span class="o">.</span><span class="n">ObjectEngine</span><span class="p">)</span>

    <span class="c1"># whether we support partial string indexing. Overridden</span>
    <span class="c1"># in DatetimeIndex and PeriodIndex</span>
    <span class="n">_supports_partial_string_indexing</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_accessors</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;str&quot;</span><span class="p">}</span>

    <span class="nb">str</span> <span class="o">=</span> <span class="n">CachedAccessor</span><span class="p">(</span><span class="s2">&quot;str&quot;</span><span class="p">,</span> <span class="n">StringMethods</span><span class="p">)</span>

    <span class="n">_references</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Constructors</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tupleize_cols</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.indexes.range</span> <span class="kn">import</span> <span class="n">RangeIndex</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">maybe_extract_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">data_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">refs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
            <span class="n">refs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_references</span>

        <span class="c1"># range</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">RangeIndex</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">RangeIndex</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">elif</span> <span class="n">is_ea_or_datetimelike_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># non-EA dtype indexes have special casting logic, so we punt here</span>
            <span class="k">pass</span>

        <span class="k">elif</span> <span class="n">is_ea_or_datetimelike_dtype</span><span class="p">(</span><span class="n">data_dtype</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_values</span>

            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">]:</span>
                <span class="c1"># GH#11836 we need to avoid having numpy coerce</span>
                <span class="c1"># things that look like ints/floats to ints unless</span>
                <span class="c1"># they are actually ints, e.g. &#39;0&#39; and 0.0</span>
                <span class="c1"># should not be coerced</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">asarray_tuplesafe</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_dtype_obj</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_raise_scalar_data_error</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;__array__&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">):</span>
            <span class="c1"># 2022-11-16 the memoryview check is only necessary on some CI</span>
            <span class="c1">#  builds, not clear why</span>
            <span class="k">raise</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_raise_scalar_data_error</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tupleize_cols</span><span class="p">:</span>
                <span class="c1"># GH21470: convert iterable to list before determining if empty</span>
                <span class="k">if</span> <span class="n">is_iterator</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">data</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">data</span><span class="p">):</span>
                    <span class="c1"># we must be all tuples, otherwise don&#39;t construct</span>
                    <span class="c1"># 10697</span>
                    <span class="kn">from</span> <span class="nn">pandas.core.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

                    <span class="k">return</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># other iterable of some kind</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="c1"># we allow set/frozenset, which Series/sanitize_array does not, so</span>
                <span class="c1">#  cast to list here</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># unlike Series, we default to object dtype:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># Ensure we get 1-D array of tuples instead of 2D array.</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">asarray_tuplesafe</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_dtype_obj</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">sanitize_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;index must be specified when data is not list-like&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">):</span>
                <span class="k">raise</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_raise_scalar_data_error</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
            <span class="k">if</span> <span class="s2">&quot;Data must be 1-dimensional&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index data must be 1-dimensional&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
            <span class="k">raise</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

        <span class="n">klass</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_dtype_to_subclass</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="n">klass</span><span class="o">.</span><span class="n">_ensure_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">klass</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">refs</span><span class="o">=</span><span class="n">refs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_ensure_array</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure we have a valid array to pass to _simple_new.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># GH#13601, GH#20285, GH#27125</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index data must be 1-dimensional&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">:</span>
            <span class="c1"># float16 not supported (no indexing engine)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;float16 indexes are not supported&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="c1"># asarray_tuplesafe does not always copy underlying data,</span>
            <span class="c1">#  so need to make sure that this happens</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@final</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_dtype_to_subclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeObj</span><span class="p">):</span>
        <span class="c1"># Delay import for perf. https://github.com/pandas-dev/pandas/pull/31423</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ExtensionDtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">DatetimeTZDtype</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DatetimeIndex</span>

                <span class="k">return</span> <span class="n">DatetimeIndex</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">CategoricalDtype</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">CategoricalIndex</span>

                <span class="k">return</span> <span class="n">CategoricalIndex</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">IntervalDtype</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">IntervalIndex</span>

                <span class="k">return</span> <span class="n">IntervalIndex</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">PeriodDtype</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">PeriodIndex</span>

                <span class="k">return</span> <span class="n">PeriodIndex</span>

            <span class="k">return</span> <span class="n">Index</span>

        <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DatetimeIndex</span>

            <span class="k">return</span> <span class="n">DatetimeIndex</span>

        <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">TimedeltaIndex</span>

            <span class="k">return</span> <span class="n">TimedeltaIndex</span>

        <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span><span class="p">:</span>
            <span class="c1"># NB: assuming away MultiIndex</span>
            <span class="k">return</span> <span class="n">Index</span>

        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Index</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># NOTE for new Index creation:</span>

    <span class="c1"># - _simple_new: It returns new Index with the same type as the caller.</span>
    <span class="c1">#   All metadata (such as name) must be provided by caller&#39;s responsibility.</span>
    <span class="c1">#   Using _shallow_copy is recommended because it fills these metadata</span>
    <span class="c1">#   otherwise specified.</span>

    <span class="c1"># - _shallow_copy: It returns new Index with the same type (using</span>
    <span class="c1">#   _simple_new), but fills caller&#39;s metadata otherwise specified. Passed</span>
    <span class="c1">#   kwargs will overwrite corresponding metadata.</span>

    <span class="c1"># See each method&#39;s docstring.</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_simple_new</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">_IndexT</span><span class="p">],</span> <span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">refs</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We require that we have a dtype compat for the values. If we are passed</span>
<span class="sd">        a non-dtype compat, then coerce using the constructor.</span>

<span class="sd">        Must be careful not to recurse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_data_cls</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">values</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_reset_identity</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">refs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_references</span> <span class="o">=</span> <span class="n">refs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_references</span> <span class="o">=</span> <span class="n">BlockValuesRefs</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_references</span><span class="o">.</span><span class="n">add_index_reference</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_with_infer</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor that uses the 1.0.x behavior inferring numeric dtypes</span>
<span class="sd">        for ndarray[object] inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">_dtype_obj</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="c1"># error: Argument 1 to &quot;maybe_convert_objects&quot; has incompatible type</span>
            <span class="c1"># &quot;Union[ExtensionArray, ndarray[Any, Any]]&quot;; expected</span>
            <span class="c1"># &quot;ndarray[Any, Any]&quot;</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">[</span><span class="n">_IndexT</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_maybe_check_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that an Index has no duplicates.</span>

<span class="sd">        This is typically only called via</span>
<span class="sd">        `NDFrame.flags.allows_duplicate_labels.setter` when it&#39;s set to</span>
<span class="sd">        True (duplicates aren&#39;t allowed).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        DuplicateLabelError</span>
<span class="sd">            When the index is not unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Index has duplicates.&quot;&quot;&quot;</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_duplicate_message</span><span class="p">()</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">duplicates</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="k">raise</span> <span class="n">DuplicateLabelError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_format_duplicate_message</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the DataFrame for a DuplicateLabelError.</span>

<span class="sd">        This returns a DataFrame indicating the labels and positions</span>
<span class="sd">        of duplicates in an index. This should only be called when it&#39;s</span>
<span class="sd">        already known that duplicates are present.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;a&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx._format_duplicate_message()</span>
<span class="sd">            positions</span>
<span class="sd">        label</span>
<span class="sd">        a        [0, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

        <span class="n">duplicates</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicates</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="nb">list</span><span class="p">)[</span><span class="n">duplicates</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="c1"># test_format_duplicate_labels_message_multi</span>
            <span class="c1"># error: &quot;Type[Index]&quot; has no attribute &quot;from_tuples&quot;  [attr-defined]</span>
            <span class="n">out</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;positions&quot;</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Index Internals Methods</span>

    <span class="k">def</span> <span class="nf">_shallow_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="n">no_default</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Index with the same class as the caller, don&#39;t copy the</span>
<span class="sd">        data, use the same object attributes with passed in attributes taking</span>
<span class="sd">        precedence.</span>

<span class="sd">        *this is an internal non-public method*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : the values to create the new Index, optional</span>
<span class="sd">        name : Label, defaults to self.name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">no_default</span> <span class="k">else</span> <span class="n">name</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">refs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_references</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_view</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        fastpath to make a shallow copy, i.e. new object with same data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">refs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_references</span><span class="p">)</span>

        <span class="n">result</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_rename</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        fastpath for rename if new name is already validated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Index.is_"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.is_">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">is_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        More flexible, faster check like ``is`` but that works through views.</span>

<span class="sd">        Note: this is *not* the same as ``Index.identical()``, which checks</span>
<span class="sd">        that metadata is also the same.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : object</span>
<span class="sd">            Other object to compare against.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if both have same underlying data, False otherwise.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.identical : Works like ``Index.is_`` but also checks metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;_id&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">_id</span></div>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_reset_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes or resets ``_id`` attribute with new object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">clear_mapping</span><span class="p">()</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_engine</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">libindex</span><span class="o">.</span><span class="n">IndexEngine</span> <span class="o">|</span> <span class="n">libindex</span><span class="o">.</span><span class="n">ExtensionEngine</span> <span class="o">|</span> <span class="n">libindex</span><span class="o">.</span><span class="n">MaskedIndexEngine</span><span class="p">:</span>
        <span class="c1"># For base class (object dtype) we get ObjectEngine</span>
        <span class="n">target_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_engine_target</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_values</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_values</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseMaskedArray</span><span class="p">,</span> <span class="n">ArrowExtensionArray</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_masked_engines</span><span class="p">[</span><span class="n">target_values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">](</span><span class="n">target_values</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># Not supported yet e.g. decimal</span>
                    <span class="k">pass</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine_type</span> <span class="ow">is</span> <span class="n">libindex</span><span class="o">.</span><span class="n">ObjectEngine</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">libindex</span><span class="o">.</span><span class="n">ExtensionEngine</span><span class="p">(</span><span class="n">target_values</span><span class="p">)</span>

        <span class="n">target_values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">target_values</span><span class="p">)</span>
        <span class="c1"># to avoid a reference cycle, bind `target_values` to a local variable, so</span>
        <span class="c1"># `self` is not passed into the lambda.</span>
        <span class="k">if</span> <span class="n">target_values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">libindex</span><span class="o">.</span><span class="n">BoolEngine</span><span class="p">(</span><span class="n">target_values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">target_values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">libindex</span><span class="o">.</span><span class="n">Complex64Engine</span><span class="p">(</span><span class="n">target_values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">target_values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">libindex</span><span class="o">.</span><span class="n">Complex128Engine</span><span class="p">(</span><span class="n">target_values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># We need to keep M8/m8 dtype when initializing the Engine,</span>
            <span class="c1">#  but don&#39;t want to change _get_engine_target bc it is used</span>
            <span class="c1">#  elsewhere</span>
            <span class="c1"># error: Item &quot;ExtensionArray&quot; of &quot;Union[ExtensionArray,</span>
            <span class="c1"># ndarray[Any, Any]]&quot; has no attribute &quot;_ndarray&quot;  [union-attr]</span>
            <span class="n">target_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_ndarray</span>  <span class="c1"># type: ignore[union-attr]</span>

        <span class="c1"># error: Argument 1 to &quot;ExtensionEngine&quot; has incompatible type</span>
        <span class="c1"># &quot;ndarray[Any, Any]&quot;; expected &quot;ExtensionArray&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine_type</span><span class="p">(</span><span class="n">target_values</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

    <span class="nd">@final</span>
    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_dir_additions_for_owner</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">str_t</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the string-like labels to the owner dataframe/series dir output.</span>

<span class="sd">        If this is a MultiIndex, it&#39;s first level values are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">c</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_dir_items&quot;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Array-Like Methods</span>

    <span class="c1"># ndarray compat</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the length of the Index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The array interface, return my values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="n">str_t</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">))</span> <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">arraylike</span><span class="o">.</span><span class="n">maybe_dispatch_ufunc_to_dunder_op</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="s2">&quot;out&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># e.g. test_dti_isub_tdi</span>
            <span class="k">return</span> <span class="n">arraylike</span><span class="o">.</span><span class="n">dispatch_ufunc_with_out</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;reduce&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">arraylike</span><span class="o">.</span><span class="n">dispatch_reduction_ufunc</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>

        <span class="n">new_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">_values</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">new_inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># i.e. np.divmod, np.modf, np.frexp</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called after a ufunc and other functions e.g. np.split.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">item_from_zerodim</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">or</span> <span class="n">lib</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DtypeObj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dtype object of the underlying data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span>

<div class="viewcode-block" id="Index.ravel"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.ravel">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="n">str_t</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a view on self.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.ravel : Return a flattened array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[:]</span></div>

    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># we need to see if we are subclassing an</span>
        <span class="c1"># index type here</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_typ&quot;</span><span class="p">):</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">cls</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ExtensionDtype</span><span class="p">))</span> <span class="ow">and</span> <span class="n">needs_i8_conversion</span><span class="p">(</span>
                <span class="n">dtype</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;m8[ns]&quot;</span><span class="p">:</span>
                    <span class="c1"># e.g. m8[s]</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

                <span class="n">idx_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype_to_subclass</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="c1"># NB: we only get here for subclasses that override</span>
                <span class="c1">#  _data_cls such that it is a type and not a tuple</span>
                <span class="c1">#  of types.</span>
                <span class="n">arr_cls</span> <span class="o">=</span> <span class="n">idx_cls</span><span class="o">.</span><span class="n">_data_cls</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">arr_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">idx_cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">refs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_references</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Index.astype"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an Index with values cast to dtypes.</span>

<span class="sd">        The class of a new Index is determined by dtype. When conversion is</span>
<span class="sd">        impossible, a TypeError exception is raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy dtype or pandas type</span>
<span class="sd">            Note that any signed integer `dtype` is treated as ``&#39;int64&#39;``,</span>
<span class="sd">            and any unsigned integer `dtype` is treated as ``&#39;uint64&#39;``,</span>
<span class="sd">            regardless of the size.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            By default, astype always returns a newly allocated object.</span>
<span class="sd">            If copy is set to False and internal requirements on dtype are</span>
<span class="sd">            satisfied, the original data is used to create a new Index</span>
<span class="sd">            or the original Index is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">            Index with values cast to specified dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># Ensure that self.astype(self.dtype) is self</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">rewrite_exception</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">):</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ExtensionDtype</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">construct_array_type</span><span class="p">()</span>
            <span class="c1"># Note: for RangeIndex and CategoricalDtype self vs self._values</span>
            <span class="c1">#  behaves differently here.</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># GH#13149 specifically use astype_array instead of astype</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">astype_array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="c1"># pass copy=False because any copying will be done in the astype above</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">copy</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_references</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">astype_is_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_references</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_references</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_references</span><span class="o">.</span><span class="n">add_index_reference</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="n">_index_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;take&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return a new </span><span class="si">%(klass)s</span><span class="s2"> of the values selected by the indices.</span>

<span class="s2">        For internal compatibility with numpy arrays.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        indices : array-like</span>
<span class="s2">            Indices to be taken.</span>
<span class="s2">        axis : int, optional</span>
<span class="s2">            The axis over which to select values, always 0.</span>
<span class="s2">        allow_fill : bool, default True</span>
<span class="s2">        fill_value : scalar, default None</span>
<span class="s2">            If allow_fill=True and fill_value is not None, indices specified by</span>
<span class="s2">            -1 are regarded as NA. If Index doesn&#39;t hold NA, raise ValueError.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        Index</span>
<span class="s2">            An index formed of elements at the given indices. Will be the same</span>
<span class="s2">            type as self, except for RangeIndex.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        numpy.ndarray.take: Return an array formed from the</span>
<span class="s2">            elements of a at the given indices.</span>
<span class="s2">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Index.take"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.take">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s2">&quot;take&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_index_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">allow_fill</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_take</span><span class="p">((),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected indices to be array-like&quot;</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">allow_fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_disallow_fill</span><span class="p">(</span><span class="n">allow_fill</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

        <span class="c1"># Note: we discard fill_value and use self._na_value, only relevant</span>
        <span class="c1">#  in the case where allow_fill is True and fill_value is not None</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">taken</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">allow_fill</span><span class="o">=</span><span class="n">allow_fill</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># algos.take passes &#39;axis&#39; keyword which not all EAs accept</span>
            <span class="n">taken</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">allow_fill</span><span class="o">=</span><span class="n">allow_fill</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>
            <span class="p">)</span>
        <span class="c1"># _constructor so RangeIndex-&gt; Index with an int64 dtype</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">taken</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_maybe_disallow_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_fill</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We only use pandas-style take when allow_fill is True _and_</span>
<span class="sd">        fill_value is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">allow_fill</span> <span class="ow">and</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># only fill if we are passing a non-None fill_value</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_hold_na</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;When allow_fill=True and fill_value is not None, &quot;</span>
                        <span class="s2">&quot;all indices must be &gt;= -1&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cls_name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to fill values because </span><span class="si">{</span><span class="n">cls_name</span><span class="si">}</span><span class="s2"> cannot contain NA&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allow_fill</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">allow_fill</span>

    <span class="n">_index_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;repeat&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Repeat elements of a </span><span class="si">%(klass)s</span><span class="s2">.</span>

<span class="s2">        Returns a new </span><span class="si">%(klass)s</span><span class="s2"> where each element of the current </span><span class="si">%(klass)s</span>
<span class="s2">        is repeated consecutively a given number of times.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        repeats : int or array of ints</span>
<span class="s2">            The number of repetitions for each element. This should be a</span>
<span class="s2">            non-negative integer. Repeating 0 times will return an empty</span>
<span class="s2">            </span><span class="si">%(klass)s</span><span class="s2">.</span>
<span class="s2">        axis : None</span>
<span class="s2">            Must be ``None``. Has no effect but is accepted for compatibility</span>
<span class="s2">            with numpy.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        </span><span class="si">%(klass)s</span>
<span class="s2">            Newly created </span><span class="si">%(klass)s</span><span class="s2"> with repeated elements.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        Series.repeat : Equivalent function for Series.</span>
<span class="s2">        numpy.repeat : Similar method for :class:`numpy.ndarray`.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; idx = pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="s2">        &gt;&gt;&gt; idx</span>
<span class="s2">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>
<span class="s2">        &gt;&gt;&gt; idx.repeat(2)</span>
<span class="s2">        Index([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>
<span class="s2">        &gt;&gt;&gt; idx.repeat([1, 2, 3])</span>
<span class="s2">        Index([&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>
<span class="s2">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Index.repeat"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.repeat">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s2">&quot;repeat&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_index_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">repeats</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_repeat</span><span class="p">((),</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="n">axis</span><span class="p">})</span>
        <span class="n">res_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>

        <span class="c1"># _constructor so RangeIndex-&gt; Index with an int64 dtype</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Copying Methods</span>

<div class="viewcode-block" id="Index.copy"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this object.</span>

<span class="sd">        Name is set on the new object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : Label, optional</span>
<span class="sd">            Set name for new object.</span>
<span class="sd">        deep : bool, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">            Index refer to new object which is a copy of this object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In most cases, there should be no functional difference from using</span>
<span class="sd">        ``deep``, but if ``deep`` is passed it will attempt to deepcopy.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_names</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_index</span></div>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        memo, default None</span>
<span class="sd">            Standard signature. Unused</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Rendering Methods</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">str_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">klass_name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_data</span><span class="p">()</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_attrs</span><span class="p">()</span>
        <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_space</span><span class="p">()</span>
        <span class="n">attrs_str</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">]</span>
        <span class="n">prepr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;,</span><span class="si">{</span><span class="n">space</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attrs_str</span><span class="p">)</span>

        <span class="c1"># no data provided, just attributes</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">klass_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">data</span><span class="si">}{</span><span class="n">prepr</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="nf">_format_space</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">str_t</span><span class="p">:</span>
        <span class="c1"># using space here controls if the attributes</span>
        <span class="c1"># are line separated or not (the default)</span>

        <span class="c1"># max_seq_items = get_option(&#39;display.max_seq_items&#39;)</span>
        <span class="c1"># if len(self) &gt; max_seq_items:</span>
        <span class="c1">#    space = &quot;\n%s&quot; % (&#39; &#39; * (len(klass) + 1))</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_formatter_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the formatter function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">default_pprint</span>

    <span class="k">def</span> <span class="nf">_format_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">str_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the formatted data as a unicode string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do we want to justify (only do so for non-objects)</span>
        <span class="n">is_justify</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
            <span class="n">is_justify</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s2">&quot;categorical&quot;</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;CategoricalIndex&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">categories</span><span class="p">):</span>
                <span class="n">is_justify</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">format_object_summary</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_formatter_func</span><span class="p">,</span>
            <span class="n">is_justify</span><span class="o">=</span><span class="n">is_justify</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">line_break_each_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">str_t</span><span class="p">,</span> <span class="n">str_t</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of tuples of the (attr,formatted_value).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">str_t</span><span class="p">,</span> <span class="n">str_t</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">default_pprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;names&quot;</span><span class="p">,</span> <span class="n">default_pprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)))</span>

        <span class="n">max_seq_items</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_seq_items&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_seq_items</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">attrs</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_level_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a name or list of names with None replaced by the level number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">level</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span> <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_mpl_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># how to represent ourselves to matplotlib</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span>

<div class="viewcode-block" id="Index.format"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.format">[docs]</a>    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">formatter</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="n">str_t</span> <span class="o">=</span> <span class="s2">&quot;NaN&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">str_t</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a string representation of the Index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">pprint_thing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">escape_chars</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">formatter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">header</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">formatter</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_with_header</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_format_with_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">str_t</span><span class="p">],</span> <span class="n">na_rep</span><span class="p">:</span> <span class="n">str_t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">str_t</span><span class="p">]:</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.format</span> <span class="kn">import</span> <span class="n">format_array</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>

        <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">safe</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">escape_chars</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

            <span class="c1"># could have nans</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">is_float_nan</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">result_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">result_arr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">na_rep</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result_arr</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">trim_front</span><span class="p">(</span><span class="n">format_array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">justify</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">header</span> <span class="o">+</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_format_native_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="n">str_t</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="n">str_t</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">date_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">quoting</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Actually format specific types of the index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.format</span> <span class="kn">import</span> <span class="n">FloatArrayFormatter</span>

        <span class="k">if</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">FloatArrayFormatter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
                <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
                <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
                <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">,</span>
                <span class="n">quoting</span><span class="o">=</span><span class="n">quoting</span><span class="p">,</span>
                <span class="n">fixed_width</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">formatter</span><span class="o">.</span><span class="n">get_result_as_array</span><span class="p">()</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">quoting</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">na_rep</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">str_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a summarized representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            name to use in the summary representation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        String with a summarized representation of the index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># e.g. Timedelta, display as values, not quoted</span>
                <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formatter_func</span><span class="p">(</span><span class="n">head</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># e.g. Timedelta, display as values, not quoted</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formatter_func</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="n">index_summary</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;, </span><span class="si">{</span><span class="n">head</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">tail</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_summary</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> entries</span><span class="si">{</span><span class="n">index_summary</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Conversion Methods</span>

<div class="viewcode-block" id="Index.to_flat_index"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.to_flat_index">[docs]</a>    <span class="k">def</span> <span class="nf">to_flat_index</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identity method.</span>

<span class="sd">        This is implemented for compatibility with subclass implementations</span>
<span class="sd">        when chaining.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.Index</span>
<span class="sd">            Caller.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MultiIndex.to_flat_index : Subclass implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Index.to_series"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.to_series">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Series with both index and values equal to the index keys.</span>

<span class="sd">        Useful with map for returning an indexer based on an index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : Index, optional</span>
<span class="sd">            Index of resulting Series. If None, defaults to original index.</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            Name of resulting Series. If None, defaults to name of original</span>
<span class="sd">            index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            The dtype will be based on the type of the Index values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.to_frame : Convert an Index to a DataFrame.</span>
<span class="sd">        Series.to_frame : Convert Series to DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;Ant&#39;, &#39;Bear&#39;, &#39;Cow&#39;], name=&#39;animal&#39;)</span>

<span class="sd">        By default, the original Index and original name is reused.</span>

<span class="sd">        &gt;&gt;&gt; idx.to_series()</span>
<span class="sd">        animal</span>
<span class="sd">        Ant      Ant</span>
<span class="sd">        Bear    Bear</span>
<span class="sd">        Cow      Cow</span>
<span class="sd">        Name: animal, dtype: object</span>

<span class="sd">        To enforce a new Index, specify new labels to ``index``:</span>

<span class="sd">        &gt;&gt;&gt; idx.to_series(index=[0, 1, 2])</span>
<span class="sd">        0     Ant</span>
<span class="sd">        1    Bear</span>
<span class="sd">        2     Cow</span>
<span class="sd">        Name: animal, dtype: object</span>

<span class="sd">        To override the name of the resulting column, specify `name`:</span>

<span class="sd">        &gt;&gt;&gt; idx.to_series(name=&#39;zoo&#39;)</span>
<span class="sd">        animal</span>
<span class="sd">        Ant      Ant</span>
<span class="sd">        Bear    Bear</span>
<span class="sd">        Cow      Cow</span>
<span class="sd">        Name: zoo, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.to_frame"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.to_frame">[docs]</a>    <span class="k">def</span> <span class="nf">to_frame</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a DataFrame with a column containing the Index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Set the index of the returned DataFrame as the original Index.</span>

<span class="sd">        name : object, defaults to index.name</span>
<span class="sd">            The passed name should substitute for the index name (if it has</span>
<span class="sd">            one).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            DataFrame containing the original Index data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.to_series : Convert an Index to a Series.</span>
<span class="sd">        Series.to_frame : Convert Series to DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;Ant&#39;, &#39;Bear&#39;, &#39;Cow&#39;], name=&#39;animal&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.to_frame()</span>
<span class="sd">               animal</span>
<span class="sd">        animal</span>
<span class="sd">        Ant       Ant</span>
<span class="sd">        Bear     Bear</span>
<span class="sd">        Cow       Cow</span>

<span class="sd">        By default, the original Index is reused. To enforce a new Index:</span>

<span class="sd">        &gt;&gt;&gt; idx.to_frame(index=False)</span>
<span class="sd">            animal</span>
<span class="sd">        0   Ant</span>
<span class="sd">        1  Bear</span>
<span class="sd">        2   Cow</span>

<span class="sd">        To override the name of the resulting column, specify `name`:</span>

<span class="sd">        &gt;&gt;&gt; idx.to_frame(index=False, name=&#39;zoo&#39;)</span>
<span class="sd">            zoo</span>
<span class="sd">        0   Ant</span>
<span class="sd">        1  Bear</span>
<span class="sd">        2   Cow</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_level_names</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()})</span>

        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Name-Centric Methods</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hashable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Index or MultiIndex name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_setting_name</span><span class="p">:</span>
            <span class="c1"># Used in MultiIndex.levels to avoid silently ignoring name updates.</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set name on a level of a MultiIndex. Use &quot;</span>
                <span class="s2">&quot;&#39;MultiIndex.set_names&#39; instead.&quot;</span>
            <span class="p">)</span>
        <span class="n">maybe_extract_name</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_validate_names</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles the quirks of having a singular &#39;name&#39; parameter for general</span>
<span class="sd">        Index and plural &#39;names&#39; parameter for MultiIndex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only provide one of `names` and `name`&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_names</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="k">if</span> <span class="n">deep</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>
        <span class="k">elif</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must pass list-like as `names`.&quot;</span><span class="p">)</span>
            <span class="n">new_names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="n">new_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_names</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Length of new names must be </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># All items in &#39;new_names&#39; need to be hashable</span>
        <span class="n">validate_all_hashable</span><span class="p">(</span><span class="o">*</span><span class="n">new_names</span><span class="p">,</span> <span class="n">error_name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.name&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_names</span>

    <span class="k">def</span> <span class="nf">_get_default_index_names</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get names of index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : int, str or 1-dimensional list, default None</span>
<span class="sd">            Index names to set.</span>
<span class="sd">        default : str</span>
<span class="sd">            Default name of index.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            if names not str or list-like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index names must be str or 1-dimensional list&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">fill_missing_names</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">default</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">names</span>

    <span class="k">def</span> <span class="nf">_get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrozenList</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FrozenList</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">_set_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set new names on index. Each name has to be a hashable type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : str or sequence</span>
<span class="sd">            name(s) to set</span>
<span class="sd">        level : int, level name, or sequence of int/level names (default None)</span>
<span class="sd">            If the index is a MultiIndex (hierarchical), level(s) to set (None</span>
<span class="sd">            for all levels).  Otherwise level must be None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError if each name is not hashable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Names must be a list-like&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length of new names must be 1, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># GH 20527</span>
        <span class="c1"># All items in &#39;name&#39; need to be hashable:</span>
        <span class="n">validate_all_hashable</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">,</span> <span class="n">error_name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.name&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">names</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fset</span><span class="o">=</span><span class="n">_set_names</span><span class="p">,</span> <span class="n">fget</span><span class="o">=</span><span class="n">_get_names</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">set_names</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">level</span><span class="o">=...</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">set_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">level</span><span class="o">=...</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">set_names</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">level</span><span class="o">=...</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<div class="viewcode-block" id="Index.set_names"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.set_names">[docs]</a>    <span class="k">def</span> <span class="nf">set_names</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set Index or MultiIndex name.</span>

<span class="sd">        Able to set new names partially and by level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        names : label or list of label or dict-like for MultiIndex</span>
<span class="sd">            Name(s) to set.</span>

<span class="sd">            .. versionchanged:: 1.3.0</span>

<span class="sd">        level : int, label or list of int or label, optional</span>
<span class="sd">            If the index is a MultiIndex and names is not dict-like, level(s) to set</span>
<span class="sd">            (None for all levels). Otherwise level must be None.</span>

<span class="sd">            .. versionchanged:: 1.3.0</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Modifies the object directly, instead of creating a new Index or</span>
<span class="sd">            MultiIndex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index or None</span>
<span class="sd">            The same type as the caller or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.rename : Able to set new names without level.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([1, 2, 3, 4], dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.set_names(&#39;quarter&#39;)</span>
<span class="sd">        Index([1, 2, 3, 4], dtype=&#39;int64&#39;, name=&#39;quarter&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.MultiIndex.from_product([[&#39;python&#39;, &#39;cobra&#39;],</span>
<span class="sd">        ...                                   [2018, 2019]])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        MultiIndex([(&#39;python&#39;, 2018),</span>
<span class="sd">                    (&#39;python&#39;, 2019),</span>
<span class="sd">                    ( &#39;cobra&#39;, 2018),</span>
<span class="sd">                    ( &#39;cobra&#39;, 2019)],</span>
<span class="sd">                   )</span>
<span class="sd">        &gt;&gt;&gt; idx = idx.set_names([&#39;kind&#39;, &#39;year&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.set_names(&#39;species&#39;, level=0)</span>
<span class="sd">        MultiIndex([(&#39;python&#39;, 2018),</span>
<span class="sd">                    (&#39;python&#39;, 2019),</span>
<span class="sd">                    ( &#39;cobra&#39;, 2018),</span>
<span class="sd">                    ( &#39;cobra&#39;, 2019)],</span>
<span class="sd">                   names=[&#39;species&#39;, &#39;year&#39;])</span>

<span class="sd">        When renaming levels with a dict, levels can not be passed.</span>

<span class="sd">        &gt;&gt;&gt; idx.set_names({&#39;kind&#39;: &#39;snake&#39;})</span>
<span class="sd">        MultiIndex([(&#39;python&#39;, 2018),</span>
<span class="sd">                    (&#39;python&#39;, 2019),</span>
<span class="sd">                    ( &#39;cobra&#39;, 2018),</span>
<span class="sd">                    ( &#39;cobra&#39;, 2019)],</span>
<span class="sd">                   names=[&#39;snake&#39;, &#39;year&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Level must be None for non-MultiIndex&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Names must be a string when a single level is provided.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">and</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must pass list-like as `names`.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only pass dict-like as `names` for MultiIndex.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">and</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can not pass level for dictlike `names`.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">and</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Transform dict to list of new names and corresponding levels</span>
            <span class="n">level</span><span class="p">,</span> <span class="n">names_adjusted</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">level</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">names_adjusted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names_adjusted</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="n">level</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>

        <span class="n">idx</span><span class="o">.</span><span class="n">_set_names</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Index.rename"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alter Index or MultiIndex name.</span>

<span class="sd">        Able to set new names without level. Defaults to returning new index.</span>
<span class="sd">        Length of names must match number of levels in MultiIndex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : label or list of labels</span>
<span class="sd">            Name(s) to set.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Modifies the object directly, instead of creating a new Index or</span>
<span class="sd">            MultiIndex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index or None</span>
<span class="sd">            The same type as the caller or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.set_names : Able to set new names partially and by level.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;A&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;], name=&#39;score&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.rename(&#39;grade&#39;)</span>
<span class="sd">        Index([&#39;A&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;], dtype=&#39;object&#39;, name=&#39;grade&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.MultiIndex.from_product([[&#39;python&#39;, &#39;cobra&#39;],</span>
<span class="sd">        ...                                   [2018, 2019]],</span>
<span class="sd">        ...                                   names=[&#39;kind&#39;, &#39;year&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        MultiIndex([(&#39;python&#39;, 2018),</span>
<span class="sd">                    (&#39;python&#39;, 2019),</span>
<span class="sd">                    ( &#39;cobra&#39;, 2018),</span>
<span class="sd">                    ( &#39;cobra&#39;, 2019)],</span>
<span class="sd">                   names=[&#39;kind&#39;, &#39;year&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.rename([&#39;species&#39;, &#39;year&#39;])</span>
<span class="sd">        MultiIndex([(&#39;python&#39;, 2018),</span>
<span class="sd">                    (&#39;python&#39;, 2019),</span>
<span class="sd">                    ( &#39;cobra&#39;, 2018),</span>
<span class="sd">                    ( &#39;cobra&#39;, 2019)],</span>
<span class="sd">                   names=[&#39;species&#39;, &#39;year&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.rename(&#39;species&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        TypeError: Must pass list-like as `names`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_names</span><span class="p">([</span><span class="n">name</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span></div>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Level-Centric Methods</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nlevels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of levels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_sort_levels_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compat with MultiIndex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_validate_index_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate index level.</span>

<span class="sd">        For single-level Index getting level number is a no-op, but some</span>
<span class="sd">        verification must be done like in MultiIndex.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">level</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="s2">&quot;Too many levels: Index has only 1 level, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2"> is not a valid level number&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Too many levels: Index has only 1 level, not </span><span class="si">{</span><span class="n">level</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">level</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Requested level (</span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2">) does not match index name (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_level_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

<div class="viewcode-block" id="Index.sortlevel"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.sortlevel">[docs]</a>    <span class="k">def</span> <span class="nf">sortlevel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sort_remaining</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For internal compatibility with the Index API.</span>

<span class="sd">        Sort the Index. This is for compat with MultiIndex</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ascending : bool, default True</span>
<span class="sd">            False to sort in descending order</span>

<span class="sd">        level, sort_remaining are compat parameters</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ascending</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;ascending must be a single bool value or&quot;</span>
                <span class="s2">&quot;a list of bool values of length 1&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ascending</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ascending</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ascending must be a list of bool values of length 1&quot;</span><span class="p">)</span>
            <span class="n">ascending</span> <span class="o">=</span> <span class="n">ascending</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ascending</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ascending must be a bool value&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">return_indexer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_level_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an Index of values for requested level.</span>

<span class="sd">        This is primarily useful to get an individual level of values from a</span>
<span class="sd">        MultiIndex, but is provided on Index as well for compatibility.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int or str</span>
<span class="sd">            It is either the integer position or the name of the level.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">            Calling object, as there is only one level in the Index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MultiIndex.get_level_values : Get values for a level of a MultiIndex.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For Index, level should be 0, since there are no multiple levels.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index(list(&#39;abc&#39;))</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        Get level values by supplying `level` as integer:</span>

<span class="sd">        &gt;&gt;&gt; idx.get_level_values(0)</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">get_level_values</span> <span class="o">=</span> <span class="n">_get_level_values</span>

<div class="viewcode-block" id="Index.droplevel"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.droplevel">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">droplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index with requested level(s) removed.</span>

<span class="sd">        If resulting index has only 1 level left, the result will be</span>
<span class="sd">        of Index type, not MultiIndex. The original index is not modified inplace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, or list-like, default 0</span>
<span class="sd">            If a string is given, must be the name of a level</span>
<span class="sd">            If list-like, elements must be names or indexes of levels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index or MultiIndex</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays(</span>
<span class="sd">        ... [[1, 2], [3, 4], [5, 6]], names=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</span>
<span class="sd">        &gt;&gt;&gt; mi</span>
<span class="sd">        MultiIndex([(1, 3, 5),</span>
<span class="sd">                    (2, 4, 6)],</span>
<span class="sd">                   names=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</span>

<span class="sd">        &gt;&gt;&gt; mi.droplevel()</span>
<span class="sd">        MultiIndex([(3, 5),</span>
<span class="sd">                    (4, 6)],</span>
<span class="sd">                   names=[&#39;y&#39;, &#39;z&#39;])</span>

<span class="sd">        &gt;&gt;&gt; mi.droplevel(2)</span>
<span class="sd">        MultiIndex([(1, 3),</span>
<span class="sd">                    (2, 4)],</span>
<span class="sd">                   names=[&#39;x&#39;, &#39;y&#39;])</span>

<span class="sd">        &gt;&gt;&gt; mi.droplevel(&#39;z&#39;)</span>
<span class="sd">        MultiIndex([(1, 3),</span>
<span class="sd">                    (2, 4)],</span>
<span class="sd">                   names=[&#39;x&#39;, &#39;y&#39;])</span>

<span class="sd">        &gt;&gt;&gt; mi.droplevel([&#39;x&#39;, &#39;y&#39;])</span>
<span class="sd">        Index([5, 6], dtype=&#39;int64&#39;, name=&#39;z&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="n">level</span><span class="p">]</span>

        <span class="n">levnums</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">level</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drop_level_numbers</span><span class="p">(</span><span class="n">levnums</span><span class="p">)</span></div>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_drop_level_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">levnums</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop MultiIndex levels by level _number_, not name.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">levnums</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levnums</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot remove </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">levnums</span><span class="p">)</span><span class="si">}</span><span class="s2"> levels from an index with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span><span class="si">}</span><span class="s2"> levels: at least one level must be left.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># The two checks above guarantee that here self is a MultiIndex</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;MultiIndex&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">new_levels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">new_codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>
        <span class="n">new_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">levnums</span><span class="p">:</span>
            <span class="n">new_levels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">new_codes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">new_names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_levels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lev</span> <span class="o">=</span> <span class="n">new_levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If lev is empty, lev.take will fail GH#42055</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_codes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># GH#45230 preserve RangeIndex here</span>
                    <span class="c1">#  see test_reset_index_empty_rangeindex</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">lev</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res_values</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">lev</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">new_codes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">allow_fill</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># _constructor instead of type(lev) for RangeIndex compat GH#35230</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">lev</span><span class="o">.</span><span class="n">_constructor</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">new_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># set nan if needed</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">new_codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">new_levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">new_codes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

                <span class="n">result</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">new_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.core.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

            <span class="k">return</span> <span class="n">MultiIndex</span><span class="p">(</span>
                <span class="n">levels</span><span class="o">=</span><span class="n">new_levels</span><span class="p">,</span>
                <span class="n">codes</span><span class="o">=</span><span class="n">new_codes</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="n">new_names</span><span class="p">,</span>
                <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Introspection Methods</span>

    <span class="nd">@cache_readonly</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_can_hold_na</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ExtensionDtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">IntervalDtype</span><span class="p">):</span>
                <span class="c1"># FIXME(GH#45720): this is inaccurate for integer-backed</span>
                <span class="c1">#  IntervalArray, but without it other.categories.take raises</span>
                <span class="c1">#  in IntervalArray._cmp_method</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">_can_hold_na</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_monotonic_increasing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean if the values are equal or increasing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.is_monotonic_decreasing : Check if the values are equal or decreasing.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pd.Index([1, 2, 3]).is_monotonic_increasing</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; pd.Index([1, 2, 2]).is_monotonic_increasing</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; pd.Index([1, 3, 2]).is_monotonic_increasing</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_monotonic_decreasing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean if the values are equal or decreasing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.is_monotonic_increasing : Check if the values are equal or increasing.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pd.Index([3, 2, 1]).is_monotonic_decreasing</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; pd.Index([3, 2, 2]).is_monotonic_decreasing</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; pd.Index([3, 1, 2]).is_monotonic_decreasing</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span>

    <span class="nd">@final</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_strictly_monotonic_increasing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the index is strictly monotonic increasing</span>
<span class="sd">        (only increasing) values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Index([1, 2, 3])._is_strictly_monotonic_increasing</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Index([1, 2, 2])._is_strictly_monotonic_increasing</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Index([1, 3, 2])._is_strictly_monotonic_increasing</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>

    <span class="nd">@final</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_strictly_monotonic_decreasing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the index is strictly monotonic decreasing</span>
<span class="sd">        (only decreasing) values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Index([3, 2, 1])._is_strictly_monotonic_decreasing</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Index([3, 2, 2])._is_strictly_monotonic_decreasing</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Index([3, 1, 2])._is_strictly_monotonic_decreasing</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">is_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the index has unique values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.has_duplicates : Inverse method that checks if it has duplicate values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 5, 7, 7])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_unique</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 5, 7])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_unique</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Apple&quot;,</span>
<span class="sd">        ...                 &quot;Watermelon&quot;]).astype(&quot;category&quot;)</span>
<span class="sd">        &gt;&gt;&gt; idx.is_unique</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&quot;Orange&quot;, &quot;Apple&quot;,</span>
<span class="sd">        ...                 &quot;Watermelon&quot;]).astype(&quot;category&quot;)</span>
<span class="sd">        &gt;&gt;&gt; idx.is_unique</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">is_unique</span>

    <span class="nd">@final</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the Index has duplicate values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether or not the Index has duplicate values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.is_unique : Inverse method that checks if it has unique values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 5, 7, 7])</span>
<span class="sd">        &gt;&gt;&gt; idx.has_duplicates</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 5, 7])</span>
<span class="sd">        &gt;&gt;&gt; idx.has_duplicates</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Apple&quot;,</span>
<span class="sd">        ...                 &quot;Watermelon&quot;]).astype(&quot;category&quot;)</span>
<span class="sd">        &gt;&gt;&gt; idx.has_duplicates</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&quot;Orange&quot;, &quot;Apple&quot;,</span>
<span class="sd">        ...                 &quot;Watermelon&quot;]).astype(&quot;category&quot;)</span>
<span class="sd">        &gt;&gt;&gt; idx.has_duplicates</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span>

<div class="viewcode-block" id="Index.is_boolean"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.is_boolean">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">is_boolean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the Index only consists of booleans.</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Use `pandas.api.types.is_bool_dtype` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether or not the Index only consists of booleans.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        is_integer : Check if the Index only consists of integers (deprecated).</span>
<span class="sd">        is_floating : Check if the Index is a floating type (deprecated).</span>
<span class="sd">        is_numeric : Check if the Index only consists of numeric data (deprecated).</span>
<span class="sd">        is_object : Check if the Index is of the object dtype (deprecated).</span>
<span class="sd">        is_categorical : Check if the Index holds categorical data.</span>
<span class="sd">        is_interval : Check if the Index holds Interval objects (deprecated).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([True, False, True])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_boolean()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&quot;True&quot;, &quot;False&quot;, &quot;True&quot;])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_boolean()  # doctest: +SKIP</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([True, False, &quot;True&quot;])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_boolean()  # doctest: +SKIP</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.is_boolean is deprecated. &quot;</span>
            <span class="s2">&quot;Use pandas.api.types.is_bool_type instead.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;boolean&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Index.is_integer"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.is_integer">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">is_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the Index only consists of integers.</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Use `pandas.api.types.is_integer_dtype` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether or not the Index only consists of integers.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        is_boolean : Check if the Index only consists of booleans (deprecated).</span>
<span class="sd">        is_floating : Check if the Index is a floating type (deprecated).</span>
<span class="sd">        is_numeric : Check if the Index only consists of numeric data (deprecated).</span>
<span class="sd">        is_object : Check if the Index is of the object dtype. (deprecated).</span>
<span class="sd">        is_categorical : Check if the Index holds categorical data (deprecated).</span>
<span class="sd">        is_interval : Check if the Index holds Interval objects (deprecated).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_integer()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_integer()  # doctest: +SKIP</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&quot;Apple&quot;, &quot;Mango&quot;, &quot;Watermelon&quot;])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_integer()  # doctest: +SKIP</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.is_integer is deprecated. &quot;</span>
            <span class="s2">&quot;Use pandas.api.types.is_integer_dtype instead.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;integer&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Index.is_floating"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.is_floating">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">is_floating</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the Index is a floating type.</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Use `pandas.api.types.is_float_dtype` instead</span>

<span class="sd">        The Index may consist of only floats, NaNs, or a mix of floats,</span>
<span class="sd">        integers, or NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether or not the Index only consists of only consists of floats, NaNs, or</span>
<span class="sd">            a mix of floats, integers, or NaNs.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        is_boolean : Check if the Index only consists of booleans (deprecated).</span>
<span class="sd">        is_integer : Check if the Index only consists of integers (deprecated).</span>
<span class="sd">        is_numeric : Check if the Index only consists of numeric data (deprecated).</span>
<span class="sd">        is_object : Check if the Index is of the object dtype. (deprecated).</span>
<span class="sd">        is_categorical : Check if the Index holds categorical data (deprecated).</span>
<span class="sd">        is_interval : Check if the Index holds Interval objects (deprecated).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_floating()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, np.nan, 4.0])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_floating()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_floating()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_floating()  # doctest: +SKIP</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.is_floating is deprecated. &quot;</span>
            <span class="s2">&quot;Use pandas.api.types.is_float_dtype instead.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;floating&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed-integer-float&quot;</span><span class="p">,</span> <span class="s2">&quot;integer-na&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Index.is_numeric"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.is_numeric">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">is_numeric</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the Index only consists of numeric data.</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Use `pandas.api.types.is_numeric_dtype` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether or not the Index only consists of numeric data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        is_boolean : Check if the Index only consists of booleans (deprecated).</span>
<span class="sd">        is_integer : Check if the Index only consists of integers (deprecated).</span>
<span class="sd">        is_floating : Check if the Index is a floating type (deprecated).</span>
<span class="sd">        is_object : Check if the Index is of the object dtype. (deprecated).</span>
<span class="sd">        is_categorical : Check if the Index holds categorical data (deprecated).</span>
<span class="sd">        is_interval : Check if the Index holds Interval objects (deprecated).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_numeric()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4.0])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_numeric()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_numeric()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4.0, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_numeric()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4.0, np.nan, &quot;Apple&quot;])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_numeric()  # doctest: +SKIP</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.is_numeric is deprecated. &quot;</span>
            <span class="s2">&quot;Use pandas.api.types.is_any_real_numeric_dtype instead&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;integer&quot;</span><span class="p">,</span> <span class="s2">&quot;floating&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Index.is_object"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.is_object">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">is_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the Index is of the object dtype.</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">           Use `pandas.api.types.is_object_dtype` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether or not the Index is of the object dtype.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        is_boolean : Check if the Index only consists of booleans (deprecated).</span>
<span class="sd">        is_integer : Check if the Index only consists of integers (deprecated).</span>
<span class="sd">        is_floating : Check if the Index is a floating type (deprecated).</span>
<span class="sd">        is_numeric : Check if the Index only consists of numeric data (deprecated).</span>
<span class="sd">        is_categorical : Check if the Index holds categorical data (deprecated).</span>
<span class="sd">        is_interval : Check if the Index holds Interval objects (deprecated).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&quot;Apple&quot;, &quot;Mango&quot;, &quot;Watermelon&quot;])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_object()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&quot;Apple&quot;, &quot;Mango&quot;, 2.0])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_object()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Apple&quot;,</span>
<span class="sd">        ...                 &quot;Watermelon&quot;]).astype(&quot;category&quot;)</span>
<span class="sd">        &gt;&gt;&gt; idx.is_object()  # doctest: +SKIP</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_object()  # doctest: +SKIP</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.is_object is deprecated.&quot;</span>
            <span class="s2">&quot;Use pandas.api.types.is_object_dtype instead&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.is_categorical"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.is_categorical">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">is_categorical</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the Index holds categorical data.</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">              Use :meth:`pandas.api.types.is_categorical_dtype` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the Index is categorical.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        CategoricalIndex : Index for categorical data.</span>
<span class="sd">        is_boolean : Check if the Index only consists of booleans (deprecated).</span>
<span class="sd">        is_integer : Check if the Index only consists of integers (deprecated).</span>
<span class="sd">        is_floating : Check if the Index is a floating type (deprecated).</span>
<span class="sd">        is_numeric : Check if the Index only consists of numeric data (deprecated).</span>
<span class="sd">        is_object : Check if the Index is of the object dtype. (deprecated).</span>
<span class="sd">        is_interval : Check if the Index holds Interval objects (deprecated).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Apple&quot;,</span>
<span class="sd">        ...                 &quot;Watermelon&quot;]).astype(&quot;category&quot;)</span>
<span class="sd">        &gt;&gt;&gt; idx.is_categorical()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 3, 5, 7])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_categorical()  # doctest: +SKIP</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&quot;Peter&quot;, &quot;Victor&quot;, &quot;Elisabeth&quot;, &quot;Mar&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0        Peter</span>
<span class="sd">        1       Victor</span>
<span class="sd">        2    Elisabeth</span>
<span class="sd">        3          Mar</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; s.index.is_categorical()  # doctest: +SKIP</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.is_categorical is deprecated.&quot;</span>
            <span class="s2">&quot;Use pandas.api.types.is_categorical_dtype instead&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;categorical&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Index.is_interval"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.is_interval">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">is_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the Index holds Interval objects.</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Use `pandas.api.types.is_interval_dtype` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether or not the Index holds Interval objects.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        IntervalIndex : Index for Interval objects.</span>
<span class="sd">        is_boolean : Check if the Index only consists of booleans (deprecated).</span>
<span class="sd">        is_integer : Check if the Index only consists of integers (deprecated).</span>
<span class="sd">        is_floating : Check if the Index is a floating type (deprecated).</span>
<span class="sd">        is_numeric : Check if the Index only consists of numeric data (deprecated).</span>
<span class="sd">        is_object : Check if the Index is of the object dtype. (deprecated).</span>
<span class="sd">        is_categorical : Check if the Index holds categorical data (deprecated).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([pd.Interval(left=0, right=5),</span>
<span class="sd">        ...                 pd.Interval(left=5, right=10)])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_interval()  # doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 3, 5, 7])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_interval()  # doctest: +SKIP</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.is_interval is deprecated.&quot;</span>
            <span class="s2">&quot;Use pandas.api.types.is_interval_dtype instead&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;interval&quot;</span><span class="p">]</span></div>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_holds_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the type is an integer type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;integer&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed-integer&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="Index.holds_integer"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.holds_integer">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">holds_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the type is an integer type.</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Use `pandas.api.types.infer_dtype` instead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.holds_integer is deprecated. &quot;</span>
            <span class="s2">&quot;Use pandas.api.types.infer_dtype instead.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holds_integer</span><span class="p">()</span></div>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">inferred_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">str_t</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string of the type inferred from the values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_is_all_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether or not the index values only consist of dates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">_dtype_obj</span><span class="p">:</span>
            <span class="c1"># TODO(ExtensionIndex): 3rd party EA might override?</span>
            <span class="c1"># Note: this includes IntervalIndex, even when the left/right</span>
            <span class="c1">#  contain datetime-like objects.</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">is_datetime_array</span><span class="p">(</span><span class="n">ensure_object</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span>

    <span class="nd">@final</span>
    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_is_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cached check equivalent to isinstance(self, MultiIndex)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Pickle Methods</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">_new_Index</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">d</span><span class="p">),</span> <span class="kc">None</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Null Handling Methods</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_na_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The expected NA value to use with this index.&quot;&quot;&quot;</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">NaT</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">dtype</span><span class="o">.</span><span class="n">na_value</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_isnan</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if each value is NaN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_hold_na</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># shouldn&#39;t reach to this condition by checking hasnans beforehand</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">hasnans</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if there are any NaNs.</span>

<span class="sd">        Enables various performance speedups.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_hold_na</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Index.isna"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.isna">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect missing values.</span>

<span class="sd">        Return a boolean same-sized object indicating if the values are NA.</span>
<span class="sd">        NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get</span>
<span class="sd">        mapped to ``True`` values.</span>
<span class="sd">        Everything else get mapped to ``False`` values. Characters such as</span>
<span class="sd">        empty strings `&#39;&#39;` or :attr:`numpy.inf` are not considered NA values</span>
<span class="sd">        (unless you set ``pandas.options.mode.use_inf_as_na = True``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray[bool]</span>
<span class="sd">            A boolean array of whether my values are NA.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.notna : Boolean inverse of isna.</span>
<span class="sd">        Index.dropna : Omit entries with missing values.</span>
<span class="sd">        isna : Top-level isna.</span>
<span class="sd">        Series.isna : Detect missing values in Series object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Show which entries in a pandas.Index are NA. The result is an</span>
<span class="sd">        array.</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([5.2, 6.0, np.NaN])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([5.2, 6.0, nan], dtype=&#39;float64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.isna()</span>
<span class="sd">        array([False, False,  True])</span>

<span class="sd">        Empty strings are not considered NA values. None is considered an NA</span>
<span class="sd">        value.</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;black&#39;, &#39;&#39;, &#39;red&#39;, None])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([&#39;black&#39;, &#39;&#39;, &#39;red&#39;, None], dtype=&#39;object&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.isna()</span>
<span class="sd">        array([False, False, False,  True])</span>

<span class="sd">        For datetimes, `NaT` (Not a Time) is considered as an NA value.</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.DatetimeIndex([pd.Timestamp(&#39;1940-04-25&#39;),</span>
<span class="sd">        ...                         pd.Timestamp(&#39;&#39;), None, pd.NaT])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;1940-04-25&#39;, &#39;NaT&#39;, &#39;NaT&#39;, &#39;NaT&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
<span class="sd">        &gt;&gt;&gt; idx.isna()</span>
<span class="sd">        array([False,  True,  True,  True])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span></div>

    <span class="n">isnull</span> <span class="o">=</span> <span class="n">isna</span>

<div class="viewcode-block" id="Index.notna"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.notna">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect existing (non-missing) values.</span>

<span class="sd">        Return a boolean same-sized object indicating if the values are not NA.</span>
<span class="sd">        Non-missing values get mapped to ``True``. Characters such as empty</span>
<span class="sd">        strings ``&#39;&#39;`` or :attr:`numpy.inf` are not considered NA values</span>
<span class="sd">        (unless you set ``pandas.options.mode.use_inf_as_na = True``).</span>
<span class="sd">        NA values, such as None or :attr:`numpy.NaN`, get mapped to ``False``</span>
<span class="sd">        values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray[bool]</span>
<span class="sd">            Boolean array to indicate which entries are not NA.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.notnull : Alias of notna.</span>
<span class="sd">        Index.isna: Inverse of notna.</span>
<span class="sd">        notna : Top-level notna.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Show which entries in an Index are not NA. The result is an</span>
<span class="sd">        array.</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([5.2, 6.0, np.NaN])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([5.2, 6.0, nan], dtype=&#39;float64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.notna()</span>
<span class="sd">        array([ True,  True, False])</span>

<span class="sd">        Empty strings are not considered NA values. None is considered a NA</span>
<span class="sd">        value.</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;black&#39;, &#39;&#39;, &#39;red&#39;, None])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([&#39;black&#39;, &#39;&#39;, &#39;red&#39;, None], dtype=&#39;object&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.notna()</span>
<span class="sd">        array([ True,  True,  True, False])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span></div>

    <span class="n">notnull</span> <span class="o">=</span> <span class="n">notna</span>

<div class="viewcode-block" id="Index.fillna"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.fillna">[docs]</a>    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NA/NaN values with the specified value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar</span>
<span class="sd">            Scalar value to use to fill holes (e.g. 0).</span>
<span class="sd">            This value cannot be a list-likes.</span>
<span class="sd">        downcast : dict, default is None</span>
<span class="sd">            A dict of item-&gt;dtype of what to downcast if possible,</span>
<span class="sd">            or the string &#39;infer&#39; which will try to downcast to an appropriate</span>
<span class="sd">            equal type (e.g. float64 to int64 if possible).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.fillna : Fill NaN values of a DataFrame.</span>
<span class="sd">        Series.fillna : Fill NaN Values of a Series.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_require_scalar</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">downcast</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># no need to care metadata other than name</span>
                <span class="c1"># because it can&#39;t have freq if it has NaTs</span>
                <span class="c1"># _with_infer needed for test_fillna_categorical</span>
                <span class="k">return</span> <span class="n">Index</span><span class="o">.</span><span class="n">_with_infer</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.fillna does not support &#39;downcast&#39; &quot;</span>
                <span class="s2">&quot;argument values other than &#39;None&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span></div>

<div class="viewcode-block" id="Index.dropna"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.dropna">[docs]</a>    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="n">AnyAll</span> <span class="o">=</span> <span class="s2">&quot;any&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Index without NA/NaN values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        how : {&#39;any&#39;, &#39;all&#39;}, default &#39;any&#39;</span>
<span class="sd">            If the Index is a MultiIndex, drop the value when any or all levels</span>
<span class="sd">            are NaN.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">how</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid how option: </span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span></div>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Uniqueness Methods</span>

<div class="viewcode-block" id="Index.unique"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.unique">[docs]</a>    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return unique values in the index.</span>

<span class="sd">        Unique values are returned in order of appearance, this does NOT sort.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int or hashable, optional</span>
<span class="sd">            Only return values from specified level (for MultiIndex).</span>
<span class="sd">            If int, gets the level by integer position, else by level name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        unique : Numpy array of unique values in that column.</span>
<span class="sd">        Series.unique : Return unique values of Series object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.drop_duplicates"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.drop_duplicates">[docs]</a>    <span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">DropKeep</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Index with duplicate values removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, ``False``}, default &#39;first&#39;</span>
<span class="sd">            - &#39;first&#39; : Drop duplicates except for the first occurrence.</span>
<span class="sd">            - &#39;last&#39; : Drop duplicates except for the last occurrence.</span>
<span class="sd">            - ``False`` : Drop all duplicates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.drop_duplicates : Equivalent method on Series.</span>
<span class="sd">        DataFrame.drop_duplicates : Equivalent method on DataFrame.</span>
<span class="sd">        Index.duplicated : Related method on Index, indicating duplicate</span>
<span class="sd">            Index values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generate an pandas.Index with duplicate values.</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;])</span>

<span class="sd">        The `keep` parameter controls  which duplicate values are removed.</span>
<span class="sd">        The value &#39;first&#39; keeps the first occurrence for each</span>
<span class="sd">        set of duplicated entries. The default value of keep is &#39;first&#39;.</span>

<span class="sd">        &gt;&gt;&gt; idx.drop_duplicates(keep=&#39;first&#39;)</span>
<span class="sd">        Index([&#39;lama&#39;, &#39;cow&#39;, &#39;beetle&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        The value &#39;last&#39; keeps the last occurrence for each set of duplicated</span>
<span class="sd">        entries.</span>

<span class="sd">        &gt;&gt;&gt; idx.drop_duplicates(keep=&#39;last&#39;)</span>
<span class="sd">        Index([&#39;cow&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        The value ``False`` discards all sets of duplicated entries.</span>

<span class="sd">        &gt;&gt;&gt; idx.drop_duplicates(keep=False)</span>
<span class="sd">        Index([&#39;cow&#39;, &#39;beetle&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.duplicated"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.duplicated">[docs]</a>    <span class="k">def</span> <span class="nf">duplicated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">DropKeep</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicate duplicate index values.</span>

<span class="sd">        Duplicated values are indicated as ``True`` values in the resulting</span>
<span class="sd">        array. Either all duplicates, all except the first, or all except the</span>
<span class="sd">        last occurrence of duplicates can be indicated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, False}, default &#39;first&#39;</span>
<span class="sd">            The value or values in a set of duplicates to mark as missing.</span>

<span class="sd">            - &#39;first&#39; : Mark duplicates as ``True`` except for the first</span>
<span class="sd">              occurrence.</span>
<span class="sd">            - &#39;last&#39; : Mark duplicates as ``True`` except for the last</span>
<span class="sd">              occurrence.</span>
<span class="sd">            - ``False`` : Mark all duplicates as ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray[bool]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.duplicated : Equivalent method on pandas.Series.</span>
<span class="sd">        DataFrame.duplicated : Equivalent method on pandas.DataFrame.</span>
<span class="sd">        Index.drop_duplicates : Remove duplicate values from Index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        By default, for each set of duplicated values, the first occurrence is</span>
<span class="sd">        set to False and all others to True:</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.duplicated()</span>
<span class="sd">        array([False, False,  True, False,  True])</span>

<span class="sd">        which is equivalent to</span>

<span class="sd">        &gt;&gt;&gt; idx.duplicated(keep=&#39;first&#39;)</span>
<span class="sd">        array([False, False,  True, False,  True])</span>

<span class="sd">        By using &#39;last&#39;, the last occurrence of each set of duplicated values</span>
<span class="sd">        is set on False and all others on True:</span>

<span class="sd">        &gt;&gt;&gt; idx.duplicated(keep=&#39;last&#39;)</span>
<span class="sd">        array([ True, False,  True, False, False])</span>

<span class="sd">        By setting keep on ``False``, all duplicates are True:</span>

<span class="sd">        &gt;&gt;&gt; idx.duplicated(keep=False)</span>
<span class="sd">        array([ True, False,  True, False,  True])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="c1"># fastpath available bc we are immutable</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span></div>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Arithmetic &amp; Logical Methods</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># alias for __add__</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The truth value of a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is ambiguous. &quot;</span>
            <span class="s2">&quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot;</span>
        <span class="p">)</span>

    <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Set Operation Methods</span>

    <span class="k">def</span> <span class="nf">_get_reconciled_name_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the result of a set operation will be self,</span>
<span class="sd">        return self, unless the name changes, in which</span>
<span class="sd">        case make a shallow copy of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_validate_sort_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sort</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The &#39;sort&#39; keyword only takes the values of &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;None, True, or False; </span><span class="si">{</span><span class="n">sort</span><span class="si">}</span><span class="s2"> was passed.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_dti_setop_align_tzs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">setop</span><span class="p">:</span> <span class="n">str_t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">Index</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        With mismatched timezones, cast both to UTC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Caller is responsibelf or checking</span>
        <span class="c1">#  `not is_dtype_equal(self.dtype, other.dtype)`</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDatetimeIndex</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDatetimeIndex</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="c1"># GH#39328, GH#45357</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s2">&quot;UTC&quot;</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s2">&quot;UTC&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>

<div class="viewcode-block" id="Index.union"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.union">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Form the union of two Index objects.</span>

<span class="sd">        If the Index objects are incompatible, both Index objects will be</span>
<span class="sd">        cast to dtype(&#39;object&#39;) first.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>
<span class="sd">        sort : bool or None, default None</span>
<span class="sd">            Whether to sort the resulting Index.</span>

<span class="sd">            * None : Sort the result, except when</span>

<span class="sd">              1. `self` and `other` are equal.</span>
<span class="sd">              2. `self` or `other` has length 0.</span>
<span class="sd">              3. Some values in `self` or `other` cannot be compared.</span>
<span class="sd">                 A RuntimeWarning is issued in this case.</span>

<span class="sd">            * False : do not sort the result.</span>
<span class="sd">            * True : Sort the result (which may raise TypeError).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Union matching dtypes</span>

<span class="sd">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; idx1.union(idx2)</span>
<span class="sd">        Index([1, 2, 3, 4, 5, 6], dtype=&#39;int64&#39;)</span>

<span class="sd">        Union mismatched dtypes</span>

<span class="sd">        &gt;&gt;&gt; idx1 = pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx1.union(idx2)</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, 1, 2, 3, 4], dtype=&#39;object&#39;)</span>

<span class="sd">        MultiIndex case</span>

<span class="sd">        &gt;&gt;&gt; idx1 = pd.MultiIndex.from_arrays(</span>
<span class="sd">        ...     [[1, 1, 2, 2], [&quot;Red&quot;, &quot;Blue&quot;, &quot;Red&quot;, &quot;Blue&quot;]]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; idx1</span>
<span class="sd">        MultiIndex([(1,  &#39;Red&#39;),</span>
<span class="sd">            (1, &#39;Blue&#39;),</span>
<span class="sd">            (2,  &#39;Red&#39;),</span>
<span class="sd">            (2, &#39;Blue&#39;)],</span>
<span class="sd">           )</span>
<span class="sd">        &gt;&gt;&gt; idx2 = pd.MultiIndex.from_arrays(</span>
<span class="sd">        ...     [[3, 3, 2, 2], [&quot;Red&quot;, &quot;Green&quot;, &quot;Red&quot;, &quot;Green&quot;]]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; idx2</span>
<span class="sd">        MultiIndex([(3,   &#39;Red&#39;),</span>
<span class="sd">            (3, &#39;Green&#39;),</span>
<span class="sd">            (2,   &#39;Red&#39;),</span>
<span class="sd">            (2, &#39;Green&#39;)],</span>
<span class="sd">           )</span>
<span class="sd">        &gt;&gt;&gt; idx1.union(idx2)</span>
<span class="sd">        MultiIndex([(1,  &#39;Blue&#39;),</span>
<span class="sd">            (1,   &#39;Red&#39;),</span>
<span class="sd">            (2,  &#39;Blue&#39;),</span>
<span class="sd">            (2, &#39;Green&#39;),</span>
<span class="sd">            (2,   &#39;Red&#39;),</span>
<span class="sd">            (3, &#39;Green&#39;),</span>
<span class="sd">            (3,   &#39;Red&#39;)],</span>
<span class="sd">           )</span>
<span class="sd">        &gt;&gt;&gt; idx1.union(idx2, sort=False)</span>
<span class="sd">        MultiIndex([(1,   &#39;Red&#39;),</span>
<span class="sd">            (1,  &#39;Blue&#39;),</span>
<span class="sd">            (2,   &#39;Red&#39;),</span>
<span class="sd">            (2,  &#39;Blue&#39;),</span>
<span class="sd">            (3,   &#39;Red&#39;),</span>
<span class="sd">            (3, &#39;Green&#39;),</span>
<span class="sd">            (2, &#39;Green&#39;)],</span>
<span class="sd">           )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_sort_keyword</span><span class="p">(</span><span class="n">sort</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">other</span><span class="p">,</span> <span class="n">result_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">_unpack_nested_dtype</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Can only union MultiIndex with MultiIndex or Index of tuples, &quot;</span>
                    <span class="s2">&quot;try mi.to_flat_index().union(other) instead.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dti_setop_align_tzs</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;union&quot;</span><span class="p">)</span>

            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_common_type_compat</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c1"># NB: whether this (and the `if not len(self)` check below) come before</span>
            <span class="c1">#  or after the is_dtype_equal check above affects the returned dtype</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_reconciled_name_object</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_reconciled_name_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_union</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_setop_result</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">sort</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Specific union logic should go here. In subclasses, union behavior</span>
<span class="sd">        should be overwritten here rather than in `self.union`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>
<span class="sd">        sort : False or None, default False</span>
<span class="sd">            Whether to sort the resulting index.</span>

<span class="sd">            * False : do not sort the result.</span>
<span class="sd">            * None : sort the result, except when `self` and `other` are equal</span>
<span class="sd">              or when the values cannot be compared.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">rvals</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">sort</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
            <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_duplicates</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">has_duplicates</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_use_libjoin</span>
        <span class="p">):</span>
            <span class="c1"># Both are monotonic and at least one is unique, so can use outer join</span>
            <span class="c1">#  (actually don&#39;t need either unique, but without this restriction</span>
            <span class="c1">#  test_union_same_value_duplicated_in_both fails)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outer_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="n">IncompatibleFrequency</span><span class="p">):</span>
                <span class="c1"># incomparable objects; should only be for object dtype</span>
                <span class="n">value_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lvals</span><span class="p">)</span>

                <span class="c1"># worth making this faster? a very unusual case</span>
                <span class="n">value_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lvals</span><span class="p">)</span>
                <span class="n">value_list</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rvals</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">value_set</span><span class="p">])</span>
                <span class="c1"># If objects are unorderable, we must have object dtype.</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="c1"># other has duplicates</span>
            <span class="n">result_dups</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">union_with_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_maybe_try_sort</span><span class="p">(</span><span class="n">result_dups</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>

        <span class="c1"># The rest of this method is analogous to Index._intersection_via_get_indexer</span>

        <span class="c1"># Self may have duplicates; other already checked as unique</span>
        <span class="c1"># find indexes of things in &quot;other&quot; that are not in &quot;self&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_as_unique</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="p">(</span><span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">unique1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">other</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">result</span><span class="p">:</span> <span class="n">Index</span> <span class="o">|</span> <span class="n">MultiIndex</span> <span class="o">|</span> <span class="n">ArrayLike</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="c1"># Preserve MultiIndex to avoid losing dtypes</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">missing</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">other_diff</span> <span class="o">=</span> <span class="n">rvals</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">concat_compat</span><span class="p">((</span><span class="n">lvals</span><span class="p">,</span> <span class="n">other_diff</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">lvals</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="c1"># if both are monotonic then result should already be sorted</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_maybe_try_sort</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_wrap_setop_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Index.intersection"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.intersection">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Form the intersection of two Index objects.</span>

<span class="sd">        This returns a new Index with elements common to the index and `other`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>
<span class="sd">        sort : True, False or None, default False</span>
<span class="sd">            Whether to sort the resulting index.</span>

<span class="sd">            * None : sort the result, except when `self` and `other` are equal</span>
<span class="sd">              or when the values cannot be compared.</span>
<span class="sd">            * False : do not sort the result.</span>
<span class="sd">            * True : Sort the result (which may raise TypeError).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; idx1.intersection(idx2)</span>
<span class="sd">        Index([3, 4], dtype=&#39;int64&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_sort_keyword</span><span class="p">(</span><span class="n">sort</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">other</span><span class="p">,</span> <span class="n">result_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dti_setop_align_tzs</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;intersection&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_duplicates</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">_get_reconciled_name_object</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_reconciled_name_object</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># fastpath; we need to be careful about having commutativity</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
                <span class="c1"># _convert_can_do_setop ensures that we have both or neither</span>
                <span class="c1"># We retain self.levels</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>

            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_common_type_compat</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># Slicing allows us to retain DTI/TDI.freq, RangeIndex</span>

                <span class="c1"># Note: self[:0] vs other[:0] affects</span>
                <span class="c1">#  1) which index&#39;s `freq` we get in DTI/TDI cases</span>
                <span class="c1">#     This may be a historical artifact, i.e. no documented</span>
                <span class="c1">#     reason for this choice.</span>
                <span class="c1">#  2) The `step` we get in RangeIndex cases</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">other</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">Index</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">result_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_compare</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c1"># We can infer that the intersection is empty.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Index</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="n">result_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_common_type_compat</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_intersection_result</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        intersection specialized to the case with matching dtypes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
            <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_use_libjoin</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res_indexer</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># non-comparable; should only be for object dtype</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: algos.unique1d should preserve DTA/TDA</span>
                <span class="k">if</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="c1"># This is faster, because Index.unique() checks for uniqueness</span>
                    <span class="c1"># before calculating the unique values.</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">unique1d</span><span class="p">(</span><span class="n">res_indexer</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="n">res_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersection_via_get_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="n">res_values</span> <span class="o">=</span> <span class="n">_maybe_try_sort</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res_values</span>

    <span class="k">def</span> <span class="nf">_wrap_intersection_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="c1"># We will override for MultiIndex to handle empty results</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_setop_result</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_intersection_via_get_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span> <span class="o">|</span> <span class="n">MultiIndex</span><span class="p">,</span> <span class="n">sort</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">MultiIndex</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the intersection of two Indexes using get_indexer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray or ExtensionArray</span>
<span class="sd">            The returned array will be unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_unique</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">right_unique</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="c1"># even though we are unique, we need get_indexer_for for IntervalIndex</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">left_unique</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">right_unique</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">indexer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">taker</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># sort bc we want the elements in the same order they are in self</span>
            <span class="c1"># unnecessary in the case with sort=None bc we will sort later</span>
            <span class="n">taker</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">taker</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_unique</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">left_unique</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">taker</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">left_unique</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">taker</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Index.difference"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.difference">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Index with elements of index not in `other`.</span>

<span class="sd">        This is the set difference of two Index objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>
<span class="sd">        sort : bool or None, default None</span>
<span class="sd">            Whether to sort the resulting index. By default, the</span>
<span class="sd">            values are attempted to be sorted, but any TypeError from</span>
<span class="sd">            incomparable elements is caught by pandas.</span>

<span class="sd">            * None : Attempt to sort the result, but catch any TypeErrors</span>
<span class="sd">              from comparing incomparable elements.</span>
<span class="sd">            * False : Do not sort the result.</span>
<span class="sd">            * True : Sort the result (which may raise TypeError).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx1 = pd.Index([2, 1, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; idx1.difference(idx2)</span>
<span class="sd">        Index([1, 2], dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx1.difference(idx2, sort=False)</span>
<span class="sd">        Index([2, 1], dtype=&#39;int64&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_sort_keyword</span><span class="p">(</span><span class="n">sort</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">other</span><span class="p">,</span> <span class="n">result_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># Note: we do NOT call _dti_setop_align_tzs here, as there</span>
        <span class="c1">#  is no requirement that .difference be commutative, so it does</span>
        <span class="c1">#  not cast to object.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c1"># Note: we do not (yet) sort even if sort=None GH#24959</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Note: we do not (yet) sort even if sort=None GH#24959</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_compare</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c1"># Nothing matches -&gt; difference is everything</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_difference</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_difference_result</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="p">):</span>
        <span class="c1"># overridden by RangeIndex</span>

        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="n">indexer</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">take</span><span class="p">((</span><span class="n">indexer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">label_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">the_diff</span><span class="p">:</span> <span class="n">MultiIndex</span> <span class="o">|</span> <span class="n">ArrayLike</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="n">the_diff</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">label_diff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">the_diff</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">label_diff</span><span class="p">)</span>
        <span class="n">the_diff</span> <span class="o">=</span> <span class="n">_maybe_try_sort</span><span class="p">(</span><span class="n">the_diff</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">the_diff</span>

    <span class="k">def</span> <span class="nf">_wrap_difference_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="c1"># We will override for MultiIndex to handle empty results</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_setop_result</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<div class="viewcode-block" id="Index.symmetric_difference"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.symmetric_difference">[docs]</a>    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">result_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the symmetric difference of two Index objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>
<span class="sd">        result_name : str</span>
<span class="sd">        sort : bool or None, default None</span>
<span class="sd">            Whether to sort the resulting index. By default, the</span>
<span class="sd">            values are attempted to be sorted, but any TypeError from</span>
<span class="sd">            incomparable elements is caught by pandas.</span>

<span class="sd">            * None : Attempt to sort the result, but catch any TypeErrors</span>
<span class="sd">              from comparing incomparable elements.</span>
<span class="sd">            * False : Do not sort the result.</span>
<span class="sd">            * True : Sort the result (which may raise TypeError).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``symmetric_difference`` contains elements that appear in either</span>
<span class="sd">        ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by</span>
<span class="sd">        ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates</span>
<span class="sd">        dropped.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = pd.Index([2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; idx1.symmetric_difference(idx2)</span>
<span class="sd">        Index([1, 5], dtype=&#39;int64&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_sort_keyword</span><span class="p">(</span><span class="n">sort</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">other</span><span class="p">,</span> <span class="n">result_name_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result_name</span> <span class="o">=</span> <span class="n">result_name_update</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dti_setop_align_tzs</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;symmetric_difference&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_compare</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_common_type_compat</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">that</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">that</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>

        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># {this} minus {other}</span>
        <span class="n">common_indexer</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">take</span><span class="p">((</span><span class="n">indexer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">common_indexer</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">left_diff</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">left_indexer</span><span class="p">)</span>

        <span class="c1"># {other} minus {this}</span>
        <span class="n">right_indexer</span> <span class="o">=</span> <span class="p">(</span><span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">right_diff</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">right_indexer</span><span class="p">)</span>

        <span class="n">res_values</span> <span class="o">=</span> <span class="n">left_diff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_diff</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_maybe_try_sort</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">result_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">res_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left_diff</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;MultiIndex&quot;</span><span class="p">,</span> <span class="n">left_diff</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># result might be an Index, if other was an Index</span>
                <span class="k">return</span> <span class="n">left_diff</span><span class="o">.</span><span class="n">remove_unused_levels</span><span class="p">()</span><span class="o">.</span><span class="n">set_names</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">set_names</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span></div>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_assert_can_do_setop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input must be Index or array-like&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_convert_can_do_setop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">result_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span><span class="p">,</span> <span class="n">result_name</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Indexing Methods</span>

<div class="viewcode-block" id="Index.get_loc"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.get_loc">[docs]</a>    <span class="k">def</span> <span class="nf">get_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get integer location, slice or boolean mask for requested label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : label</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int if unique index, slice if monotonic index, else mask</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; unique_index = pd.Index(list(&#39;abc&#39;))</span>
<span class="sd">        &gt;&gt;&gt; unique_index.get_loc(&#39;b&#39;)</span>
<span class="sd">        1</span>

<span class="sd">        &gt;&gt;&gt; monotonic_index = pd.Index(list(&#39;abbc&#39;))</span>
<span class="sd">        &gt;&gt;&gt; monotonic_index.get_loc(&#39;b&#39;)</span>
<span class="sd">        slice(1, 3, None)</span>

<span class="sd">        &gt;&gt;&gt; non_monotonic_index = pd.Index(list(&#39;abcb&#39;))</span>
<span class="sd">        &gt;&gt;&gt; non_monotonic_index.get_loc(&#39;b&#39;)</span>
<span class="sd">        array([False,  True, False,  True])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">casted_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">casted_key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># If we have a listlike key, _check_indexing_error will raise</span>
            <span class="c1">#  InvalidIndexError. Otherwise we fall through and re-raise</span>
            <span class="c1">#  the TypeError.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_indexing_error</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">raise</span></div>

    <span class="n">_index_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;get_indexer&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Compute indexer and mask for new index given the current index.</span>

<span class="s2">        The indexer should be then used as an input to ndarray.take to align the</span>
<span class="s2">        current data to the new index.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        target : </span><span class="si">%(target_klass)s</span>
<span class="s2">        method : {None, &#39;pad&#39;/&#39;ffill&#39;, &#39;backfill&#39;/&#39;bfill&#39;, &#39;nearest&#39;}, optional</span>
<span class="s2">            * default: exact matches only.</span>
<span class="s2">            * pad / ffill: find the PREVIOUS index value if no exact match.</span>
<span class="s2">            * backfill / bfill: use NEXT index value if no exact match</span>
<span class="s2">            * nearest: use the NEAREST index value if no exact match. Tied</span>
<span class="s2">              distances are broken by preferring the larger index value.</span>
<span class="s2">        limit : int, optional</span>
<span class="s2">            Maximum number of consecutive labels in ``target`` to match for</span>
<span class="s2">            inexact matches.</span>
<span class="s2">        tolerance : optional</span>
<span class="s2">            Maximum distance between original and new labels for inexact</span>
<span class="s2">            matches. The values of the index at the matching locations must</span>
<span class="s2">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>

<span class="s2">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="s2">            to all values, or list-like, which applies variable tolerance per</span>
<span class="s2">            element. List-like includes list, tuple, array, Series, and must be</span>
<span class="s2">            the same size as the index and its dtype must exactly match the</span>
<span class="s2">            index&#39;s type.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        np.ndarray[np.intp]</span>
<span class="s2">            Integers from 0 to n - 1 indicating that the index at these</span>
<span class="s2">            positions matches the corresponding target values. Missing values</span>
<span class="s2">            in the target are marked by -1.</span>
<span class="s2">        </span><span class="si">%(raises_section)s</span>
<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        Returns -1 for unmatched values, for further explanation see the</span>
<span class="s2">        example below.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; index = pd.Index([&#39;c&#39;, &#39;a&#39;, &#39;b&#39;])</span>
<span class="s2">        &gt;&gt;&gt; index.get_indexer([&#39;a&#39;, &#39;b&#39;, &#39;x&#39;])</span>
<span class="s2">        array([ 1,  2, -1])</span>

<span class="s2">        Notice that the return value is an array of locations in ``index``</span>
<span class="s2">        and ``x`` is marked by -1, as it is not in ``index``.</span>
<span class="s2">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Index.get_indexer"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.get_indexer">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s2">&quot;get_indexer&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_index_doc_kwargs</span><span class="p">)</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">get_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">str_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">clean_reindex_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">orig_target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_listlike_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_indexing_method</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_as_unique</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidIndexError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_requires_unique_msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_compare</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_partial_index</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="c1"># IntervalIndex get special treatment bc numeric scalars can be</span>
            <span class="c1">#  matched to Interval scalars</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_indexer_non_comparable</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># _maybe_cast_listlike_indexer ensures target has our dtype</span>
            <span class="c1">#  (could improve perf by doing _should_compare check earlier?)</span>
            <span class="k">assert</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
                <span class="c1"># After _maybe_cast_listlike_indexer, target elements which do not</span>
                <span class="c1"># belong to some category are changed to NaNs</span>
                <span class="c1"># Mask to track actual NaN values compared to inserted NaN values</span>
                <span class="c1"># GH#45361</span>
                <span class="n">target_nans</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">orig_target</span><span class="p">)</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
                <span class="n">indexer</span><span class="p">[</span><span class="n">target_nans</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
                <span class="n">indexer</span><span class="p">[</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">target_nans</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">indexer</span>

        <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># potential fastpath</span>
            <span class="c1"># get an indexer for unique categories then propagate to codes via take_nd</span>
            <span class="c1"># get_indexer instead of _get_indexer needed for MultiIndex cases</span>
            <span class="c1">#  e.g. test_append_different_columns_types</span>
            <span class="n">categories_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">take_nd</span><span class="p">(</span><span class="n">categories_indexer</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span><span class="p">)</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
                <span class="c1"># Exclude MultiIndex because hasnans raises NotImplementedError</span>
                <span class="c1"># we should only get here if we are unique, so loc is an integer</span>
                <span class="c1"># GH#41934</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
                <span class="n">indexer</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>

            <span class="k">return</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

        <span class="n">pself</span><span class="p">,</span> <span class="n">ptarget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_promote</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pself</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">or</span> <span class="n">ptarget</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pself</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span>
                <span class="n">ptarget</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="c1"># Only call equals if we have same dtype to avoid inference/casting</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_partial_index</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="c1"># _should_partial_index e.g. IntervalIndex with numeric scalars</span>
            <span class="c1">#  that can be matched to Interval scalars.</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_common_type_compat</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">_get_indexer</span><span class="p">(</span>
                <span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">str_t</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_tolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;backfill&quot;</span><span class="p">]:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fill_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nearest_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
                <span class="n">engine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span>
                <span class="c1"># error: Item &quot;IndexEngine&quot; of &quot;Union[IndexEngine, ExtensionEngine]&quot;</span>
                <span class="c1"># has no attribute &quot;_extract_level_codes&quot;</span>
                <span class="n">tgt_values</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">_extract_level_codes</span><span class="p">(</span>  <span class="c1"># type: ignore[union-attr]</span>
                    <span class="n">target</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tgt_values</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">_get_engine_target</span><span class="p">()</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">tgt_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_should_partial_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Should we attempt partial-matching indexing?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># See https://github.com/pandas-dev/pandas/issues/47772 the commented</span>
            <span class="c1"># out code can be restored (instead of hardcoding `return True`)</span>
            <span class="c1"># once that issue is fixed</span>
            <span class="c1"># &quot;Index&quot; has no attribute &quot;left&quot;</span>
            <span class="c1"># return self.left._should_compare(target)  # type: ignore[attr-defined]</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_check_indexing_method</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">str_t</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise if we have a get_indexer `method` that is not supported or valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">,</span> <span class="s2">&quot;backfill&quot;</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">]:</span>
            <span class="c1"># in practice the clean_reindex_fill_method call would raise</span>
            <span class="c1">#  before we get here</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid fill method&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;method=&#39;nearest&#39; not implemented yet &quot;</span>
                    <span class="s2">&quot;for MultiIndex; see GitHub issue 9365&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;backfill&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;tolerance not implemented yet for MultiIndex&quot;</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># GH#37871 for now this is only for IntervalIndex and CategoricalIndex</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> not yet implemented for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;tolerance argument only valid if doing pad, &quot;</span>
                    <span class="s2">&quot;backfill or nearest reindexing&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;limit argument only valid if doing pad, &quot;</span>
                    <span class="s2">&quot;backfill or nearest reindexing&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert_tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># override this method on subclasses</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">tolerance</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">tolerance</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;list-like tolerance size must match target index size&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">tolerance</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tolerance</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;tolerance argument for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with dtype &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> must contain numeric elements if it is list type&quot;</span>
                <span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;tolerance argument for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with dtype </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;must be numeric if it is a scalar: </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">tolerance</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_fill_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="n">str_t</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="c1"># TODO: get_indexer_with_fill docstring says values must be _sorted_</span>
            <span class="c1">#  but that doesn&#39;t appear to be enforced</span>
            <span class="c1"># error: &quot;IndexEngine&quot; has no attribute &quot;get_indexer_with_fill&quot;</span>
            <span class="n">engine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="c1"># TODO: We need to fix this. Casting to int64 in cython</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">engine</span><span class="o">.</span><span class="n">get_indexer_with_fill</span><span class="p">(</span>  <span class="c1"># type: ignore[union-attr]</span>
                    <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
                    <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                    <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="n">target_values</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">_get_engine_target</span><span class="p">()</span>
            <span class="n">own_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_engine_target</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">own_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pad&quot;</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">libalgos</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">own_values</span><span class="p">,</span> <span class="n">target_values</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># i.e. &quot;backfill&quot;</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">libalgos</span><span class="o">.</span><span class="n">backfill</span><span class="p">(</span><span class="n">own_values</span><span class="p">,</span> <span class="n">target_values</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fill_indexer_searchsorted</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_indexer_tolerance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indexer</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_fill_indexer_searchsorted</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="n">str_t</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fallback pad/backfill get_indexer that works for monotonic decreasing</span>
<span class="sd">        indexes and non-monotonic targets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;limit argument for </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="si">}</span><span class="s2"> method only well-defined &quot;</span>
                <span class="s2">&quot;if index and target are monotonic&quot;</span>
            <span class="p">)</span>

        <span class="n">side</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pad&quot;</span> <span class="k">else</span> <span class="s2">&quot;right&quot;</span>

        <span class="c1"># find exact matches first (this simplifies the algorithm)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">nonexact</span> <span class="o">=</span> <span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">indexer</span><span class="p">[</span><span class="n">nonexact</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_searchsorted_monotonic</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="n">nonexact</span><span class="p">],</span> <span class="n">side</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
            <span class="c1"># searchsorted returns &quot;indices into a sorted array such that,</span>
            <span class="c1"># if the corresponding elements in v were inserted before the</span>
            <span class="c1"># indices, the order of a would be preserved&quot;.</span>
            <span class="c1"># Thus, we need to subtract 1 to find values to the left.</span>
            <span class="n">indexer</span><span class="p">[</span><span class="n">nonexact</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># This also mapped not found values (values of 0 from</span>
            <span class="c1"># np.searchsorted) to -1, which conveniently is also our</span>
            <span class="c1"># sentinel for missing values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mark indices to the right of the largest value as not found</span>
            <span class="n">indexer</span><span class="p">[</span><span class="n">indexer</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">indexer</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_nearest_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the indexer for the nearest index labels; requires an index with</span>
<span class="sd">        values that can be subtracted from each other (e.g., not strings or</span>
<span class="sd">        tuples).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fill_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">)</span>

        <span class="n">left_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="n">right_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;backfill&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="n">left_distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_difference_compat</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">left_indexer</span><span class="p">)</span>
        <span class="n">right_distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_difference_compat</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">right_indexer</span><span class="p">)</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="c1"># error: Argument 1&amp;2 has incompatible type &quot;Union[ExtensionArray,</span>
            <span class="c1"># ndarray[Any, Any]]&quot;; expected &quot;Union[SupportsDunderLE,</span>
            <span class="c1"># SupportsDunderGE, SupportsDunderGT, SupportsDunderLT]&quot;</span>
            <span class="n">op</span><span class="p">(</span><span class="n">left_distances</span><span class="p">,</span> <span class="n">right_distances</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="o">|</span> <span class="p">(</span><span class="n">right_indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">left_indexer</span><span class="p">,</span>
            <span class="n">right_indexer</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_indexer_tolerance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indexer</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_filter_indexer_tolerance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span>
        <span class="n">indexer</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span>
        <span class="n">tolerance</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_difference_compat</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">indexer</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_difference_compat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
        <span class="c1"># Compatibility for PeriodArray, for which __sub__ returns an ndarray[object]</span>
        <span class="c1">#  of DateOffset objects, which do not support __abs__ (and would be slow</span>
        <span class="c1">#  if they did)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">PeriodDtype</span><span class="p">):</span>
            <span class="c1"># Note: we only get here with matching dtypes</span>
            <span class="n">own_values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;PeriodArray&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="o">.</span><span class="n">_ndarray</span>
            <span class="n">target_values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;PeriodArray&quot;</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="o">.</span><span class="n">_ndarray</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">own_values</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># error: Unsupported left operand type for - (&quot;ExtensionArray&quot;)</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="o">.</span><span class="n">_values</span>  <span class="c1"># type: ignore[operator]</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Indexer Conversion Methods</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_validate_positional_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For positional indexing, a slice must have either int or None</span>
<span class="sd">        for each of start, stop, and step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s2">&quot;positional&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot;iloc&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s2">&quot;positional&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;iloc&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s2">&quot;positional&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="s2">&quot;iloc&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert_slice_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">str_t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a slice indexer.</span>

<span class="sd">        By definition, these are labels unless &#39;iloc&#39; is passed in.</span>
<span class="sd">        Floats are not allowed as the start, step, or stop of the slice.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : label of the slice bound</span>
<span class="sd">        kind : {&#39;loc&#39;, &#39;getitem&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;getitem&quot;</span><span class="p">],</span> <span class="n">kind</span>

        <span class="c1"># potentially cast the bounds to integers</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span>

        <span class="c1"># TODO(GH#50617): once Series.__[gs]etitem__ is removed we should be able</span>
        <span class="c1">#  to simplify this.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># We always treat __getitem__ slicing as label-based</span>
            <span class="c1"># translate to locations</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_indexer</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

        <span class="c1"># figure out if this is a positional indexer</span>
        <span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">is_index_slice</span> <span class="o">=</span> <span class="n">is_int</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_int</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_int</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

        <span class="c1"># special case for interval_dtype bc we do not do partial-indexing</span>
        <span class="c1">#  on integer Intervals when slicing</span>
        <span class="c1"># TODO: write this in terms of e.g. should_partial_index?</span>
        <span class="n">ints_are_positional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_fallback_to_positional</span> <span class="ow">or</span> <span class="n">is_interval_dtype</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">is_positional</span> <span class="o">=</span> <span class="n">is_index_slice</span> <span class="ow">and</span> <span class="n">ints_are_positional</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;getitem&quot;</span><span class="p">:</span>
            <span class="c1"># called from the getitem slicers, validate that we are in fact integers</span>
            <span class="k">if</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_index_slice</span><span class="p">:</span>
                <span class="c1"># Note: these checks are redundant if we know is_index_slice</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s2">&quot;slice&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot;getitem&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s2">&quot;slice&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;getitem&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s2">&quot;slice&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="s2">&quot;getitem&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">key</span>

        <span class="c1"># convert the slice to an indexer here</span>

        <span class="c1"># if we are mixed and have integers</span>
        <span class="k">if</span> <span class="n">is_positional</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Validate start &amp; stop</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
                <span class="n">is_positional</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_null_slice</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># It doesn&#39;t matter if we are positional or label based</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">elif</span> <span class="n">is_positional</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span>
                <span class="c1"># GH#16121, GH#24612, GH#31810</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Slicing a positional slice with .loc is not allowed, &quot;</span>
                    <span class="s2">&quot;Use .loc with labels or .iloc with positions instead.&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_indexer</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">indexer</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_raise_invalid_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">form</span><span class="p">:</span> <span class="n">str_t</span><span class="p">,</span>
        <span class="n">key</span><span class="p">,</span>
        <span class="n">reraise</span><span class="p">:</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="ne">Exception</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise consistent invalid indexer message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;cannot do </span><span class="si">{</span><span class="n">form</span><span class="si">}</span><span class="s2"> indexing on </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with these &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;indexers [</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">] of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">reraise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">reraise</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Reindex Methods</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_validate_can_reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexer</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if we are allowing reindexing with this particular indexer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexer : an integer ndarray</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if its a duplicate axis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># trying to reindex on an axis with duplicates</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_as_unique</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot reindex on an axis with duplicate labels&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Index.reindex"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.reindex">[docs]</a>    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create index with target&#39;s values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : an iterable</span>
<span class="sd">        method : {None, &#39;pad&#39;/&#39;ffill&#39;, &#39;backfill&#39;/&#39;bfill&#39;, &#39;nearest&#39;}, optional</span>
<span class="sd">            * default: exact matches only.</span>
<span class="sd">            * pad / ffill: find the PREVIOUS index value if no exact match.</span>
<span class="sd">            * backfill / bfill: use NEXT index value if no exact match</span>
<span class="sd">            * nearest: use the NEAREST index value if no exact match. Tied</span>
<span class="sd">              distances are broken by preferring the larger index value.</span>
<span class="sd">        level : int, optional</span>
<span class="sd">            Level of multiindex.</span>
<span class="sd">        limit : int, optional</span>
<span class="sd">            Maximum number of consecutive labels in ``target`` to match for</span>
<span class="sd">            inexact matches.</span>
<span class="sd">        tolerance : int or float, optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations must</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>

<span class="sd">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="sd">            to all values, or list-like, which applies variable tolerance per</span>
<span class="sd">            element. List-like includes list, tuple, array, Series, and must be</span>
<span class="sd">            the same size as the index and its dtype must exactly match the</span>
<span class="sd">            index&#39;s type.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_index : pd.Index</span>
<span class="sd">            Resulting index.</span>
<span class="sd">        indexer : np.ndarray[np.intp] or None</span>
<span class="sd">            Indices of output values in original index.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If ``method`` passed along with ``level``.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If non-unique multi-index</span>
<span class="sd">        ValueError</span>
<span class="sd">            If non-unique index and ``method`` or ``limit`` passed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.reindex : Conform Series to new index with optional filling logic.</span>
<span class="sd">        DataFrame.reindex : Conform DataFrame to new index with optional filling logic.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;car&#39;, &#39;bike&#39;, &#39;train&#39;, &#39;tractor&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([&#39;car&#39;, &#39;bike&#39;, &#39;train&#39;, &#39;tractor&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.reindex([&#39;car&#39;, &#39;bike&#39;])</span>
<span class="sd">        (Index([&#39;car&#39;, &#39;bike&#39;], dtype=&#39;object&#39;), array([0, 1]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># GH6552: preserve names when reindexing to non-named target</span>
        <span class="c1"># (i.e. neither Index nor Series).</span>
        <span class="n">preserve_names</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span>

        <span class="c1"># GH7774: preserve dtype/tz if target is empty and not an Index.</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">ensure_has_len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>  <span class="c1"># target may be an iterator</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
                <span class="c1"># &quot;Index&quot; has no attribute &quot;levels&quot;; maybe &quot;nlevels&quot;?</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Fill method not supported if level passed&quot;</span><span class="p">)</span>

            <span class="c1"># TODO: tests where passing `keep_order=not self._is_multi`</span>
            <span class="c1">#  makes a difference for non-MultiIndex case</span>
            <span class="n">target</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_level</span><span class="p">(</span>
                <span class="n">target</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">keep_order</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_as_unique</span><span class="p">:</span>
                    <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span>
                        <span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot handle a non-unique multi-index!&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                    <span class="c1"># GH#42568</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot reindex on an axis with duplicate labels&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indexer</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_reindex_result</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">preserve_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target</span><span class="p">,</span> <span class="n">indexer</span></div>

    <span class="k">def</span> <span class="nf">_wrap_reindex_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">preserve_names</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_preserve_names</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">preserve_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target</span>

    <span class="k">def</span> <span class="nf">_maybe_preserve_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">preserve_names</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">preserve_names</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">target</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">target</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_reindex_non_unique</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new index with target&#39;s values (move/add/delete values as</span>
<span class="sd">        necessary) use with non-unique Index and a possibly non-unique target.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : an iterable</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_index : pd.Index</span>
<span class="sd">            Resulting index.</span>
<span class="sd">        indexer : np.ndarray[np.intp]</span>
<span class="sd">            Indices of output values in original index.</span>
<span class="sd">        new_indexer : np.ndarray[np.intp] or None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># GH#13691</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[:</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span> <span class="kc">None</span>

        <span class="n">indexer</span><span class="p">,</span> <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">indexer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">new_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">[</span><span class="n">check</span><span class="p">])</span>
        <span class="n">new_indexer</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

            <span class="n">missing</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>
            <span class="n">missing_labels</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>
            <span class="n">missing_indexer</span> <span class="o">=</span> <span class="n">length</span><span class="p">[</span><span class="o">~</span><span class="n">check</span><span class="p">]</span>
            <span class="n">cur_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">[</span><span class="n">check</span><span class="p">])</span><span class="o">.</span><span class="n">values</span>
            <span class="n">cur_indexer</span> <span class="o">=</span> <span class="n">length</span><span class="p">[</span><span class="n">check</span><span class="p">]</span>

            <span class="c1"># Index constructor below will do inference</span>
            <span class="n">new_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">new_labels</span><span class="p">[</span><span class="n">cur_indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_labels</span>
            <span class="n">new_labels</span><span class="p">[</span><span class="n">missing_indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">missing_labels</span>

            <span class="c1"># GH#38906</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">new_indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

            <span class="c1"># a unique indexer</span>
            <span class="k">elif</span> <span class="n">target</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                <span class="c1"># see GH5553, make sure we use the right indexer</span>
                <span class="n">new_indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
                <span class="n">new_indexer</span><span class="p">[</span><span class="n">cur_indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cur_labels</span><span class="p">))</span>
                <span class="n">new_indexer</span><span class="p">[</span><span class="n">missing_indexer</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># we have a non_unique selector, need to use the original</span>
            <span class="c1"># indexer here</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># need to retake to have the same size as the indexer</span>
                <span class="n">indexer</span><span class="p">[</span><span class="o">~</span><span class="n">check</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="c1"># reset the new indexer to account for the new size</span>
                <span class="n">new_indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
                <span class="n">new_indexer</span><span class="p">[</span><span class="o">~</span><span class="n">check</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">new_labels</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">new_labels</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">new_indexer</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Join Methods</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">JoinHow</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">return_indexers</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">JoinHow</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">return_indexers</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">JoinHow</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">return_indexers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="o">...</span>

    <span class="nd">@final</span>
    <span class="nd">@_maybe_return_indexers</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">JoinHow</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_indexers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute join_index and indexers to conform data structures to the new index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index</span>
<span class="sd">        how : {&#39;left&#39;, &#39;right&#39;, &#39;inner&#39;, &#39;outer&#39;}</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">        return_indexers : bool, default False</span>
<span class="sd">        sort : bool, default False</span>
<span class="sd">            Sort the join keys lexicographically in the result Index. If False,</span>
<span class="sd">            the order of the join keys depends on the join type (how keyword).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        join_index, (left_indexer, right_indexer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDatetimeIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDatetimeIndex</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Raise instead of casting to object below.</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot join tz-naive with tz-aware DatetimeIndex&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="c1"># We have specific handling for MultiIndex below</span>
            <span class="n">pself</span><span class="p">,</span> <span class="n">pother</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_promote</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pself</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">or</span> <span class="n">pother</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pself</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">pother</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span>
                <span class="p">)</span>

        <span class="n">lindexer</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
        <span class="n">rindexer</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>

        <span class="c1"># try to figure out the join level</span>
        <span class="c1"># GH3662</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">):</span>
            <span class="c1"># have the same levels/names so a simple join</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_multi</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>

        <span class="c1"># join on the level</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_level</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">how</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">):</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>
                <span class="n">rindexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">join_index</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rindexer</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="s2">&quot;cross&quot;</span><span class="p">):</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>
                <span class="n">lindexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">lindexer</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">how</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">):</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>
                <span class="n">lindexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">join_index</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">lindexer</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="s2">&quot;cross&quot;</span><span class="p">):</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>
                <span class="n">rindexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rindexer</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_precedence</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_join_precedence</span><span class="p">:</span>
            <span class="n">flip</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">JoinHow</span><span class="p">,</span> <span class="n">JoinHow</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="s2">&quot;right&quot;</span><span class="p">}</span>
            <span class="n">how</span> <span class="o">=</span> <span class="n">flip</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">how</span><span class="p">)</span>
            <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">ridx</span><span class="p">,</span> <span class="n">lidx</span>
            <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_common_type_compat</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">_validate_join_method</span><span class="p">(</span><span class="n">how</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_non_unique</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="c1"># otherwise we will fall through to _join_via_get_indexer</span>
                    <span class="c1"># GH#39133</span>
                    <span class="c1"># go through object dtype for ea till engine is supported properly</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_monotonic</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_non_unique</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="c1"># GH48504: exclude MultiIndex to avoid going through MultiIndex._values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
            <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_use_libjoin</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Categorical is monotonic if data are ordered as categories, but join can</span>
            <span class="c1">#  not handle this in case of not lexicographically monotonic GH#38502</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_monotonic</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># object dtype; non-comparable objects</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_via_get_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_join_via_get_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="n">JoinHow</span><span class="p">,</span> <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="c1"># Fallback if we do not have any fastpaths available based on</span>
        <span class="c1">#  uniqueness/monotonicity</span>

        <span class="c1"># Note: at this point we have checked matching dtypes</span>

        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;inner&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: sort=False here for backwards compat. It may</span>
            <span class="c1"># be better to use the sort parameter passed into join</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: sort=True here for backwards compat. It may</span>
            <span class="c1"># be better to use the sort parameter passed into join</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="n">join_index</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">join_index</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">lindexer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lindexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">join_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">join_index</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="n">rindexer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rindexer</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">join_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">lindexer</span><span class="p">,</span> <span class="n">rindexer</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_join_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="n">JoinHow</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.merge</span> <span class="kn">import</span> <span class="n">restore_dropped_levels_multijoin</span>

        <span class="c1"># figure out join names</span>
        <span class="n">self_names_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">not_none</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">))</span>
        <span class="n">other_names_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">not_none</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">names</span><span class="p">))</span>
        <span class="n">self_names_order</span> <span class="o">=</span> <span class="n">self_names_list</span><span class="o">.</span><span class="n">index</span>
        <span class="n">other_names_order</span> <span class="o">=</span> <span class="n">other_names_list</span><span class="o">.</span><span class="n">index</span>
        <span class="n">self_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">self_names_list</span><span class="p">)</span>
        <span class="n">other_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other_names_list</span><span class="p">)</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">self_names</span> <span class="o">&amp;</span> <span class="n">other_names</span>

        <span class="c1"># need at least 1 in common</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overlap</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot join with no overlapping index names&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="c1"># Drop the non-matching levels from left and right respectively</span>
            <span class="n">ldrop_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">self_names</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">self_names_order</span><span class="p">)</span>
            <span class="n">rdrop_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">other_names</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">other_names_order</span><span class="p">)</span>

            <span class="c1"># if only the order differs</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">ldrop_names</span> <span class="o">+</span> <span class="n">rdrop_names</span><span class="p">):</span>
                <span class="n">self_jnlevels</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="n">other_jnlevels</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self_jnlevels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">ldrop_names</span><span class="p">)</span>
                <span class="n">other_jnlevels</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">rdrop_names</span><span class="p">)</span>

            <span class="c1"># Join left and right</span>
            <span class="c1"># Join on same leveled multi-index frames is supported</span>
            <span class="n">join_idx</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">self_jnlevels</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">other_jnlevels</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="c1"># Restore the dropped levels</span>
            <span class="c1"># Returned index level order is</span>
            <span class="c1"># common levels, ldrop_names, rdrop_names</span>
            <span class="n">dropped_names</span> <span class="o">=</span> <span class="n">ldrop_names</span> <span class="o">+</span> <span class="n">rdrop_names</span>

            <span class="c1"># error: Argument 5/6 to &quot;restore_dropped_levels_multijoin&quot; has</span>
            <span class="c1"># incompatible type &quot;Optional[ndarray[Any, dtype[signedinteger[Any</span>
            <span class="c1"># ]]]]&quot;; expected &quot;ndarray[Any, dtype[signedinteger[Any]]]&quot;</span>
            <span class="n">levels</span><span class="p">,</span> <span class="n">codes</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">restore_dropped_levels_multijoin</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">other</span><span class="p">,</span>
                <span class="n">dropped_names</span><span class="p">,</span>
                <span class="n">join_idx</span><span class="p">,</span>
                <span class="n">lidx</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">ridx</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="p">)</span>

            <span class="c1"># Re-create the multi-index</span>
            <span class="n">multi_join_idx</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="p">(</span>
                <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">codes</span><span class="o">=</span><span class="n">codes</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="n">multi_join_idx</span> <span class="o">=</span> <span class="n">multi_join_idx</span><span class="o">.</span><span class="n">remove_unused_levels</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">multi_join_idx</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span>

        <span class="n">jl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">overlap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Case where only one index is multi</span>
        <span class="c1"># make the indices into mi&#39;s that match</span>
        <span class="n">flip_order</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span>
            <span class="n">flip_order</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># flip if join method is right or left</span>
            <span class="n">flip</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">JoinHow</span><span class="p">,</span> <span class="n">JoinHow</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="s2">&quot;right&quot;</span><span class="p">}</span>
            <span class="n">how</span> <span class="o">=</span> <span class="n">flip</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">how</span><span class="p">)</span>

        <span class="n">level</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">jl</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_level</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">flip_order</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_join_non_unique</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="n">JoinHow</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]]:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.merge</span> <span class="kn">import</span> <span class="n">get_join_indexers</span>

        <span class="c1"># We only get here if dtypes match</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span> <span class="o">=</span> <span class="n">get_join_indexers</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">],</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">left_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">join_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">left_idx</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">right_idx</span><span class="p">)</span>
        <span class="n">join_index</span> <span class="o">=</span> <span class="n">join_idx</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_join_level</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="n">JoinHow</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">keep_order</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">MultiIndex</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The join method *only* affects the level of the resulting</span>
<span class="sd">        MultiIndex. Otherwise it just exactly aligns the Index data to the</span>
<span class="sd">        labels of the level in the MultiIndex.</span>

<span class="sd">        If ```keep_order == True```, the order of the data indexed by the</span>
<span class="sd">        MultiIndex will not be changed; otherwise, it will tie out</span>
<span class="sd">        with `other`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

        <span class="k">def</span> <span class="nf">_get_leaf_sorter</span><span class="p">(</span><span class="n">labels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns sorter for the inner most level while preserving the</span>
<span class="sd">            order of higher levels.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            labels : list[np.ndarray]</span>
<span class="sd">                Each ndarray has signed integer dtype, not necessarily identical.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            np.ndarray[np.intp]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">get_group_index_sorter</span><span class="p">(</span><span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="c1"># find indexers of beginning of each set of</span>
            <span class="c1"># same-key labels w.r.t all but last level</span>
            <span class="n">tic</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">tic</span> <span class="o">|=</span> <span class="n">lab</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">lab</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(([</span><span class="kc">True</span><span class="p">],</span> <span class="n">tic</span><span class="p">,</span> <span class="p">[</span><span class="kc">True</span><span class="p">]))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lab</span> <span class="o">=</span> <span class="n">ensure_int64</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">get_level_sorter</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">starts</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Join on level between two MultiIndex objects is ambiguous&quot;</span><span class="p">)</span>

        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>

        <span class="n">flip_order</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flip_order</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">,</span> <span class="n">left</span>
            <span class="n">flip</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">JoinHow</span><span class="p">,</span> <span class="n">JoinHow</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="s2">&quot;right&quot;</span><span class="p">}</span>
            <span class="n">how</span> <span class="o">=</span> <span class="n">flip</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">how</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>

        <span class="n">level</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">old_level</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Index._join_level on non-unique index is not implemented&quot;</span>
            <span class="p">)</span>

        <span class="n">new_level</span><span class="p">,</span> <span class="n">left_lev_indexer</span><span class="p">,</span> <span class="n">right_lev_indexer</span> <span class="o">=</span> <span class="n">old_level</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">right</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">left_lev_indexer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keep_order</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">left_indexer</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># sort the leaves</span>
                <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">_get_leaf_sorter</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">codes</span><span class="p">[:</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">left_indexer</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">left_lev_indexer</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">left_lev_indexer</span><span class="p">)</span>
            <span class="n">rev_indexer</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">get_reverse_indexer</span><span class="p">(</span><span class="n">left_lev_indexer</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_level</span><span class="p">))</span>
            <span class="n">old_codes</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>

            <span class="n">taker</span> <span class="o">=</span> <span class="n">old_codes</span><span class="p">[</span><span class="n">old_codes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">new_lev_codes</span> <span class="o">=</span> <span class="n">rev_indexer</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">taker</span><span class="p">)</span>

            <span class="n">new_codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>
            <span class="n">new_codes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_lev_codes</span>

            <span class="n">new_levels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
            <span class="n">new_levels</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_level</span>

            <span class="k">if</span> <span class="n">keep_order</span><span class="p">:</span>  <span class="c1"># just drop missing values. o.w. keep order</span>
                <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
                <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">left_indexer</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">new_lev_codes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">new_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">new_codes</span><span class="p">]</span>
                    <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">left_indexer</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># tie out the order with other</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># outer most level, take the fast route</span>
                    <span class="n">max_new_lev</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_lev_codes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">new_lev_codes</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="n">ngroups</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max_new_lev</span>
                    <span class="n">left_indexer</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">libalgos</span><span class="o">.</span><span class="n">groupsort_indexer</span><span class="p">(</span>
                        <span class="n">new_lev_codes</span><span class="p">,</span> <span class="n">ngroups</span>
                    <span class="p">)</span>

                    <span class="c1"># missing values are placed first; drop them!</span>
                    <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">left_indexer</span><span class="p">[</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:]</span>
                    <span class="n">new_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="n">left_indexer</span><span class="p">]</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">new_codes</span><span class="p">]</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># sort the leaves</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">new_lev_codes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">mask_all</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">mask_all</span><span class="p">:</span>
                        <span class="n">new_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">new_codes</span><span class="p">]</span>

                    <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">_get_leaf_sorter</span><span class="p">(</span><span class="n">new_codes</span><span class="p">[:</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">new_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="n">left_indexer</span><span class="p">]</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">new_codes</span><span class="p">]</span>

                    <span class="c1"># left_indexers are w.r.t masked frame.</span>
                    <span class="c1"># reverse to original frame!</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">mask_all</span><span class="p">:</span>
                        <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="n">left_indexer</span><span class="p">]</span>

            <span class="n">join_index</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="p">(</span>
                <span class="n">levels</span><span class="o">=</span><span class="n">new_levels</span><span class="p">,</span>
                <span class="n">codes</span><span class="o">=</span><span class="n">new_codes</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">names</span><span class="p">,</span>
                <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">right_lev_indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">right_indexer</span> <span class="o">=</span> <span class="n">right_lev_indexer</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">join_index</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right_indexer</span> <span class="o">=</span> <span class="n">join_index</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">flip_order</span><span class="p">:</span>
            <span class="n">left_indexer</span><span class="p">,</span> <span class="n">right_indexer</span> <span class="o">=</span> <span class="n">right_indexer</span><span class="p">,</span> <span class="n">left_indexer</span>

        <span class="n">left_indexer</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="n">left_indexer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">left_indexer</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">right_indexer</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="n">right_indexer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">right_indexer</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">left_indexer</span><span class="p">,</span> <span class="n">right_indexer</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_join_monotonic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="n">JoinHow</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="c1"># We only get here with matching dtypes and both monotonic increasing</span>
        <span class="k">assert</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c1"># This is a convenient place for this check, but its correctness</span>
            <span class="c1">#  does not depend on monotonicity, so it could go earlier</span>
            <span class="c1">#  in the calling method.</span>
            <span class="n">ret_index</span> <span class="o">=</span> <span class="n">other</span> <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span> <span class="k">else</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">ret_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">ridx</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
        <span class="n">lidx</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="c1"># We can perform much better than the general case</span>
            <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="n">lidx</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_indexer_unique</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="n">other</span>
                <span class="n">lidx</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_left_indexer_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;inner&quot;</span><span class="p">:</span>
                <span class="n">join_array</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_joined_index</span><span class="p">(</span><span class="n">join_array</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span><span class="p">:</span>
                <span class="n">join_array</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outer_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_joined_index</span><span class="p">(</span><span class="n">join_array</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="n">join_array</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                <span class="n">join_array</span><span class="p">,</span> <span class="n">ridx</span><span class="p">,</span> <span class="n">lidx</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_left_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;inner&quot;</span><span class="p">:</span>
                <span class="n">join_array</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span><span class="p">:</span>
                <span class="n">join_array</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outer_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">ridx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_joined_index</span><span class="p">(</span><span class="n">join_array</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span><span class="p">)</span>

        <span class="n">lidx</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">lidx</span><span class="p">)</span>
        <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ridx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">ridx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span>

    <span class="k">def</span> <span class="nf">_wrap_joined_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span>
        <span class="n">joined</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span>
        <span class="n">lidx</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span>
        <span class="n">ridx</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">names</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="c1"># error: Incompatible return value type (got &quot;MultiIndex&quot;,</span>
            <span class="c1"># expected &quot;_IndexT&quot;)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">lidx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">join_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">lidx</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ridx</span><span class="p">)</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="n">join_idx</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">join_index</span><span class="o">.</span><span class="n">set_names</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># type: ignore[return-value]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="o">.</span><span class="n">_with_infer</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_can_use_libjoin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether we can use the fastpaths implement in _libs.join</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Index</span><span class="p">:</span>
            <span class="c1"># excludes EAs, but include masks, we get here with monotonic</span>
            <span class="c1"># values only, meaning no NA</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">BaseMaskedArray</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">ArrowExtensionArray</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Uncategorized Methods</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array representing the data in the Index.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           We recommend using :attr:`Index.array` or</span>
<span class="sd">           :meth:`Index.to_numpy`, depending on whether you need</span>
<span class="sd">           a reference to the underlying data or a NumPy array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array: numpy.ndarray or ExtensionArray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.array : Reference to the underlying data.</span>
<span class="sd">        Index.to_numpy : A NumPy array representing the underlying data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@cache_readonly</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">IndexOpsMixin</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtensionArray</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.core.arrays.numpy_</span> <span class="kn">import</span> <span class="n">PandasArray</span>

            <span class="n">array</span> <span class="o">=</span> <span class="n">PandasArray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">array</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtensionArray</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The best array representation.</span>

<span class="sd">        This is an ndarray or ExtensionArray.</span>

<span class="sd">        ``_values`` are consistent between ``Series`` and ``Index``.</span>

<span class="sd">        It may differ from the public &#39;.values&#39; method.</span>

<span class="sd">        index             | values          | _values       |</span>
<span class="sd">        ----------------- | --------------- | ------------- |</span>
<span class="sd">        Index             | ndarray         | ndarray       |</span>
<span class="sd">        CategoricalIndex  | Categorical     | Categorical   |</span>
<span class="sd">        DatetimeIndex     | ndarray[M8ns]   | DatetimeArray |</span>
<span class="sd">        DatetimeIndex[tz] | ndarray[M8ns]   | DatetimeArray |</span>
<span class="sd">        PeriodIndex       | ndarray[object] | PeriodArray   |</span>
<span class="sd">        IntervalIndex     | IntervalArray   | IntervalArray |</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        values : Values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="k">def</span> <span class="nf">_get_engine_target</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the ndarray or ExtensionArray that we can pass to the IndexEngine</span>
<span class="sd">        constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">StringArray</span><span class="p">):</span>
            <span class="c1"># GH#45652 much more performant than ExtensionEngine</span>
            <span class="k">return</span> <span class="n">vals</span><span class="o">.</span><span class="n">_ndarray</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Index</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">BaseMaskedArray</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">ArrowExtensionArray</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="c1"># Exclude decimal</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s2">&quot;O&quot;</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># TODO(ExtensionIndex): remove special-case, just use self._values</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>

    <span class="k">def</span> <span class="nf">_get_join_target</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the ndarray or ExtensionArray that we can pass to the join</span>
<span class="sd">        functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">BaseMaskedArray</span><span class="p">):</span>
            <span class="c1"># This is only used if our array is monotonic, so no NAs present</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">ArrowExtensionArray</span><span class="p">):</span>
            <span class="c1"># This is only used if our array is monotonic, so no missing values</span>
            <span class="c1"># present</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_engine_target</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_from_join_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast the ndarray returned from one of the libjoin.foo_indexer functions</span>
<span class="sd">        back to type(self)._data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">BaseMaskedArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)(</span><span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ArrowExtensionArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Index.memory_usage"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.memory_usage">[docs]</a>    <span class="nd">@doc</span><span class="p">(</span><span class="n">IndexOpsMixin</span><span class="o">.</span><span class="n">_memory_usage</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">memory_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>

        <span class="c1"># include our engine hashtable</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Index.where"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.where">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace values where the condition is False.</span>

<span class="sd">        The replacement is taken from other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cond : bool array-like with the same length as self</span>
<span class="sd">            Condition to select the values on.</span>
<span class="sd">        other : scalar, or array-like, default None</span>
<span class="sd">            Replacement if the condition is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Index</span>
<span class="sd">            A copy of self with values replaced from other</span>
<span class="sd">            where the condition is False.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.where : Same method for Series.</span>
<span class="sd">        DataFrame.where : Same method for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;car&#39;, &#39;bike&#39;, &#39;train&#39;, &#39;tractor&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([&#39;car&#39;, &#39;bike&#39;, &#39;train&#39;, &#39;tractor&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.where(idx.isin([&#39;car&#39;, &#39;train&#39;]), &#39;other&#39;)</span>
<span class="sd">        Index([&#39;car&#39;, &#39;other&#39;, &#39;train&#39;, &#39;other&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;.where is not supported for MultiIndex operations&quot;</span>
            <span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="o">~</span><span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="c1"># construction helpers</span>
    <span class="nd">@final</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_raise_scalar_data_error</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># We return the TypeError so that we can raise it from the constructor</span>
        <span class="c1">#  in order to keep mypy happy</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(...) must be called with a collection of some &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;kind, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> was passed&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the value can be inserted into our array without casting,</span>
<span class="sd">        and convert it to an appropriate native type if necessary.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the value cannot be inserted into an array of this dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">]:</span>
            <span class="c1"># return np_can_hold_element(dtype, value)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np_can_hold_element</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">LossySetitemError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="c1"># re-raise as TypeError for consistency</span>
                <span class="k">raise</span> <span class="ne">TypeError</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">can_hold_element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_require_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that this is a scalar value that we can use for setitem-like</span>
<span class="sd">        operations without changing dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;value&#39; must be a scalar, passed: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_is_memory_usage_qualified</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean if we need a qualified .info display.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean indicating whether the provided key is in the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : label</span>
<span class="sd">            The key to check if it is present in the index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether the key search is in the index.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the key is not hashable.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.isin : Returns an ndarray of boolean dtype indicating whether the</span>
<span class="sd">            list-like key is in the index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([1, 2, 3, 4], dtype=&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; 2 in idx</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; 6 in idx</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">OverflowError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># https://github.com/python/typeshed/issues/2148#issuecomment-520783318</span>
    <span class="c1"># Incompatible types in assignment (expression has type &quot;None&quot;, base class</span>
    <span class="c1"># &quot;object&quot; defined the type as &quot;Callable[[object], int]&quot;)</span>
    <span class="fm">__hash__</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>  <span class="c1"># type: ignore[assignment]</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index does not support mutable operations&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override numpy.ndarray&#39;s __getitem__ method to work as desired.</span>

<span class="sd">        This function adds lists and Series as valid boolean indexers</span>
<span class="sd">        (ndarrays only supports ndarray with dtype=bool).</span>

<span class="sd">        If resulting ndim != 1, plain ndarray is returned instead of</span>
<span class="sd">        corresponding `Index` subclass.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">getitem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__getitem__</span>

        <span class="k">if</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_float</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># GH#44051 exclude bool, which would return a 2d ndarray</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">cast_scalar_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="c1"># This case is separated from the conditional above to avoid</span>
            <span class="c1"># pessimization com.is_bool_indexer and ndim checks.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># Going through simple_new for performance.</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">refs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_references</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># if we have list[bools, length=1e5] then doing this check+convert</span>
            <span class="c1">#  takes 166 µs + 2.1 ms and cuts the ndarray.__getitem__</span>
            <span class="c1">#  time below from 3.8 ms to 496 µs</span>
            <span class="c1"># if we already have ndarray[bool], the overhead is 1.4 µs or .25%</span>
            <span class="k">if</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">na_value</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="c1"># Because we ruled out integer above, we always get an arraylike here</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">disallow_ndim_indexing</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="c1"># NB: Using _constructor._simple_new would break if MultiIndex</span>
        <span class="c1">#  didn&#39;t override __getitem__</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getitem_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">slobj</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fastpath for __getitem__ when we know we have a slice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">refs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_references</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_can_hold_identifiers_and_holds_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Faster check for ``name in self`` when we know `name` is a Python</span>
<span class="sd">        identifier (e.g. in NDFrame.__getattr__, which hits this to support</span>
<span class="sd">        . key lookup). For indexes that can&#39;t hold identifiers (everything</span>
<span class="sd">        but object &amp; categorical) we just return False.</span>

<span class="sd">        https://github.com/pandas-dev/pandas/issues/19764</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_string_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Index.append"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Index</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a collection of Index options together.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or list/tuple of indices</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">to_concat</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># error: Argument 1 to &quot;append&quot; of &quot;list&quot; has incompatible type</span>
            <span class="c1"># &quot;Union[Index, Sequence[Index]]&quot;; expected &quot;Index&quot;</span>
            <span class="n">to_concat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;all inputs must be Index&quot;</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">}</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concat</span><span class="p">(</span><span class="n">to_concat</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_concat</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Index</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate multiple Index objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_concat_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_values</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">concat_compat</span><span class="p">(</span><span class="n">to_concat_vals</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Index</span><span class="o">.</span><span class="n">_with_infer</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="Index.putmask"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.putmask">[docs]</a>    <span class="k">def</span> <span class="nf">putmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Index of the values set with the mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.putmask : Changes elements of an array</span>
<span class="sd">            based on conditional and input values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span><span class="p">,</span> <span class="n">noop</span> <span class="o">=</span> <span class="n">validate_putmask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">noop</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span> <span class="ow">and</span> <span class="n">is_valid_na_for_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># e.g. None -&gt; np.nan, see also Block._standardize_fill_value</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">converted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_fill_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">LossySetitemError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span> <span class="n">err</span>

            <span class="c1"># See also: Block.coerce_to_target_dtype</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_common_type_compat</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">converted</span> <span class="o">=</span> <span class="n">setitem_datetimelike_compat</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">converted</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">converted</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Note: we use the original value here, not converted, as</span>
            <span class="c1">#  _validate_fill_value is not idempotent</span>
            <span class="n">values</span><span class="o">.</span><span class="n">_putmask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.equals"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.equals">[docs]</a>    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if two Index object are equal.</span>

<span class="sd">        The things that are being compared are:</span>

<span class="sd">        * The elements inside the Index object.</span>
<span class="sd">        * The order of the elements inside the Index object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Any</span>
<span class="sd">            The other object to compare against.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if &quot;other&quot; is an Index and it has the same elements and order</span>
<span class="sd">            as the calling index; False otherwise.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; idx1</span>
<span class="sd">        Index([1, 2, 3], dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx1.equals(pd.Index([1, 2, 3]))</span>
<span class="sd">        True</span>

<span class="sd">        The elements inside are compared</span>

<span class="sd">        &gt;&gt;&gt; idx2 = pd.Index([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; idx2</span>
<span class="sd">        Index([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx1.equals(idx2)</span>
<span class="sd">        False</span>

<span class="sd">        The order is compared</span>

<span class="sd">        &gt;&gt;&gt; ascending_idx = pd.Index([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; ascending_idx</span>
<span class="sd">        Index([1, 2, 3], dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; descending_idx = pd.Index([3, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; descending_idx</span>
<span class="sd">        Index([3, 2, 1], dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ascending_idx.equals(descending_idx)</span>
<span class="sd">        False</span>

<span class="sd">        The dtype is *not* compared</span>

<span class="sd">        &gt;&gt;&gt; int64_idx = pd.Index([1, 2, 3], dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; int64_idx</span>
<span class="sd">        Index([1, 2, 3], dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; uint64_idx = pd.Index([1, 2, 3], dtype=&#39;uint64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; uint64_idx</span>
<span class="sd">        Index([1, 2, 3], dtype=&#39;uint64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; int64_idx.equals(uint64_idx)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># if other is not object, use other&#39;s logic for coercion</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="c1"># d-level MultiIndex can equal d-tuple Index</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
            <span class="c1"># Dispatch to the ExtensionArray&#39;s .equals method.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">earr</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ExtensionArray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">earr</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># All EA-backed Index subclasses override equals</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">array_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.identical"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.identical">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">identical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to equals, but checks that object attributes and types are also equal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            If two Index objects have equal elements and same type True,</span>
<span class="sd">            otherwise False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comparables</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Index.asof"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.asof">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">asof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the label from the index, or, if not present, the previous one.</span>

<span class="sd">        Assuming that the index is sorted, return the passed index label if it</span>
<span class="sd">        is in the index, or return the previous index label if the passed one</span>
<span class="sd">        is not in the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">            The label up to which the method returns the latest index label.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            The passed label if it is in the index. The previous label if the</span>
<span class="sd">            passed label is not in the sorted index or `NaN` if there is no</span>
<span class="sd">            such label.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.asof : Return the latest value in a Series up to the</span>
<span class="sd">            passed index.</span>
<span class="sd">        merge_asof : Perform an asof merge (similar to left join but it</span>
<span class="sd">            matches on nearest key rather than equal key).</span>
<span class="sd">        Index.get_loc : An `asof` is a thin wrapper around `get_loc`</span>
<span class="sd">            with method=&#39;pad&#39;.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        `Index.asof` returns the latest index label up to the passed label.</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;2013-12-31&#39;, &#39;2014-01-02&#39;, &#39;2014-01-03&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.asof(&#39;2014-01-01&#39;)</span>
<span class="sd">        &#39;2013-12-31&#39;</span>

<span class="sd">        If the label is in the index, the method returns the passed label.</span>

<span class="sd">        &gt;&gt;&gt; idx.asof(&#39;2014-01-02&#39;)</span>
<span class="sd">        &#39;2014-01-02&#39;</span>

<span class="sd">        If all of the labels in the index are later than the passed label,</span>
<span class="sd">        NaN is returned.</span>

<span class="sd">        &gt;&gt;&gt; idx.asof(&#39;1999-01-02&#39;)</span>
<span class="sd">        nan</span>

<span class="sd">        If the index is not sorted, an error is raised.</span>

<span class="sd">        &gt;&gt;&gt; idx_not_sorted = pd.Index([&#39;2013-12-31&#39;, &#39;2015-01-02&#39;,</span>
<span class="sd">        ...                            &#39;2014-01-03&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx_not_sorted.asof(&#39;2013-12-31&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ValueError: index must be monotonic increasing or decreasing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_searchsorted_monotonic</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>  <span class="c1"># validate sortedness</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="c1"># KeyError -&gt; No exact match, try for padded</span>
            <span class="c1"># TypeError -&gt; passed e.g. non-hashable, fall through to get</span>
            <span class="c1">#  the tested exception message</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">([</span><span class="n">label</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indexer</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">indexer</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;asof requires scalar valued input&quot;</span><span class="p">)</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span></div>

<div class="viewcode-block" id="Index.asof_locs"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.asof_locs">[docs]</a>    <span class="k">def</span> <span class="nf">asof_locs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the locations (indices) of labels in the index.</span>

<span class="sd">        As in the `asof` function, if the label (a particular entry in</span>
<span class="sd">        `where`) is not in the index, the latest index label up to the</span>
<span class="sd">        passed label is chosen and its index returned.</span>

<span class="sd">        If all of the labels in the index are later than a label in `where`,</span>
<span class="sd">        -1 is returned.</span>

<span class="sd">        `mask` is used to ignore NA values in the index during calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : Index</span>
<span class="sd">            An Index consisting of an array of timestamps.</span>
<span class="sd">        mask : np.ndarray[bool]</span>
<span class="sd">            Array of booleans denoting where values in the original</span>
<span class="sd">            data are not NA.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray[np.intp]</span>
<span class="sd">            An array of locations (indices) of the labels from the Index</span>
<span class="sd">            which correspond to the return values of the `asof` function</span>
<span class="sd">            for every element in `where`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># error: No overload variant of &quot;searchsorted&quot; of &quot;ndarray&quot; matches argument</span>
        <span class="c1"># types &quot;Union[ExtensionArray, ndarray[Any, Any]]&quot;, &quot;str&quot;</span>
        <span class="c1"># TODO: will be fixed when ExtensionArray.searchsorted() is fixed</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
            <span class="n">where</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span>  <span class="c1"># type: ignore[call-overload]</span>
        <span class="p">)</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">locs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>

        <span class="n">first_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">mask</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
        <span class="n">result</span><span class="p">[(</span><span class="n">locs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">where</span><span class="o">.</span><span class="n">_values</span> <span class="o">&lt;</span> <span class="n">first_value</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Index.sort_values"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.sort_values">[docs]</a>    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">return_indexer</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="n">str_t</span> <span class="o">=</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a sorted copy of the index.</span>

<span class="sd">        Return a sorted copy of the index, and optionally return the indices</span>
<span class="sd">        that sorted the index itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        return_indexer : bool, default False</span>
<span class="sd">            Should the indices that would sort the index be returned.</span>
<span class="sd">        ascending : bool, default True</span>
<span class="sd">            Should the index values be sorted in an ascending order.</span>
<span class="sd">        na_position : {&#39;first&#39; or &#39;last&#39;}, default &#39;last&#39;</span>
<span class="sd">            Argument &#39;first&#39; puts NaNs at the beginning, &#39;last&#39; puts NaNs at</span>
<span class="sd">            the end.</span>

<span class="sd">            .. versionadded:: 1.2.0</span>

<span class="sd">        key : callable, optional</span>
<span class="sd">            If not None, apply the key function to the index values</span>
<span class="sd">            before sorting. This is similar to the `key` argument in the</span>
<span class="sd">            builtin :meth:`sorted` function, with the notable difference that</span>
<span class="sd">            this `key` function should be *vectorized*. It should expect an</span>
<span class="sd">            ``Index`` and return an ``Index`` of the same shape.</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted_index : pandas.Index</span>
<span class="sd">            Sorted copy of the index.</span>
<span class="sd">        indexer : numpy.ndarray, optional</span>
<span class="sd">            The indices that the index itself was sorted by.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.sort_values : Sort values of a Series.</span>
<span class="sd">        DataFrame.sort_values : Sort values in a DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([10, 100, 1, 1000])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([10, 100, 1, 1000], dtype=&#39;int64&#39;)</span>

<span class="sd">        Sort values in ascending order (default behavior).</span>

<span class="sd">        &gt;&gt;&gt; idx.sort_values()</span>
<span class="sd">        Index([1, 10, 100, 1000], dtype=&#39;int64&#39;)</span>

<span class="sd">        Sort values in descending order, and also get the indices `idx` was</span>
<span class="sd">        sorted by.</span>

<span class="sd">        &gt;&gt;&gt; idx.sort_values(ascending=False, return_indexer=True)</span>
<span class="sd">        (Index([1000, 100, 10, 1], dtype=&#39;int64&#39;), array([3, 1, 0, 2]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">ensure_key_mapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="c1"># GH 35584. Sort missing values according to na_position kwarg</span>
        <span class="c1"># ignore na_position for MultiIndex</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="n">_as</span> <span class="o">=</span> <span class="n">nargsort</span><span class="p">(</span>
                <span class="n">items</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_as</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
                <span class="n">_as</span> <span class="o">=</span> <span class="n">_as</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">sorted_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">_as</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_indexer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sorted_index</span><span class="p">,</span> <span class="n">_as</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sorted_index</span></div>

<div class="viewcode-block" id="Index.sort"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.sort">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use sort_values instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot sort an Index object in-place, use sort_values instead&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.shift"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift index by desired number of time frequency increments.</span>

<span class="sd">        This method is for shifting the values of datetime-like indexes</span>
<span class="sd">        by a specified time increment a given number of times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int, default 1</span>
<span class="sd">            Number of periods (or increments) to shift by,</span>
<span class="sd">            can be positive or negative.</span>
<span class="sd">        freq : pandas.DateOffset, pandas.Timedelta or str, optional</span>
<span class="sd">            Frequency increment to shift by.</span>
<span class="sd">            If None, the index is shifted by its own `freq` attribute.</span>
<span class="sd">            Offset aliases are valid strings, e.g., &#39;D&#39;, &#39;W&#39;, &#39;M&#39; etc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Index</span>
<span class="sd">            Shifted index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.shift : Shift values of Series.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is only implemented for datetime-like index classes,</span>
<span class="sd">        i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Put the first 5 month starts of 2011 into an index.</span>

<span class="sd">        &gt;&gt;&gt; month_starts = pd.date_range(&#39;1/1/2011&#39;, periods=5, freq=&#39;MS&#39;)</span>
<span class="sd">        &gt;&gt;&gt; month_starts</span>
<span class="sd">        DatetimeIndex([&#39;2011-01-01&#39;, &#39;2011-02-01&#39;, &#39;2011-03-01&#39;, &#39;2011-04-01&#39;,</span>
<span class="sd">                       &#39;2011-05-01&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)</span>

<span class="sd">        Shift the index by 10 days.</span>

<span class="sd">        &gt;&gt;&gt; month_starts.shift(10, freq=&#39;D&#39;)</span>
<span class="sd">        DatetimeIndex([&#39;2011-01-11&#39;, &#39;2011-02-11&#39;, &#39;2011-03-11&#39;, &#39;2011-04-11&#39;,</span>
<span class="sd">                       &#39;2011-05-11&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">        The default value of `freq` is the `freq` attribute of the index,</span>
<span class="sd">        which is &#39;MS&#39; (month start) in this example.</span>

<span class="sd">        &gt;&gt;&gt; month_starts.shift(10)</span>
<span class="sd">        DatetimeIndex([&#39;2011-11-01&#39;, &#39;2011-12-01&#39;, &#39;2012-01-01&#39;, &#39;2012-02-01&#39;,</span>
<span class="sd">                       &#39;2012-03-01&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;This method is only implemented for DatetimeIndex, PeriodIndex and &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;TimedeltaIndex; Got type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Index.argsort"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.argsort">[docs]</a>    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the integer indices that would sort the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args</span>
<span class="sd">            Passed to `numpy.ndarray.argsort`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Passed to `numpy.ndarray.argsort`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray[np.intp]</span>
<span class="sd">            Integer indices that would sort the index if used as</span>
<span class="sd">            an indexer.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.argsort : Similar method for NumPy arrays.</span>
<span class="sd">        Index.sort_values : Return sorted copy of Index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;b&#39;, &#39;a&#39;, &#39;d&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([&#39;b&#39;, &#39;a&#39;, &#39;d&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        &gt;&gt;&gt; order = idx.argsort()</span>
<span class="sd">        &gt;&gt;&gt; order</span>
<span class="sd">        array([1, 0, 3, 2])</span>

<span class="sd">        &gt;&gt;&gt; idx[order]</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This works for either ndarray or EA, is overridden</span>
        <span class="c1">#  by RangeIndex, MultIIndex</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_check_indexing_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># if key is not a scalar, directly raise an error (the code below</span>
            <span class="c1"># would convert to numpy arrays and raise later any way) - GH29926</span>
            <span class="k">raise</span> <span class="n">InvalidIndexError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_should_fallback_to_positional</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Should an integer key be treated as positional?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mixed-integer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;floating&quot;</span><span class="p">,</span>
            <span class="s2">&quot;complex&quot;</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="n">_index_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;get_indexer_non_unique&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Compute indexer and mask for new index given the current index.</span>

<span class="s2">        The indexer should be then used as an input to ndarray.take to align the</span>
<span class="s2">        current data to the new index.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        target : </span><span class="si">%(target_klass)s</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        indexer : np.ndarray[np.intp]</span>
<span class="s2">            Integers from 0 to n - 1 indicating that the index at these</span>
<span class="s2">            positions matches the corresponding target values. Missing values</span>
<span class="s2">            in the target are marked by -1.</span>
<span class="s2">        missing : np.ndarray[np.intp]</span>
<span class="s2">            An indexer into the target of the values not found.</span>
<span class="s2">            These correspond to the -1 in the indexer array.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; index = pd.Index([&#39;c&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;])</span>
<span class="s2">        &gt;&gt;&gt; index.get_indexer_non_unique([&#39;b&#39;, &#39;b&#39;])</span>
<span class="s2">        (array([1, 3, 4, 1, 3, 4]), array([], dtype=int64))</span>

<span class="s2">        In the example below there are no matched values.</span>

<span class="s2">        &gt;&gt;&gt; index = pd.Index([&#39;c&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;])</span>
<span class="s2">        &gt;&gt;&gt; index.get_indexer_non_unique([&#39;q&#39;, &#39;r&#39;, &#39;t&#39;])</span>
<span class="s2">        (array([-1, -1, -1]), array([0, 1, 2]))</span>

<span class="s2">        For this reason, the returned ``indexer`` contains only integers equal to -1.</span>
<span class="s2">        It demonstrates that there&#39;s no match between the index and the ``target``</span>
<span class="s2">        values at these positions. The mask [0, 1, 2] in the return value shows that</span>
<span class="s2">        the first, second, and third elements are missing.</span>

<span class="s2">        Notice that the return value is a tuple contains two items. In the example</span>
<span class="s2">        below the first item is an array of locations in ``index``. The second</span>
<span class="s2">        item is a mask shows that the first and third elements are missing.</span>

<span class="s2">        &gt;&gt;&gt; index = pd.Index([&#39;c&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;])</span>
<span class="s2">        &gt;&gt;&gt; index.get_indexer_non_unique([&#39;f&#39;, &#39;b&#39;, &#39;s&#39;])</span>
<span class="s2">        (array([-1,  1,  3,  4, -1]), array([0, 2]))</span>
<span class="s2">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Index.get_indexer_non_unique"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.get_indexer_non_unique">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s2">&quot;get_indexer_non_unique&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_index_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_indexer_non_unique</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]]:</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_listlike_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_compare</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_partial_index</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="c1"># _should_partial_index e.g. IntervalIndex with numeric scalars</span>
            <span class="c1">#  that can be matched to Interval scalars.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_indexer_non_comparable</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">pself</span><span class="p">,</span> <span class="n">ptarget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_promote</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pself</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">or</span> <span class="n">ptarget</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pself</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">ptarget</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># TODO: if object, could use infer_dtype to preempt costly</span>
            <span class="c1">#  conversion if still non-comparable?</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_common_type_compat</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">that</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>

        <span class="c1"># TODO: get_indexer has fastpaths for both Categorical-self and</span>
        <span class="c1">#  Categorical-target. Can we do something similar here?</span>

        <span class="c1"># Note: _maybe_promote ensures we never get here with MultiIndex</span>
        <span class="c1">#  self and non-Multi target</span>
        <span class="n">tgt_values</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">_get_engine_target</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="n">engine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span>
            <span class="c1"># Item &quot;IndexEngine&quot; of &quot;Union[IndexEngine, ExtensionEngine]&quot; has</span>
            <span class="c1"># no attribute &quot;_extract_level_codes&quot;</span>
            <span class="n">tgt_values</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">_extract_level_codes</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>

        <span class="n">indexer</span><span class="p">,</span> <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">tgt_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">indexer</span><span class="p">),</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.get_indexer_for"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.get_indexer_for">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">get_indexer_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Guaranteed return of an indexer even when non-unique.</span>

<span class="sd">        This dispatches to get_indexer or get_indexer_non_unique</span>
<span class="sd">        as appropriate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray[np.intp]</span>
<span class="sd">            List of indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([np.nan, &#39;var1&#39;, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; idx.get_indexer_for([np.nan])</span>
<span class="sd">        array([0, 2])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_as_unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">indexer</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indexer</span></div>

    <span class="k">def</span> <span class="nf">_get_indexer_strict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">:</span> <span class="n">str_t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analogue to get_indexer that raises if any elements are missing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keyarr</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keyarr</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">keyarr</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">asarray_tuplesafe</span><span class="p">(</span><span class="n">keyarr</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_as_unique</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">keyarr</span><span class="p">)</span>
            <span class="n">keyarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">keyarr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keyarr</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">new_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_non_unique</span><span class="p">(</span><span class="n">keyarr</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_missing</span><span class="p">(</span><span class="n">keyarr</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">)</span>

        <span class="n">keyarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="c1"># GH 42790 - Preserve name from an Index</span>
            <span class="n">keyarr</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">keyarr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">]:</span>
            <span class="c1"># DTI/TDI.take can infer a freq in some cases when we dont want one</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="c1"># &quot;Index&quot; has no attribute &quot;freq&quot;</span>
                <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="p">):</span>
                <span class="n">keyarr</span> <span class="o">=</span> <span class="n">keyarr</span><span class="o">.</span><span class="n">_with_freq</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">keyarr</span><span class="p">,</span> <span class="n">indexer</span>

    <span class="k">def</span> <span class="nf">_raise_if_missing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">:</span> <span class="n">str_t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that indexer can be used to return a result.</span>

<span class="sd">        e.g. at least one element was found,</span>
<span class="sd">        unless the list of keys was actually empty.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : list-like</span>
<span class="sd">            Targeted labels (only used to show correct error message).</span>
<span class="sd">        indexer: array-like of booleans</span>
<span class="sd">            Indices corresponding to the key,</span>
<span class="sd">            (with -1 indicating not found).</span>
<span class="sd">        axis_name : str</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If at least one key was requested but none was found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Count missing values</span>
        <span class="n">missing_mask</span> <span class="o">=</span> <span class="n">indexer</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">nmissing</span> <span class="o">=</span> <span class="n">missing_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">nmissing</span><span class="p">:</span>
            <span class="c1"># TODO: remove special-case; this is just to keep exception</span>
            <span class="c1">#  message tests from raising while debugging</span>
            <span class="n">use_interval_msg</span> <span class="o">=</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="c1"># &quot;Index&quot; has no attribute &quot;categories&quot;  [attr-defined]</span>
                <span class="ow">and</span> <span class="n">is_interval_dtype</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">dtype</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">nmissing</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">use_interval_msg</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;None of [</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">] are in the [</span><span class="si">{</span><span class="n">axis_name</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

            <span class="n">not_found</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ensure_index</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="n">missing_mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">not_found</span><span class="si">}</span><span class="s2"> not in index&quot;</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">_get_indexer_non_comparable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">_get_indexer_non_comparable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]]:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">_get_indexer_non_comparable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]]:</span>
        <span class="o">...</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_get_indexer_non_comparable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called from get_indexer or get_indexer_non_unique when the target</span>
<span class="sd">        is of a non-comparable dtype.</span>

<span class="sd">        For get_indexer lookups with method=None, get_indexer is an _equality_</span>
<span class="sd">        check, so non-comparable dtypes mean we will always have no matches.</span>

<span class="sd">        For get_indexer lookups with a method, get_indexer is an _inequality_</span>
<span class="sd">        check, so non-comparable dtypes mean we will always raise TypeError.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : Index</span>
<span class="sd">        method : str or None</span>
<span class="sd">        unique : bool, default True</span>
<span class="sd">            * True if called from get_indexer.</span>
<span class="sd">            * False if called from get_indexer_non_unique.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If doing an inequality check, i.e. method is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">_unpack_nested_dtype</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot compare dtypes </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">no_matches</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="c1"># This is for get_indexer</span>
            <span class="k">return</span> <span class="n">no_matches</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is for get_indexer_non_unique</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">no_matches</span><span class="p">,</span> <span class="n">missing</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_index_as_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether we should treat this as unique for the sake of</span>
<span class="sd">        get_indexer vs get_indexer_non_unique.</span>

<span class="sd">        For IntervalIndex compat.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span>

    <span class="n">_requires_unique_msg</span> <span class="o">=</span> <span class="s2">&quot;Reindexing only valid with uniquely valued Index objects&quot;</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_maybe_promote</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">Index</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When dealing with an object-dtype Index and a non-object Index, see</span>
<span class="sd">        if we can upcast the object-dtype one to improve performance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDatetimeIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDatetimeIndex</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">tz_compare</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="c1"># standardize on UTC</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s2">&quot;UTC&quot;</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s2">&quot;UTC&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s2">&quot;date&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDatetimeIndex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)(</span><span class="bp">self</span><span class="p">),</span> <span class="n">other</span>
            <span class="k">except</span> <span class="n">OutOfBoundsDatetime</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s2">&quot;timedelta&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCTimedeltaIndex</span><span class="p">):</span>
            <span class="c1"># TODO: we dont have tests that get here</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)(</span><span class="bp">self</span><span class="p">),</span> <span class="n">other</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;u&quot;</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
            <span class="c1"># GH#41873</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># lookup min as it may be cached</span>
                <span class="c1"># TODO: may need itemsize check if we have non-64-bit Indexes</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># &quot;Type[Index]&quot; has no attribute &quot;from_tuples&quot;</span>
                <span class="n">other</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="c1"># let&#39;s instead try with a straight Index</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># Reverse op so we dont need to re-implement on the subclasses</span>
            <span class="n">other</span><span class="p">,</span> <span class="bp">self</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_maybe_promote</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_find_common_type_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DtypeObj</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of find_common_type that adjusts for Index-specific</span>
<span class="sd">        special cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">infer_dtype_from</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">pandas_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># special case: if one dtype is uint64 and the other a signed int, return object</span>
        <span class="c1"># See https://github.com/pandas-dev/pandas/issues/26778 for discussion</span>
        <span class="c1"># Now it&#39;s:</span>
        <span class="c1"># * float | [u]int -&gt; float</span>
        <span class="c1"># * uint64 | signed int  -&gt; object</span>
        <span class="c1"># We may change union(float | [u]int) to go to object.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;uint64&quot;</span> <span class="ow">or</span> <span class="n">target_dtype</span> <span class="o">==</span> <span class="s2">&quot;uint64&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_signed_integer_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_signed_integer_dtype</span><span class="p">(</span>
                <span class="n">target_dtype</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">_dtype_obj</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">find_result_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">common_dtype_categorical_compat</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dtype</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_should_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if `self == other` can ever have non-False entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_any_real_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">is_bool_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_any_real_numeric_dtype</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># GH#16877 Treat boolean labels passed to a numeric index as not</span>
            <span class="c1">#  found. Without this fix False and True would be treated as 0 and 1</span>
            <span class="c1">#  respectively.</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">_unpack_nested_dtype</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_comparable_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_comparable_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeObj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Can we compare values of the given dtype to our own?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span>
        <span class="k">elif</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># TODO: this was written assuming we only get here with object-dtype,</span>
        <span class="c1">#  which is nom longer correct. Can we specialize for EA?</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Index.groupby"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.groupby">[docs]</a>    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PrettyDict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Group the index labels by a given array of values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : array</span>
<span class="sd">            Values used to determine the groups.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            {group name -&gt; group labels}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: if we are a MultiIndex, we can do better</span>
        <span class="c1"># that converting to tuples</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">Categorical</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">_reverse_indexer</span><span class="p">()</span>

        <span class="c1"># map to the label</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">return</span> <span class="n">PrettyDict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.map"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map values using an input mapping or function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapper : function, dict, or Series</span>
<span class="sd">            Mapping correspondence.</span>
<span class="sd">        na_action : {None, &#39;ignore&#39;}</span>
<span class="sd">            If &#39;ignore&#39;, propagate NA values, without passing them to the</span>
<span class="sd">            mapping correspondence.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[Index, MultiIndex]</span>
<span class="sd">            The output of the mapping function applied to the index.</span>
<span class="sd">            If the function returns a tuple with more than one element</span>
<span class="sd">            a MultiIndex will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_values</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="n">na_action</span><span class="p">)</span>

        <span class="c1"># we can return a MultiIndex</span>
        <span class="k">if</span> <span class="n">new_values</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new_values</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># empty</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># e.g. if we are floating and new_values is all ints, then we</span>
        <span class="c1">#  don&#39;t want to cast back to floating.  But if we are UInt64</span>
        <span class="c1">#  and new_values is all ints, we want to try.</span>
        <span class="n">same_dtype</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span>
        <span class="k">if</span> <span class="n">same_dtype</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">maybe_cast_pointwise_result</span><span class="p">(</span>
                <span class="n">new_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">same_dtype</span><span class="o">=</span><span class="n">same_dtype</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">Index</span><span class="o">.</span><span class="n">_with_infer</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

    <span class="c1"># TODO: De-duplicate with map, xref GH#32349</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_transform_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply function to all values found in index.</span>

<span class="sd">        This includes transforming multiindex entries separately.</span>
<span class="sd">        Only apply function to one level of the MultiIndex if level is specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">level</span> <span class="ow">or</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tupleize_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="Index.isin"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.isin">[docs]</a>    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean array where the index values are in `values`.</span>

<span class="sd">        Compute boolean array of whether each index value is found in the</span>
<span class="sd">        passed set of values. The length of the returned boolean array matches</span>
<span class="sd">        the length of the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : set or list-like</span>
<span class="sd">            Sought values.</span>
<span class="sd">        level : str or int, optional</span>
<span class="sd">            Name or position of the index level to use (if the index is a</span>
<span class="sd">            `MultiIndex`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray[bool]</span>
<span class="sd">            NumPy array of boolean values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.isin : Same for Series.</span>
<span class="sd">        DataFrame.isin : Same method for DataFrames.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the case of `MultiIndex` you must either specify `values` as a</span>
<span class="sd">        list-like object containing tuples that are the same length as the</span>
<span class="sd">        number of levels, or specify `level`. Otherwise it will raise a</span>
<span class="sd">        ``ValueError``.</span>

<span class="sd">        If `level` is specified:</span>

<span class="sd">        - if it is the name of one *and only one* index level, use that level;</span>
<span class="sd">        - otherwise it should be a number indicating level position.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([1, 2, 3], dtype=&#39;int64&#39;)</span>

<span class="sd">        Check whether each index value in a list of values.</span>

<span class="sd">        &gt;&gt;&gt; idx.isin([1, 4])</span>
<span class="sd">        array([ True, False, False])</span>

<span class="sd">        &gt;&gt;&gt; midx = pd.MultiIndex.from_arrays([[1,2,3],</span>
<span class="sd">        ...                                  [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]],</span>
<span class="sd">        ...                                  names=(&#39;number&#39;, &#39;color&#39;))</span>
<span class="sd">        &gt;&gt;&gt; midx</span>
<span class="sd">        MultiIndex([(1,   &#39;red&#39;),</span>
<span class="sd">                    (2,  &#39;blue&#39;),</span>
<span class="sd">                    (3, &#39;green&#39;)],</span>
<span class="sd">                   names=[&#39;number&#39;, &#39;color&#39;])</span>

<span class="sd">        Check whether the strings in the &#39;color&#39; level of the MultiIndex</span>
<span class="sd">        are in a list of colors.</span>

<span class="sd">        &gt;&gt;&gt; midx.isin([&#39;red&#39;, &#39;orange&#39;, &#39;yellow&#39;], level=&#39;color&#39;)</span>
<span class="sd">        array([ True, False, False])</span>

<span class="sd">        To check across the levels of a MultiIndex, pass a list of tuples:</span>

<span class="sd">        &gt;&gt;&gt; midx.isin([(1, &#39;red&#39;), (3, &#39;red&#39;)])</span>
<span class="sd">        array([ True, False, False])</span>

<span class="sd">        For a DatetimeIndex, string values in `values` are converted to</span>
<span class="sd">        Timestamps.</span>

<span class="sd">        &gt;&gt;&gt; dates = [&#39;2000-03-11&#39;, &#39;2000-03-12&#39;, &#39;2000-03-13&#39;]</span>
<span class="sd">        &gt;&gt;&gt; dti = pd.to_datetime(dates)</span>
<span class="sd">        &gt;&gt;&gt; dti</span>
<span class="sd">        DatetimeIndex([&#39;2000-03-11&#39;, &#39;2000-03-12&#39;, &#39;2000-03-13&#39;],</span>
<span class="sd">        dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">        &gt;&gt;&gt; dti.isin([&#39;2000-03-11&#39;])</span>
<span class="sd">        array([ True, False, False])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">algos</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_string_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">str_t</span><span class="p">):</span>
        <span class="c1"># this is for partial string indexing,</span>
        <span class="c1"># overridden in DatetimeIndex, TimedeltaIndex and PeriodIndex</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="Index.slice_indexer"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.slice_indexer">[docs]</a>    <span class="k">def</span> <span class="nf">slice_indexer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">slice</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the slice indexer for input labels and step.</span>

<span class="sd">        Index needs to be ordered and unique.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : label, default None</span>
<span class="sd">            If None, defaults to the beginning.</span>
<span class="sd">        end : label, default None</span>
<span class="sd">            If None, defaults to the end.</span>
<span class="sd">        step : int, default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        slice</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError : If key does not exist, or key is not unique and index is</span>
<span class="sd">            not ordered.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function assumes that the data is sorted, so use at your own peril</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This is a method on all index types. For example you can do:</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index(list(&#39;abcd&#39;))</span>
<span class="sd">        &gt;&gt;&gt; idx.slice_indexer(start=&#39;b&#39;, end=&#39;c&#39;)</span>
<span class="sd">        slice(1, 3, None)</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([list(&#39;abcd&#39;), list(&#39;efgh&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; idx.slice_indexer(start=&#39;b&#39;, end=(&#39;c&#39;, &#39;g&#39;))</span>
<span class="sd">        slice(1, 3, None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start_slice</span><span class="p">,</span> <span class="n">end_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_locs</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">)</span>

        <span class="c1"># return a slice</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">start_slice</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Start slice bound is non-scalar&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">end_slice</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;End slice bound is non-scalar&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start_slice</span><span class="p">,</span> <span class="n">end_slice</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_maybe_cast_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we have a float key and are not a floating index, then try to cast</span>
<span class="sd">        to an int if equivalent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">_maybe_cast_listlike_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analogue to maybe_cast_indexer for get_indexer instead of get_loc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_validate_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">:</span> <span class="n">str_t</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">str_t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we are positional indexer, validate that we have appropriate</span>
<span class="sd">        typed bounds must be an integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;getitem&quot;</span><span class="p">,</span> <span class="s2">&quot;iloc&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_invalid_indexer</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maybe_cast_slice_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="n">str_t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should be overloaded in subclasses that allow non-trivial</span>
<span class="sd">        casting on label-slice bounds, e.g. datetime-like indices allowing</span>
<span class="sd">        strings containing formatted datetimes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">        side : {&#39;left&#39;, &#39;right&#39;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        label : object</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Value of `side` parameter should be validated in caller.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We are a plain index here (sub-class override this method if they</span>
        <span class="c1"># wish to have special treatment for floats/ints, e.g. datetimelike Indexes</span>

        <span class="k">if</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_indexer</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># reject them, if index does not contain label</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_float</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">label</span><span class="p">))</span> <span class="ow">and</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_invalid_indexer</span><span class="p">(</span><span class="s2">&quot;slice&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_searchsorted_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span><span class="p">:</span>
            <span class="c1"># np.searchsorted expects ascending sort order, have to reverse</span>
            <span class="c1"># everything for it to work (element ordering, search side and</span>
            <span class="c1"># resulting value).</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
                <span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="s2">&quot;left&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;index must be monotonic increasing or decreasing&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Index.get_slice_bound"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.get_slice_bound">[docs]</a>    <span class="k">def</span> <span class="nf">get_slice_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate slice bound that corresponds to given label.</span>

<span class="sd">        Returns leftmost (one-past-the-rightmost if ``side==&#39;right&#39;``) position</span>
<span class="sd">        of given label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">        side : {&#39;left&#39;, &#39;right&#39;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Index of label.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">side</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid value for side kwarg, must be either &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;left&#39; or &#39;right&#39;: </span><span class="si">{</span><span class="n">side</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">original_label</span> <span class="o">=</span> <span class="n">label</span>

        <span class="c1"># For datetime indices label may be a string that has to be converted</span>
        <span class="c1"># to datetime boundary according to its resolution.</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_slice_bound</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>

        <span class="c1"># we need to look up the label</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_searchsorted_monotonic</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># raise the original KeyError</span>
                <span class="k">raise</span> <span class="n">err</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># get_loc may return a boolean array, which</span>
            <span class="c1"># is OK as long as they are representable by a slice.</span>
            <span class="k">assert</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_booleans_to_slice</span><span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;u1&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot get </span><span class="si">{</span><span class="n">side</span><span class="si">}</span><span class="s2"> slice bound for non-unique &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;label: </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">original_label</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slc</span><span class="o">.</span><span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slc</span><span class="o">.</span><span class="n">stop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slc</span></div>

<div class="viewcode-block" id="Index.slice_locs"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.slice_locs">[docs]</a>    <span class="k">def</span> <span class="nf">slice_locs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute slice locations for input labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : label, default None</span>
<span class="sd">            If None, defaults to the beginning.</span>
<span class="sd">        end : label, default None</span>
<span class="sd">            If None, defaults to the end.</span>
<span class="sd">        step : int, defaults None</span>
<span class="sd">            If None, defaults to 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[int, int]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.get_loc : Get location for a single label.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method only works if the index is monotonic or unique.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index(list(&#39;abcd&#39;))</span>
<span class="sd">        &gt;&gt;&gt; idx.slice_locs(start=&#39;b&#39;, end=&#39;c&#39;)</span>
<span class="sd">        (1, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inc</span><span class="p">:</span>
            <span class="c1"># If it&#39;s a reverse slice, temporarily swap bounds.</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">,</span> <span class="n">start</span>

        <span class="c1"># GH 16785: If start and end happen to be date strings with UTC offsets</span>
        <span class="c1"># attempt to parse and check that the offsets are the same</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ts_start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                <span class="n">ts_end</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tz_compare</span><span class="p">(</span><span class="n">ts_start</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">,</span> <span class="n">ts_end</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both dates must have the same UTC offset&quot;</span><span class="p">)</span>

        <span class="n">start_slice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slice_bound</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_slice</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">end_slice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slice_bound</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_slice</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inc</span><span class="p">:</span>
            <span class="c1"># Bounds at this moment are swapped, swap them back and shift by 1.</span>
            <span class="c1">#</span>
            <span class="c1"># slice_locs(&#39;B&#39;, &#39;A&#39;, step=-1): s=&#39;B&#39;, e=&#39;A&#39;</span>
            <span class="c1">#</span>
            <span class="c1">#              s=&#39;A&#39;                 e=&#39;B&#39;</span>
            <span class="c1"># AFTER SWAP:    |                     |</span>
            <span class="c1">#                v ------------------&gt; V</span>
            <span class="c1">#           -----------------------------------</span>
            <span class="c1">#           | | |A|A|A|A| | | | | |B|B| | | | |</span>
            <span class="c1">#           -----------------------------------</span>
            <span class="c1">#              ^ &lt;------------------ ^</span>
            <span class="c1"># SHOULD BE:   |                     |</span>
            <span class="c1">#           end=s-1              start=e-1</span>
            <span class="c1">#</span>
            <span class="n">end_slice</span><span class="p">,</span> <span class="n">start_slice</span> <span class="o">=</span> <span class="n">start_slice</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end_slice</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># i == -1 triggers ``len(self) + i`` selection that points to the</span>
            <span class="c1"># last element, not before-the-first one, subtracting len(self)</span>
            <span class="c1"># compensates that.</span>
            <span class="k">if</span> <span class="n">end_slice</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">end_slice</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start_slice</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">start_slice</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">start_slice</span><span class="p">,</span> <span class="n">end_slice</span></div>

<div class="viewcode-block" id="Index.delete"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.delete">[docs]</a>    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IndexT</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IndexT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new Index with passed location(-s) deleted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : int or list of int</span>
<span class="sd">            Location of item(-s) which will be deleted.</span>
<span class="sd">            Use a list of locations to delete more than one value at the same time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">            Will be same type as self, except for RangeIndex.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.delete : Delete any rows and column from NumPy array (ndarray).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.delete(1)</span>
<span class="sd">        Index([&#39;a&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.delete([0, 2])</span>
<span class="sd">        Index([&#39;b&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">res_values</span><span class="p">:</span> <span class="n">ArrayLike</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># TODO(__array_function__): special casing will be unnecessary</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>

        <span class="c1"># _constructor so RangeIndex-&gt; Index with an int64 dtype</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.insert"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new Index inserting new item at location.</span>

<span class="sd">        Follows Python numpy.insert semantics for negative values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : int</span>
<span class="sd">        item : object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">item_from_zerodim</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_valid_na_for_dtype</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
                <span class="n">res_values</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_fill_value</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">LossySetitemError</span><span class="p">):</span>
            <span class="c1"># e.g. trying to insert an integer into a DatetimeIndex</span>
            <span class="c1">#  We cannot keep the same dtype, so cast to the (often object)</span>
            <span class="c1">#  minimal shared dtype before doing the insert.</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_common_type_compat</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># with object-dtype we need to worry about numpy incorrectly casting</span>
            <span class="c1"># dt64/td64 to integer, also about treating tuples as sequences</span>
            <span class="c1"># special-casing dt64/td64 https://github.com/numpy/numpy/issues/12550</span>
            <span class="n">casted</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">casted</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># error: No overload variant of &quot;insert&quot; matches argument types</span>
            <span class="c1"># &quot;ndarray[Any, Any]&quot;, &quot;int&quot;, &quot;None&quot;</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># type: ignore[call-overload]</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span> <span class="k">if</span> <span class="n">loc</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">new_values</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>

        <span class="k">return</span> <span class="n">Index</span><span class="o">.</span><span class="n">_with_infer</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.drop"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.drop">[docs]</a>    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">Index</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new Index with passed list of labels deleted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : array-like or scalar</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span>
<span class="sd">            If &#39;ignore&#39;, suppress error and existing labels are dropped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">            Will be same type as self, except for RangeIndex.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If not all of the labels are found in the selected axis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="c1"># avoid materializing e.g. RangeIndex</span>
            <span class="n">arr_dtype</span> <span class="o">=</span> <span class="s2">&quot;object&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;object&quot;</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">index_labels_to_array</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr_dtype</span><span class="p">)</span>

        <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">errors</span> <span class="o">!=</span> <span class="s2">&quot;ignore&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="si">}</span><span class="s2"> not found in axis&quot;</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">indexer</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.infer_objects"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.infer_objects">[docs]</a>    <span class="k">def</span> <span class="nf">infer_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we have an object dtype, try to infer a non-object dtype.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Whether to make a copy in cases where no inference occurs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;infer_objects is not implemented for MultiIndex. &quot;</span>
                <span class="s2">&quot;Use index.to_frame().infer_objects() instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;npt.NDArray[np.object_]&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">res_values</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span>
            <span class="n">convert_datetime</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">convert_timedelta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">convert_period</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">convert_interval</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">res_values</span> <span class="ow">is</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">res_values</span> <span class="ow">is</span> <span class="n">values</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_references</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_references</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_references</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_references</span><span class="o">.</span><span class="n">add_index_reference</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Generated Arithmetic, Comparison, and Unary Methods</span>

    <span class="k">def</span> <span class="nf">_cmp_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper used to dispatch comparison operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c1"># fastpath</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">{</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">}:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_hold_na</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                    <span class="c1"># TODO: should set MultiIndex._can_hold_na = False?</span>
                    <span class="n">arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="n">arr</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_hold_na</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                    <span class="n">arr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">arr</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
            <span class="bp">self</span>
        <span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lengths must match to compare&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
            <span class="c1"># e.g. PeriodArray, Categorical</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="c1"># don&#39;t pass MultiIndex</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">comp_method_OBJECT_ARRAY</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">comparison_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_logical_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="n">res_name</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="n">lvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">rvalues</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extract_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">res_values</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">logical_op</span><span class="p">(</span><span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalues</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_result</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_construct_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_arith_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Index</span>
        <span class="p">):</span>
            <span class="c1"># We return NotImplemented for object-dtype index *subclasses* so they have</span>
            <span class="c1"># a chance to implement ops before we unwrap them.</span>
            <span class="c1"># See https://github.com/pandas-dev/pandas/issues/31109</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_arith_method</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_unary_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unary_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">abs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unary_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unary_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="c1"># GH#8875</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unary_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">inv</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Reductions</span>

<div class="viewcode-block" id="Index.any"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.any">[docs]</a>    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether any element is Truthy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args</span>
<span class="sd">            Required for compatibility with numpy.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Required for compatibility with numpy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or array-like (if axis is specified)</span>
<span class="sd">            A single element array-like may be converted to bool.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.all : Return whether all elements are True.</span>
<span class="sd">        Series.all : Return whether all elements are True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Not a Number (NaN), positive infinity and negative infinity</span>
<span class="sd">        evaluate to True because these are not equal to zero.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = pd.Index([0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; index.any()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; index = pd.Index([0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; index.any()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_any</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_disable_logical_methods</span><span class="p">(</span><span class="s2">&quot;any&quot;</span><span class="p">)</span>
        <span class="c1"># error: Argument 1 to &quot;any&quot; has incompatible type &quot;ArrayLike&quot;; expected</span>
        <span class="c1"># &quot;Union[Union[int, float, complex, str, bytes, generic], Sequence[Union[int,</span>
        <span class="c1"># float, complex, str, bytes, generic]], Sequence[Sequence[Any]],</span>
        <span class="c1"># _SupportsArray]&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span></div>

<div class="viewcode-block" id="Index.all"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.all">[docs]</a>    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether all elements are Truthy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args</span>
<span class="sd">            Required for compatibility with numpy.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Required for compatibility with numpy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or array-like (if axis is specified)</span>
<span class="sd">            A single element array-like may be converted to bool.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.any : Return whether any element in an Index is True.</span>
<span class="sd">        Series.any : Return whether any element in a Series is True.</span>
<span class="sd">        Series.all : Return whether all elements in a Series are True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Not a Number (NaN), positive infinity and negative infinity</span>
<span class="sd">        evaluate to True because these are not equal to zero.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        True, because nonzero integers are considered True.</span>

<span class="sd">        &gt;&gt;&gt; pd.Index([1, 2, 3]).all()</span>
<span class="sd">        True</span>

<span class="sd">        False, because ``0`` is considered False.</span>

<span class="sd">        &gt;&gt;&gt; pd.Index([0, 1, 2]).all()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_all</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_disable_logical_methods</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
        <span class="c1"># error: Argument 1 to &quot;all&quot; has incompatible type &quot;ArrayLike&quot;; expected</span>
        <span class="c1"># &quot;Union[Union[int, float, complex, str, bytes, generic], Sequence[Union[int,</span>
        <span class="c1"># float, complex, str, bytes, generic]], Sequence[Sequence[Any]],</span>
        <span class="c1"># _SupportsArray]&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span></div>

    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">_maybe_disable_logical_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opname</span><span class="p">:</span> <span class="n">str_t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        raise if this Index subclass does not support any or all.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># This call will raise</span>
            <span class="n">make_invalid_op</span><span class="p">(</span><span class="n">opname</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Index.argmin"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.argmin">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">IndexOpsMixin</span><span class="o">.</span><span class="n">argmin</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_argmin</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_minmax_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
            <span class="c1"># Take advantage of cache</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">skipna</span> <span class="ow">or</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.argmax"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.argmax">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">IndexOpsMixin</span><span class="o">.</span><span class="n">argmax</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_argmax</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_minmax_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
            <span class="c1"># Take advantage of cache</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">skipna</span> <span class="ow">or</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.min"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.min">[docs]</a>    <span class="nd">@doc</span><span class="p">(</span><span class="n">IndexOpsMixin</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_min</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_minmax_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="c1"># quick check</span>
            <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isna</span><span class="p">(</span><span class="n">first</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">first</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
            <span class="c1"># Take advantage of cache</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">skipna</span> <span class="ow">or</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.max"><a class="viewcode-back" href="../../../../utils/pandas.html#pandas.Index.max">[docs]</a>    <span class="nd">@doc</span><span class="p">(</span><span class="n">IndexOpsMixin</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_max</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_minmax_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="c1"># quick check</span>
            <span class="n">last</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isna</span><span class="p">(</span><span class="n">last</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">last</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
            <span class="c1"># Take advantage of cache</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">skipna</span> <span class="ow">or</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_multi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span></div>

    <span class="c1"># --------------------------------------------------------------------</span>

    <span class="nd">@final</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shape</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of the shape of the underlying data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See GH#27775, GH#27384 for history/reasoning in how this is defined.</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span></div>


<span class="k">def</span> <span class="nf">ensure_index_from_sequences</span><span class="p">(</span><span class="n">sequences</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct an index from sequences of data.</span>

<span class="sd">    A single sequence returns an Index. Many sequences returns a</span>
<span class="sd">    MultiIndex.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sequences : sequence of sequences</span>
<span class="sd">    names : sequence of str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index : Index or MultiIndex</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ensure_index_from_sequences([[1, 2, 3]], names=[&quot;name&quot;])</span>
<span class="sd">    Index([1, 2, 3], dtype=&#39;int64&#39;, name=&#39;name&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ensure_index_from_sequences([[&quot;a&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;b&quot;]], names=[&quot;L1&quot;, &quot;L2&quot;])</span>
<span class="sd">    MultiIndex([(&#39;a&#39;, &#39;a&#39;),</span>
<span class="sd">                (&#39;a&#39;, &#39;b&#39;)],</span>
<span class="sd">               names=[&#39;L1&#39;, &#39;L2&#39;])</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ensure_index</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pandas.core.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">sequences</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ensure_index</span><span class="p">(</span><span class="n">index_like</span><span class="p">:</span> <span class="n">Axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensure that we have an index from some index-like object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index_like : sequence</span>
<span class="sd">        An Index or other sequence</span>
<span class="sd">    copy : bool, default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index : Index or MultiIndex</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ensure_index_from_sequences</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ensure_index([&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">    Index([&#39;a&#39;, &#39;b&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ensure_index([(&#39;a&#39;, &#39;a&#39;),  (&#39;b&#39;, &#39;c&#39;)])</span>
<span class="sd">    Index([(&#39;a&#39;, &#39;a&#39;), (&#39;b&#39;, &#39;c&#39;)], dtype=&#39;object&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ensure_index([[&#39;a&#39;, &#39;a&#39;], [&#39;b&#39;, &#39;c&#39;]])</span>
<span class="sd">    MultiIndex([(&#39;a&#39;, &#39;b&#39;),</span>
<span class="sd">            (&#39;a&#39;, &#39;c&#39;)],</span>
<span class="sd">           )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">index_like</span> <span class="o">=</span> <span class="n">index_like</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">index_like</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">index_like</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_iterator</span><span class="p">(</span><span class="n">index_like</span><span class="p">):</span>
        <span class="n">index_like</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">index_like</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">index_like</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
            <span class="c1"># must check for exactly list here because of strict type</span>
            <span class="c1"># check in clean_index_list</span>
            <span class="n">index_like</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">index_like</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_like</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lib</span><span class="o">.</span><span class="n">is_all_arraylike</span><span class="p">(</span><span class="n">index_like</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.core.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

            <span class="k">return</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">index_like</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">tupleize_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ensure_has_len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If seq is an iterator, put its values into a list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">seq</span>


<span class="k">def</span> <span class="nf">trim_front</span><span class="p">(</span><span class="n">strings</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trims zeros and decimal points.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; trim_front([&quot; a&quot;, &quot; b&quot;])</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;]</span>

<span class="sd">    &gt;&gt;&gt; trim_front([&quot; a&quot;, &quot; &quot;])</span>
<span class="sd">    [&#39;a&#39;, &#39;&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">strings</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">strings</span>
    <span class="k">while</span> <span class="nb">all</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot; &quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">):</span>
        <span class="n">strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">strings</span>


<span class="k">def</span> <span class="nf">_validate_join_method</span><span class="p">(</span><span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;do not recognize join method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">maybe_extract_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hashable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If no name is passed, then extract it from data, validating hashability.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
        <span class="c1"># Note we don&#39;t just check for &quot;name&quot; attribute since that would</span>
        <span class="c1">#  pick up e.g. dtype.name</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># GH#29069</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.name must be a hashable type&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">name</span>


<span class="k">def</span> <span class="nf">get_unanimous_names</span><span class="p">(</span><span class="o">*</span><span class="n">indexes</span><span class="p">:</span> <span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return common name if all indices agree, otherwise None (level-by-level).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indexes : list of Index objects</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list representing the unanimous &#39;names&#39; found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name_tups</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
    <span class="n">name_sets</span> <span class="o">=</span> <span class="p">[{</span><span class="o">*</span><span class="n">ns</span><span class="p">}</span> <span class="k">for</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="o">*</span><span class="n">name_tups</span><span class="p">)]</span>
    <span class="n">names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">name_sets</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">names</span>


<span class="k">def</span> <span class="nf">_unpack_nested_dtype</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When checking if our dtype is comparable with another, we need</span>
<span class="sd">    to unpack CategoricalDtype to look at its categories.dtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    other : Index</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Index</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">CategoricalDtype</span><span class="p">):</span>
        <span class="c1"># If there is ever a SparseIndex, this could get dispatched</span>
        <span class="c1">#  here too.</span>
        <span class="k">return</span> <span class="n">dtype</span><span class="o">.</span><span class="n">categories</span>
    <span class="k">return</span> <span class="n">other</span>


<span class="k">def</span> <span class="nf">_maybe_try_sort</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">sort</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">safe_sort</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">, sort order is undefined for incomparable objects.&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso Furlanello, and Daniel Hug.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>