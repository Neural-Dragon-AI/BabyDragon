<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pandas.core.arrays.datetimes &mdash; BabyDragon  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            BabyDragon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tasks:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/llm_task.html">LLMReader</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/llm_task.html#llmwriter">LLMWriter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/multi_kernel_task.html">MultiKernelTask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/base_task.html">BaseTask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/topic_tree_task.html">TopicTreeTask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tasks/embedding_task.html">EmbeddingTask</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Kernels:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/memory_kernel.html">MemoryKernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_clustering.html">ClusterPaths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_clustering.html#hdbscanpaths">HDBSCANPaths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_clustering.html#spectralclusteringpaths">SpectralClusteringPaths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel.html">MultiKernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel.html#hdbscanmultikernel">HDBSCANMultiKernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel.html#spectralclusteringmultikernel">SpectralClusteringMultiKernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel_visualization.html">MultiKernelVisualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/multi_kernel_visualization.html#multikernelstabilityanalysis">MultiKernelStabilityAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/kernels/kernel_utils.html">kernel_utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Threads:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/base_thread.html">BaseThread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/fifo_thread.html">FifoThread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/threads/vector_thread.html">VectorThread</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Memory/Indexes:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/memory_index.html">MemoryIndex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory/indexes/pandas_index.html">PandasIndex</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Chat:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/base_chat.html">Prompter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/base_chat.html#basechat">BaseChat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/memory_chat.html">FifoChat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/memory_chat.html#vectorchat">VectorChat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/memory_chat.html#fifovectorchat">FifoVectorChat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../chat/chat.html">Chat</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utils:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/pandas.html">pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/hf_datasets.html">hf_datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils/chatml.html">chatml</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/embedders:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/ada2.html">OpenAiEmbedder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/cohere.html">CohereEmbedder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/embedders/sbert.html">SBERTEmbedder</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models/generators:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/cohere.html">cohere</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models/generators/chatgpt.html">chatgpt</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Processors:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/github_processors.html">GithubProcessor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/os_processor.html">OsProcessor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/git_metadata.html">IssueParser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/git_metadata.html#commitparser">CommitParser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html">FunctionCallFinder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html#multiplicationcountervisitor">MultiplicationCounterVisitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html#functionandclassvisitor">FunctionAndClassVisitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/visitors.html#typingcollector">TypingCollector</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html">PythonMinifier</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html#pythondocstringextractor">PythonDocstringExtractor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html#functionandclassvisitor">FunctionAndClassVisitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../processors/parsers/python_parser.html#pythonparser">PythonParser</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Apps:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html">SubjectPerspectiveAnalyzer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html#ideation">Ideation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html#ideacluster">IdeaCluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html#summarizer">Summarizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps/auto_perspective/perspective.html#perspectivepromptgenerator">PerspectivePromptGenerator</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">BabyDragon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pandas.core.arrays.datetimes</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pandas.core.arrays.datetimes</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">datetime</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">timedelta</span><span class="p">,</span>
    <span class="n">tzinfo</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">lib</span><span class="p">,</span>
    <span class="n">tslib</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BaseOffset</span><span class="p">,</span>
    <span class="n">NaT</span><span class="p">,</span>
    <span class="n">NaTType</span><span class="p">,</span>
    <span class="n">Resolution</span><span class="p">,</span>
    <span class="n">Timestamp</span><span class="p">,</span>
    <span class="n">astype_overflowsafe</span><span class="p">,</span>
    <span class="n">fields</span><span class="p">,</span>
    <span class="n">get_resolution</span><span class="p">,</span>
    <span class="n">get_supported_reso</span><span class="p">,</span>
    <span class="n">get_unit_from_dtype</span><span class="p">,</span>
    <span class="n">ints_to_pydatetime</span><span class="p">,</span>
    <span class="n">is_date_array_normalized</span><span class="p">,</span>
    <span class="n">is_supported_unit</span><span class="p">,</span>
    <span class="n">is_unitless</span><span class="p">,</span>
    <span class="n">normalize_i8_timestamps</span><span class="p">,</span>
    <span class="n">npy_unit_to_abbrev</span><span class="p">,</span>
    <span class="n">timezones</span><span class="p">,</span>
    <span class="n">to_offset</span><span class="p">,</span>
    <span class="n">tz_convert_from_utc</span><span class="p">,</span>
    <span class="n">tzconversion</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs.dtypes</span> <span class="kn">import</span> <span class="n">abbrev_to_npy_unit</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DateTimeErrorChoices</span><span class="p">,</span>
    <span class="n">IntervalClosedType</span><span class="p">,</span>
    <span class="n">TimeAmbiguous</span><span class="p">,</span>
    <span class="n">TimeNonexistent</span><span class="p">,</span>
    <span class="n">npt</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="n">PerformanceWarning</span>
<span class="kn">from</span> <span class="nn">pandas.util._exceptions</span> <span class="kn">import</span> <span class="n">find_stack_level</span>
<span class="kn">from</span> <span class="nn">pandas.util._validators</span> <span class="kn">import</span> <span class="n">validate_inclusive</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DT64NS_DTYPE</span><span class="p">,</span>
    <span class="n">INT64_DTYPE</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64_any_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64tz_dtype</span><span class="p">,</span>
    <span class="n">is_dtype_equal</span><span class="p">,</span>
    <span class="n">is_extension_array_dtype</span><span class="p">,</span>
    <span class="n">is_float_dtype</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
    <span class="n">is_period_dtype</span><span class="p">,</span>
    <span class="n">is_sparse</span><span class="p">,</span>
    <span class="n">is_string_dtype</span><span class="p">,</span>
    <span class="n">is_timedelta64_dtype</span><span class="p">,</span>
    <span class="n">pandas_dtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.dtypes</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DatetimeTZDtype</span><span class="p">,</span>
    <span class="n">ExtensionDtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="n">isna</span>

<span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="n">datetimelike</span> <span class="k">as</span> <span class="n">dtl</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays._ranges</span> <span class="kn">import</span> <span class="n">generate_regular_range</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>

<span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="kn">import</span> <span class="n">get_period_alias</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.offsets</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Day</span><span class="p">,</span>
    <span class="n">Tick</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>
    <span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="n">PeriodArray</span>

<span class="n">_midnight</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">tz_to_dtype</span><span class="p">(</span><span class="n">tz</span><span class="p">:</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ns&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a datetime64[ns] dtype appropriate for the given timezone.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tz : tzinfo or None</span>
<span class="sd">    unit : str, default &quot;ns&quot;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.dtype or Datetime64TZDType</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;M8[</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DatetimeTZDtype</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_field_accessor</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_timestamps</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_ops</span><span class="p">:</span>
            <span class="n">result</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

            <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">)):</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
                <span class="n">month_kw</span> <span class="o">=</span> <span class="mi">12</span>
                <span class="k">if</span> <span class="n">freq</span><span class="p">:</span>
                    <span class="n">kwds</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">kwds</span>
                    <span class="n">month_kw</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;startingMonth&quot;</span><span class="p">,</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;month&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

                <span class="n">result</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get_start_end_field</span><span class="p">(</span>
                    <span class="n">values</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqstr</span><span class="p">,</span> <span class="n">month_kw</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get_date_field</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>

            <span class="c1"># these return a boolean by-definition</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_ops</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get_date_name_field</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_mask_results</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get_date_field</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_mask_results</span><span class="p">(</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">f</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">docstring</span>
    <span class="k">return</span> <span class="nb">property</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DatetimeArray</span><span class="p">(</span><span class="n">dtl</span><span class="o">.</span><span class="n">TimelikeOps</span><span class="p">,</span> <span class="n">dtl</span><span class="o">.</span><span class="n">DatelikeOps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pandas ExtensionArray for tz-naive or tz-aware datetime data.</span>

<span class="sd">    .. warning::</span>

<span class="sd">       DatetimeArray is currently experimental, and its API may change</span>
<span class="sd">       without warning. In particular, :attr:`DatetimeArray.dtype` is</span>
<span class="sd">       expected to change to always be an instance of an ``ExtensionDtype``</span>
<span class="sd">       subclass.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : Series, Index, DatetimeArray, ndarray</span>
<span class="sd">        The datetime data.</span>

<span class="sd">        For DatetimeArray `values` (or a Series or Index boxing one),</span>
<span class="sd">        `dtype` and `freq` will be extracted from `values`.</span>

<span class="sd">    dtype : numpy.dtype or DatetimeTZDtype</span>
<span class="sd">        Note that the only NumPy dtype allowed is &#39;datetime64[ns]&#39;.</span>
<span class="sd">    freq : str or Offset, optional</span>
<span class="sd">        The frequency.</span>
<span class="sd">    copy : bool, default False</span>
<span class="sd">        Whether to copy the underlying array of values.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_typ</span> <span class="o">=</span> <span class="s2">&quot;datetimearray&quot;</span>
    <span class="n">_internal_fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;NaT&quot;</span><span class="p">,</span> <span class="s2">&quot;ns&quot;</span><span class="p">)</span>
    <span class="n">_recognized_scalars</span> <span class="o">=</span> <span class="p">(</span><span class="n">datetime</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span>
    <span class="n">_is_recognized_dtype</span> <span class="o">=</span> <span class="n">is_datetime64_any_dtype</span>
    <span class="n">_infer_matches</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime64&quot;</span><span class="p">,</span> <span class="s2">&quot;date&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_scalar_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">[</span><span class="n">Timestamp</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">Timestamp</span>

    <span class="c1"># define my properties &amp; methods for delegation</span>
    <span class="n">_bool_ops</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;is_month_start&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_month_end&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_quarter_start&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_quarter_end&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_year_start&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_year_end&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_leap_year&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">_object_ops</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;tz&quot;</span><span class="p">]</span>
    <span class="n">_field_ops</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;month&quot;</span><span class="p">,</span>
        <span class="s2">&quot;day&quot;</span><span class="p">,</span>
        <span class="s2">&quot;hour&quot;</span><span class="p">,</span>
        <span class="s2">&quot;minute&quot;</span><span class="p">,</span>
        <span class="s2">&quot;second&quot;</span><span class="p">,</span>
        <span class="s2">&quot;weekday&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dayofweek&quot;</span><span class="p">,</span>
        <span class="s2">&quot;day_of_week&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dayofyear&quot;</span><span class="p">,</span>
        <span class="s2">&quot;day_of_year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;quarter&quot;</span><span class="p">,</span>
        <span class="s2">&quot;days_in_month&quot;</span><span class="p">,</span>
        <span class="s2">&quot;daysinmonth&quot;</span><span class="p">,</span>
        <span class="s2">&quot;microsecond&quot;</span><span class="p">,</span>
        <span class="s2">&quot;nanosecond&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">_other_ops</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;timetz&quot;</span><span class="p">]</span>
    <span class="n">_datetimelike_ops</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">_field_ops</span> <span class="o">+</span> <span class="n">_object_ops</span> <span class="o">+</span> <span class="n">_bool_ops</span> <span class="o">+</span> <span class="n">_other_ops</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">_datetimelike_methods</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;to_period&quot;</span><span class="p">,</span>
        <span class="s2">&quot;tz_localize&quot;</span><span class="p">,</span>
        <span class="s2">&quot;tz_convert&quot;</span><span class="p">,</span>
        <span class="s2">&quot;normalize&quot;</span><span class="p">,</span>
        <span class="s2">&quot;strftime&quot;</span><span class="p">,</span>
        <span class="s2">&quot;round&quot;</span><span class="p">,</span>
        <span class="s2">&quot;floor&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ceil&quot;</span><span class="p">,</span>
        <span class="s2">&quot;month_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;day_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;as_unit&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># ndim is inherited from ExtensionArray, must exist to ensure</span>
    <span class="c1">#  Timestamp.__richcmp__(DateTimeArray) operates pointwise</span>

    <span class="c1"># ensure that operations with numpy arrays defer to our implementation</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># Constructors</span>

    <span class="n">_dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span> <span class="o">|</span> <span class="n">DatetimeTZDtype</span>
    <span class="n">_freq</span><span class="p">:</span> <span class="n">BaseOffset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_default_dtype</span> <span class="o">=</span> <span class="n">DT64NS_DTYPE</span>  <span class="c1"># used in TimeLikeOps.__init__</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_validate_dtype</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># used in TimeLikeOps.__init__</span>
        <span class="n">_validate_dt64_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">_validate_dt64_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dtype</span>

    <span class="c1"># error: Signature of &quot;_simple_new&quot; incompatible with supertype &quot;NDArrayBacked&quot;</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_simple_new</span><span class="p">(</span>  <span class="c1"># type: ignore[override]</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">BaseOffset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">DT64NS_DTYPE</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeArray</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">is_unitless</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># DatetimeTZDtype. If we have e.g. DatetimeTZDtype[us, UTC],</span>
            <span class="c1">#  then values.dtype should be M8[us].</span>
            <span class="k">assert</span> <span class="n">dtype</span><span class="o">.</span><span class="n">_creso</span> <span class="o">==</span> <span class="n">get_unit_from_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_sequence</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_from_sequence_not_strict</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_sequence_not_strict</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">tz</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">BaseOffset</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="n">dayfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">yearfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ambiguous</span><span class="p">:</span> <span class="n">TimeAmbiguous</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A non-strict version of _from_sequence, called from DatetimeIndex.__new__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">explicit_none</span> <span class="o">=</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span> <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">freq</span><span class="p">,</span> <span class="n">freq_infer</span> <span class="o">=</span> <span class="n">dtl</span><span class="o">.</span><span class="n">maybe_infer_freq</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="c1"># if the user either explicitly passes tz=None or a tz-naive dtype, we</span>
        <span class="c1">#  disallows inferring a tz.</span>
        <span class="n">explicit_tz_none</span> <span class="o">=</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">timezones</span><span class="o">.</span><span class="n">maybe_get_tz</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">_validate_dt64_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># if dtype has an embedded tz, capture it</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">_validate_tz_from_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">explicit_tz_none</span><span class="p">)</span>

        <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># DatetimeTZDtype</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">unit</span>

        <span class="n">subarr</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">inferred_freq</span> <span class="o">=</span> <span class="n">_sequence_to_dt64ns</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
            <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span>
            <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">,</span>
            <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">,</span>
            <span class="n">out_unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># We have to call this again after possibly inferring a tz above</span>
        <span class="n">_validate_tz_from_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">explicit_tz_none</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">explicit_tz_none</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Passed data is timezone-aware, incompatible with &#39;tz=None&#39;. &quot;</span>
                <span class="s2">&quot;Use obj.tz_localize(None) instead.&quot;</span>
            <span class="p">)</span>

        <span class="n">freq</span><span class="p">,</span> <span class="n">freq_infer</span> <span class="o">=</span> <span class="n">dtl</span><span class="o">.</span><span class="n">validate_inferred_freq</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">inferred_freq</span><span class="p">,</span> <span class="n">freq_infer</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">explicit_none</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">data_unit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">subarr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data_dtype</span> <span class="o">=</span> <span class="n">tz_to_dtype</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">data_unit</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data_dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unit</span> <span class="o">!=</span> <span class="n">result</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="c1"># If unit was specified in user-passed dtype, cast to it here</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">as_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inferred_freq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># this condition precludes `freq_infer`</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_validate_frequency</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">freq_infer</span><span class="p">:</span>
            <span class="c1"># Set _freq directly to bypass duplicative _validate_frequency</span>
            <span class="c1"># check.</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">inferred_freq</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># error: Signature of &quot;_generate_range&quot; incompatible with supertype</span>
    <span class="c1"># &quot;DatetimeLikeArrayMixin&quot;</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_generate_range</span><span class="p">(</span>  <span class="c1"># type: ignore[override]</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">start</span><span class="p">,</span>
        <span class="n">end</span><span class="p">,</span>
        <span class="n">periods</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">,</span>
        <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ambiguous</span><span class="p">:</span> <span class="n">TimeAmbiguous</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">nonexistent</span><span class="p">:</span> <span class="n">TimeNonexistent</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">inclusive</span><span class="p">:</span> <span class="n">IntervalClosedType</span> <span class="o">=</span> <span class="s2">&quot;both&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeArray</span><span class="p">:</span>
        <span class="n">periods</span> <span class="o">=</span> <span class="n">dtl</span><span class="o">.</span><span class="n">validate_periods</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">periods</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide freq argument if no data is supplied&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">count_not_none</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Of the four parameters: start, end, periods, &quot;</span>
                <span class="s2">&quot;and freq, exactly three must be specified&quot;</span>
            <span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="n">NaT</span> <span class="ow">or</span> <span class="n">end</span> <span class="ow">is</span> <span class="n">NaT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Neither `start` nor `end` can be NaT&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;ms&quot;</span><span class="p">,</span> <span class="s2">&quot;us&quot;</span><span class="p">,</span> <span class="s2">&quot;ns&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;unit&#39; must be one of &#39;s&#39;, &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;ns&quot;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">as_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">round_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">as_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">round_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">left_inclusive</span><span class="p">,</span> <span class="n">right_inclusive</span> <span class="o">=</span> <span class="n">validate_inclusive</span><span class="p">(</span><span class="n">inclusive</span><span class="p">)</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">_maybe_normalize_endpoints</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">normalize</span><span class="p">)</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">_infer_tz_from_endpoints</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Localize the start and end arguments</span>
            <span class="n">start_tz</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start</span><span class="o">.</span><span class="n">tz</span>
            <span class="n">end_tz</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">end</span><span class="o">.</span><span class="n">tz</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">_maybe_localize_point</span><span class="p">(</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">start_tz</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span>
            <span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">_maybe_localize_point</span><span class="p">(</span>
                <span class="n">end</span><span class="p">,</span> <span class="n">end_tz</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We break Day arithmetic (fixed 24 hour) here and opt for</span>
            <span class="c1"># Day to mean calendar day (23/24/25 hour). Therefore, strip</span>
            <span class="c1"># tz info from start and day to avoid DST arithmetic</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">Day</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">Tick</span><span class="p">):</span>
                <span class="n">i8values</span> <span class="o">=</span> <span class="n">generate_regular_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xdr</span> <span class="o">=</span> <span class="n">_generate_range</span><span class="p">(</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span>
                <span class="p">)</span>
                <span class="n">i8values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">_value</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xdr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

            <span class="n">endpoint_tz</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">tz</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">end</span><span class="o">.</span><span class="n">tz</span>

            <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">endpoint_tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">timezones</span><span class="o">.</span><span class="n">is_utc</span><span class="p">(</span><span class="n">tz</span><span class="p">):</span>
                    <span class="c1"># short-circuit tz_localize_to_utc which would make</span>
                    <span class="c1">#  an unnecessary copy with UTC but be a no-op.</span>
                    <span class="n">creso</span> <span class="o">=</span> <span class="n">abbrev_to_npy_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
                    <span class="n">i8values</span> <span class="o">=</span> <span class="n">tzconversion</span><span class="o">.</span><span class="n">tz_localize_to_utc</span><span class="p">(</span>
                        <span class="n">i8values</span><span class="p">,</span>
                        <span class="n">tz</span><span class="p">,</span>
                        <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">,</span>
                        <span class="n">nonexistent</span><span class="o">=</span><span class="n">nonexistent</span><span class="p">,</span>
                        <span class="n">creso</span><span class="o">=</span><span class="n">creso</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># i8values is localized datetime64 array -&gt; have to convert</span>
                <span class="c1"># start/end as well to compare</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create a linearly spaced date_range in local time</span>
            <span class="c1"># Nanosecond-granularity timestamps aren&#39;t always correctly</span>
            <span class="c1"># representable with doubles, so we limit the range that we</span>
            <span class="c1"># pass to np.linspace as much as possible</span>
            <span class="n">i8values</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">.</span><span class="n">_value</span> <span class="o">-</span> <span class="n">start</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">start</span><span class="o">.</span><span class="n">_value</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">i8values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;i8&quot;</span><span class="p">:</span>
                <span class="c1"># 2022-01-09 I (brock) am not sure if it is possible for this</span>
                <span class="c1">#  to overflow and cast to e.g. f8, but if it does we need to cast</span>
                <span class="n">i8values</span> <span class="o">=</span> <span class="n">i8values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">left_inclusive</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right_inclusive</span><span class="p">:</span>
                <span class="n">i8values</span> <span class="o">=</span> <span class="n">i8values</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_i8</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">_value</span>
            <span class="n">end_i8</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">_value</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">left_inclusive</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">right_inclusive</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">left_inclusive</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">i8values</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i8values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">start_i8</span><span class="p">:</span>
                    <span class="n">i8values</span> <span class="o">=</span> <span class="n">i8values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">right_inclusive</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">i8values</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i8values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">end_i8</span><span class="p">:</span>
                    <span class="n">i8values</span> <span class="o">=</span> <span class="n">i8values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">dt64_values</span> <span class="o">=</span> <span class="n">i8values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;datetime64[</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">tz_to_dtype</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">dt64_values</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># DatetimeLike Interface</span>

    <span class="k">def</span> <span class="nf">_unbox_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar_type</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NaT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;value&#39; should be a Timestamp.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_compatible_with</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">NaT</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">as_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">asm8</span>

    <span class="k">def</span> <span class="nf">_scalar_from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Timestamp</span> <span class="o">|</span> <span class="n">NaTType</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_compatible_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="n">NaT</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_tzawareness_compat</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># Descriptive Properties</span>

    <span class="k">def</span> <span class="nf">_box_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Timestamp</span> <span class="o">|</span> <span class="n">NaTType</span><span class="p">:</span>
        <span class="c1"># GH#42228</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="o">.</span><span class="n">_from_value_and_reso</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="nd">@property</span>
    <span class="c1"># error: Return type &quot;Union[dtype, DatetimeTZDtype]&quot; of &quot;dtype&quot;</span>
    <span class="c1"># incompatible with return type &quot;ExtensionDtype&quot; in supertype</span>
    <span class="c1"># &quot;ExtensionArray&quot;</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span> <span class="o">|</span> <span class="n">DatetimeTZDtype</span><span class="p">:</span>  <span class="c1"># type: ignore[override]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dtype for the DatetimeArray.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           A future version of pandas will change dtype to never be a</span>
<span class="sd">           ``numpy.dtype``. Instead, :attr:`DatetimeArray.dtype` will</span>
<span class="sd">           always be an instance of an ``ExtensionDtype`` subclass.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.dtype or DatetimeTZDtype</span>
<span class="sd">            If the values are tz-naive, then ``np.dtype(&#39;datetime64[ns]&#39;)``</span>
<span class="sd">            is returned.</span>

<span class="sd">            If the values are tz-aware, then the ``DatetimeTZDtype``</span>
<span class="sd">            is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the timezone.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        datetime.tzinfo, pytz.tzinfo.BaseTZInfo, dateutil.tz.tz.tzfile, or None</span>
<span class="sd">            Returns None when the array is tz-naive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># GH 18595</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;tz&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@tz</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># GH 3746: Prevent localizing or converting the index by setting tz</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot directly set timezone. Use tz_localize() &quot;</span>
            <span class="s2">&quot;or tz_convert() as appropriate&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tzinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alias for tz attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span>

    <span class="nd">@property</span>  <span class="c1"># NB: override with cache_readonly in immutable subclasses</span>
    <span class="k">def</span> <span class="nf">is_normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if all of the dates are at midnight (&quot;no time&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_date_array_normalized</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>

    <span class="nd">@property</span>  <span class="c1"># NB: override with cache_readonly in immutable subclasses</span>
    <span class="k">def</span> <span class="nf">_resolution_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Resolution</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_resolution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------</span>
    <span class="c1"># Array-Like / EA-Interface Methods</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">:</span>
            <span class="c1"># The default for tz-aware is object, to preserve tz info</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array__</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator over the boxed values</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        tstamp : Timestamp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># convert in chunks of 10k for efficiency</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asi8</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">chunksize</span> <span class="o">=</span> <span class="mi">10000</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">//</span> <span class="n">chunksize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
                <span class="n">start_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">chunksize</span>
                <span class="n">end_i</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunksize</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
                <span class="n">converted</span> <span class="o">=</span> <span class="n">ints_to_pydatetime</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">start_i</span><span class="p">:</span><span class="n">end_i</span><span class="p">],</span>
                    <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span>
                    <span class="n">box</span><span class="o">=</span><span class="s2">&quot;timestamp&quot;</span><span class="p">,</span>
                    <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">yield from</span> <span class="n">converted</span>

    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="c1"># We handle</span>
        <span class="c1">#   --&gt; datetime</span>
        <span class="c1">#   --&gt; period</span>
        <span class="c1"># DatetimeLikeArrayMixin Super handles the rest.</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ExtensionDtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">DatetimeTZDtype</span><span class="p">):</span>
                <span class="c1"># e.g. Sparse[datetime64[ns]]</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># pre-2.0 this did self.tz_localize(dtype.tz), which did not match</span>
                <span class="c1">#  the Series behavior which did</span>
                <span class="c1">#  values.tz_localize(&quot;UTC&quot;).tz_convert(dtype.tz)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot use .astype to convert from timezone-naive dtype to &quot;</span>
                    <span class="s2">&quot;timezone-aware dtype. Use obj.tz_localize instead or &quot;</span>
                    <span class="s2">&quot;series.dt.tz_localize instead&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># tzaware unit conversion e.g. datetime64[s, UTC]</span>
                <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">)</span>
                <span class="n">res_values</span> <span class="o">=</span> <span class="n">astype_overflowsafe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndarray</span><span class="p">,</span> <span class="n">np_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_unitless</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">is_supported_unit</span><span class="p">(</span><span class="n">get_unit_from_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="c1"># unit conversion e.g. datetime64[s]</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">astype_overflowsafe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndarray</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">res_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="c1"># TODO: preserve freq?</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># pre-2.0 behavior for DTA/DTI was</span>
            <span class="c1">#  values.tz_convert(&quot;UTC&quot;).tz_localize(None), which did not match</span>
            <span class="c1">#  the Series behavior</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use .astype to convert from timezone-aware dtype to &quot;</span>
                <span class="s2">&quot;timezone-naive dtype. Use obj.tz_localize(None) or &quot;</span>
                <span class="s2">&quot;obj.tz_convert(&#39;UTC&#39;).tz_localize(None) instead.&quot;</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
            <span class="ow">and</span> <span class="n">is_unitless</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Casting to unit-less dtype &#39;datetime64&#39; is not supported. &quot;</span>
                <span class="s2">&quot;Pass e.g. &#39;datetime64[ns]&#39; instead.&quot;</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_period_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">dtype</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dtl</span><span class="o">.</span><span class="n">DatetimeLikeArrayMixin</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># Rendering Methods</span>

    <span class="k">def</span> <span class="nf">_format_native_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="s2">&quot;NaT&quot;</span><span class="p">,</span> <span class="n">date_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">]:</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.format</span> <span class="kn">import</span> <span class="n">get_format_datetime64_from_values</span>

        <span class="n">fmt</span> <span class="o">=</span> <span class="n">get_format_datetime64_from_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date_format</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tslib</span><span class="o">.</span><span class="n">format_array_from_datetime</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span>
        <span class="p">)</span>

    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># Comparison Methods</span>

    <span class="k">def</span> <span class="nf">_has_same_tz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># vzone shouldn&#39;t be None if value is non-datetime like</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
            <span class="c1"># convert to Timestamp as np.datetime64 doesn&#39;t have tz attr</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;tzinfo&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">other_tz</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">tzinfo</span>
        <span class="k">return</span> <span class="n">timezones</span><span class="o">.</span><span class="n">tz_compare</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">,</span> <span class="n">other_tz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_tzawareness_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># adapted from _Timestamp._assert_tzawareness_compat</span>
        <span class="n">other_tz</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;tzinfo&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">other_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">other_dtype</span><span class="p">):</span>
            <span class="c1"># Get tzinfo from Series dtype</span>
            <span class="n">other_tz</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">tz</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="n">NaT</span><span class="p">:</span>
            <span class="c1"># pd.NaT quacks both aware and naive</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other_tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot compare tz-naive and tz-aware datetime-like objects.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">other_tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot compare tz-naive and tz-aware datetime-like objects&quot;</span>
            <span class="p">)</span>

    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># Arithmetic Methods</span>

    <span class="k">def</span> <span class="nf">_add_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeArray</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">Tick</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">_apply_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Non-vectorized DateOffset being applied to Series or DatetimeIndex.&quot;</span><span class="p">,</span>
                <span class="n">PerformanceWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">as_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># GH#30336 _from_sequence won&#39;t be able to infer self.tz</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># Timezone Conversion and Localization Methods</span>

    <span class="k">def</span> <span class="nf">_local_timestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to an i8 (unix-like nanosecond timestamp) representation</span>
<span class="sd">        while keeping the local timezone and not using UTC.</span>
<span class="sd">        This is used to calculate time-of-day information as if the timestamps</span>
<span class="sd">        were timezone-naive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">timezones</span><span class="o">.</span><span class="n">is_utc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">):</span>
            <span class="c1"># Avoid the copy that would be made in tzconversion</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asi8</span>
        <span class="k">return</span> <span class="n">tz_convert_from_utc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert tz-aware Datetime Array/Index from one time zone to another.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : str, pytz.timezone, dateutil.tz.tzfile, datetime.tzinfo or None</span>
<span class="sd">            Time zone for time. Corresponding timestamps would be converted</span>
<span class="sd">            to this time zone of the Datetime Array/Index. A `tz` of None will</span>
<span class="sd">            convert to UTC and remove the timezone information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Array or Index</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If Datetime Array/Index is tz-naive.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DatetimeIndex.tz : A timezone that has a variable offset from UTC.</span>
<span class="sd">        DatetimeIndex.tz_localize : Localize tz-naive DatetimeIndex to a</span>
<span class="sd">            given time zone, or remove timezone from a tz-aware DatetimeIndex.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        With the `tz` parameter, we can change the DatetimeIndex</span>
<span class="sd">        to other time zones:</span>

<span class="sd">        &gt;&gt;&gt; dti = pd.date_range(start=&#39;2014-08-01 09:00&#39;,</span>
<span class="sd">        ...                     freq=&#39;H&#39;, periods=3, tz=&#39;Europe/Berlin&#39;)</span>

<span class="sd">        &gt;&gt;&gt; dti</span>
<span class="sd">        DatetimeIndex([&#39;2014-08-01 09:00:00+02:00&#39;,</span>
<span class="sd">                       &#39;2014-08-01 10:00:00+02:00&#39;,</span>
<span class="sd">                       &#39;2014-08-01 11:00:00+02:00&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns, Europe/Berlin]&#39;, freq=&#39;H&#39;)</span>

<span class="sd">        &gt;&gt;&gt; dti.tz_convert(&#39;US/Central&#39;)</span>
<span class="sd">        DatetimeIndex([&#39;2014-08-01 02:00:00-05:00&#39;,</span>
<span class="sd">                       &#39;2014-08-01 03:00:00-05:00&#39;,</span>
<span class="sd">                       &#39;2014-08-01 04:00:00-05:00&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns, US/Central]&#39;, freq=&#39;H&#39;)</span>

<span class="sd">        With the ``tz=None``, we can remove the timezone (after converting</span>
<span class="sd">        to UTC if necessary):</span>

<span class="sd">        &gt;&gt;&gt; dti = pd.date_range(start=&#39;2014-08-01 09:00&#39;, freq=&#39;H&#39;,</span>
<span class="sd">        ...                     periods=3, tz=&#39;Europe/Berlin&#39;)</span>

<span class="sd">        &gt;&gt;&gt; dti</span>
<span class="sd">        DatetimeIndex([&#39;2014-08-01 09:00:00+02:00&#39;,</span>
<span class="sd">                       &#39;2014-08-01 10:00:00+02:00&#39;,</span>
<span class="sd">                       &#39;2014-08-01 11:00:00+02:00&#39;],</span>
<span class="sd">                        dtype=&#39;datetime64[ns, Europe/Berlin]&#39;, freq=&#39;H&#39;)</span>

<span class="sd">        &gt;&gt;&gt; dti.tz_convert(None)</span>
<span class="sd">        DatetimeIndex([&#39;2014-08-01 07:00:00&#39;,</span>
<span class="sd">                       &#39;2014-08-01 08:00:00&#39;,</span>
<span class="sd">                       &#39;2014-08-01 09:00:00&#39;],</span>
<span class="sd">                        dtype=&#39;datetime64[ns]&#39;, freq=&#39;H&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">timezones</span><span class="o">.</span><span class="n">maybe_get_tz</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># tz naive, use tz_localize</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot convert tz-naive timestamps, use tz_localize to localize&quot;</span>
            <span class="p">)</span>

        <span class="c1"># No conversion since timestamps are all UTC to begin with</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">tz_to_dtype</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndarray</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>

    <span class="nd">@dtl</span><span class="o">.</span><span class="n">ravel_compat</span>
    <span class="k">def</span> <span class="nf">tz_localize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">,</span>
        <span class="n">ambiguous</span><span class="p">:</span> <span class="n">TimeAmbiguous</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">nonexistent</span><span class="p">:</span> <span class="n">TimeNonexistent</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index.</span>

<span class="sd">        This method takes a time zone (tz) naive Datetime Array/Index object</span>
<span class="sd">        and makes this time zone aware. It does not move the time to another</span>
<span class="sd">        time zone.</span>

<span class="sd">        This method can also be used to do the inverse -- to create a time</span>
<span class="sd">        zone unaware object from an aware object. To that end, pass `tz=None`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : str, pytz.timezone, dateutil.tz.tzfile, datetime.tzinfo or None</span>
<span class="sd">            Time zone to convert timestamps to. Passing ``None`` will</span>
<span class="sd">            remove the time zone information preserving local time.</span>
<span class="sd">        ambiguous : &#39;infer&#39;, &#39;NaT&#39;, bool array, default &#39;raise&#39;</span>
<span class="sd">            When clocks moved backward due to DST, ambiguous times may arise.</span>
<span class="sd">            For example in Central European Time (UTC+01), when going from</span>
<span class="sd">            03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at</span>
<span class="sd">            00:30:00 UTC and at 01:30:00 UTC. In such a situation, the</span>
<span class="sd">            `ambiguous` parameter dictates how ambiguous times should be</span>
<span class="sd">            handled.</span>

<span class="sd">            - &#39;infer&#39; will attempt to infer fall dst-transition hours based on</span>
<span class="sd">              order</span>
<span class="sd">            - bool-ndarray where True signifies a DST time, False signifies a</span>
<span class="sd">              non-DST time (note that this flag is only applicable for</span>
<span class="sd">              ambiguous times)</span>
<span class="sd">            - &#39;NaT&#39; will return NaT where there are ambiguous times</span>
<span class="sd">            - &#39;raise&#39; will raise an AmbiguousTimeError if there are ambiguous</span>
<span class="sd">              times.</span>

<span class="sd">        nonexistent : &#39;shift_forward&#39;, &#39;shift_backward, &#39;NaT&#39;, timedelta, \</span>
<span class="sd">default &#39;raise&#39;</span>
<span class="sd">            A nonexistent time does not exist in a particular timezone</span>
<span class="sd">            where clocks moved forward due to DST.</span>

<span class="sd">            - &#39;shift_forward&#39; will shift the nonexistent time forward to the</span>
<span class="sd">              closest existing time</span>
<span class="sd">            - &#39;shift_backward&#39; will shift the nonexistent time backward to the</span>
<span class="sd">              closest existing time</span>
<span class="sd">            - &#39;NaT&#39; will return NaT where there are nonexistent times</span>
<span class="sd">            - timedelta objects will shift nonexistent times by the timedelta</span>
<span class="sd">            - &#39;raise&#39; will raise an NonExistentTimeError if there are</span>
<span class="sd">              nonexistent times.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Same type as self</span>
<span class="sd">            Array/Index converted to the specified time zone.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the Datetime Array/Index is tz-aware and tz is not None.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DatetimeIndex.tz_convert : Convert tz-aware DatetimeIndex from</span>
<span class="sd">            one time zone to another.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tz_naive = pd.date_range(&#39;2018-03-01 09:00&#39;, periods=3)</span>
<span class="sd">        &gt;&gt;&gt; tz_naive</span>
<span class="sd">        DatetimeIndex([&#39;2018-03-01 09:00:00&#39;, &#39;2018-03-02 09:00:00&#39;,</span>
<span class="sd">                       &#39;2018-03-03 09:00:00&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">        Localize DatetimeIndex in US/Eastern time zone:</span>

<span class="sd">        &gt;&gt;&gt; tz_aware = tz_naive.tz_localize(tz=&#39;US/Eastern&#39;)</span>
<span class="sd">        &gt;&gt;&gt; tz_aware</span>
<span class="sd">        DatetimeIndex([&#39;2018-03-01 09:00:00-05:00&#39;,</span>
<span class="sd">                       &#39;2018-03-02 09:00:00-05:00&#39;,</span>
<span class="sd">                       &#39;2018-03-03 09:00:00-05:00&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns, US/Eastern]&#39;, freq=None)</span>

<span class="sd">        With the ``tz=None``, we can remove the time zone information</span>
<span class="sd">        while keeping the local time (not converted to UTC):</span>

<span class="sd">        &gt;&gt;&gt; tz_aware.tz_localize(None)</span>
<span class="sd">        DatetimeIndex([&#39;2018-03-01 09:00:00&#39;, &#39;2018-03-02 09:00:00&#39;,</span>
<span class="sd">                       &#39;2018-03-03 09:00:00&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">        Be careful with DST changes. When there is sequential data, pandas can</span>
<span class="sd">        infer the DST time:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.to_datetime(pd.Series([&#39;2018-10-28 01:30:00&#39;,</span>
<span class="sd">        ...                               &#39;2018-10-28 02:00:00&#39;,</span>
<span class="sd">        ...                               &#39;2018-10-28 02:30:00&#39;,</span>
<span class="sd">        ...                               &#39;2018-10-28 02:00:00&#39;,</span>
<span class="sd">        ...                               &#39;2018-10-28 02:30:00&#39;,</span>
<span class="sd">        ...                               &#39;2018-10-28 03:00:00&#39;,</span>
<span class="sd">        ...                               &#39;2018-10-28 03:30:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.dt.tz_localize(&#39;CET&#39;, ambiguous=&#39;infer&#39;)</span>
<span class="sd">        0   2018-10-28 01:30:00+02:00</span>
<span class="sd">        1   2018-10-28 02:00:00+02:00</span>
<span class="sd">        2   2018-10-28 02:30:00+02:00</span>
<span class="sd">        3   2018-10-28 02:00:00+01:00</span>
<span class="sd">        4   2018-10-28 02:30:00+01:00</span>
<span class="sd">        5   2018-10-28 03:00:00+01:00</span>
<span class="sd">        6   2018-10-28 03:30:00+01:00</span>
<span class="sd">        dtype: datetime64[ns, CET]</span>

<span class="sd">        In some cases, inferring the DST is impossible. In such cases, you can</span>
<span class="sd">        pass an ndarray to the ambiguous parameter to set the DST explicitly</span>

<span class="sd">        &gt;&gt;&gt; s = pd.to_datetime(pd.Series([&#39;2018-10-28 01:20:00&#39;,</span>
<span class="sd">        ...                               &#39;2018-10-28 02:36:00&#39;,</span>
<span class="sd">        ...                               &#39;2018-10-28 03:46:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.dt.tz_localize(&#39;CET&#39;, ambiguous=np.array([True, True, False]))</span>
<span class="sd">        0   2018-10-28 01:20:00+02:00</span>
<span class="sd">        1   2018-10-28 02:36:00+02:00</span>
<span class="sd">        2   2018-10-28 03:46:00+01:00</span>
<span class="sd">        dtype: datetime64[ns, CET]</span>

<span class="sd">        If the DST transition causes nonexistent times, you can shift these</span>
<span class="sd">        dates forward or backwards with a timedelta object or `&#39;shift_forward&#39;`</span>
<span class="sd">        or `&#39;shift_backwards&#39;`.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.to_datetime(pd.Series([&#39;2015-03-29 02:30:00&#39;,</span>
<span class="sd">        ...                               &#39;2015-03-29 03:30:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.dt.tz_localize(&#39;Europe/Warsaw&#39;, nonexistent=&#39;shift_forward&#39;)</span>
<span class="sd">        0   2015-03-29 03:00:00+02:00</span>
<span class="sd">        1   2015-03-29 03:30:00+02:00</span>
<span class="sd">        dtype: datetime64[ns, Europe/Warsaw]</span>

<span class="sd">        &gt;&gt;&gt; s.dt.tz_localize(&#39;Europe/Warsaw&#39;, nonexistent=&#39;shift_backward&#39;)</span>
<span class="sd">        0   2015-03-29 01:59:59.999999999+01:00</span>
<span class="sd">        1   2015-03-29 03:30:00+02:00</span>
<span class="sd">        dtype: datetime64[ns, Europe/Warsaw]</span>

<span class="sd">        &gt;&gt;&gt; s.dt.tz_localize(&#39;Europe/Warsaw&#39;, nonexistent=pd.Timedelta(&#39;1H&#39;))</span>
<span class="sd">        0   2015-03-29 03:30:00+02:00</span>
<span class="sd">        1   2015-03-29 03:30:00+02:00</span>
<span class="sd">        dtype: datetime64[ns, Europe/Warsaw]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nonexistent_options</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;NaT&quot;</span><span class="p">,</span> <span class="s2">&quot;shift_forward&quot;</span><span class="p">,</span> <span class="s2">&quot;shift_backward&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nonexistent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nonexistent_options</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">nonexistent</span><span class="p">,</span> <span class="n">timedelta</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The nonexistent argument must be one of &#39;raise&#39;, &quot;</span>
                <span class="s2">&quot;&#39;NaT&#39;, &#39;shift_forward&#39;, &#39;shift_backward&#39; or &quot;</span>
                <span class="s2">&quot;a timedelta object&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_dates</span> <span class="o">=</span> <span class="n">tz_convert_from_utc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Already tz-aware, use tz_convert to convert.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">timezones</span><span class="o">.</span><span class="n">maybe_get_tz</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
            <span class="c1"># Convert to UTC</span>

            <span class="n">new_dates</span> <span class="o">=</span> <span class="n">tzconversion</span><span class="o">.</span><span class="n">tz_localize_to_utc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span>
                <span class="n">tz</span><span class="p">,</span>
                <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">,</span>
                <span class="n">nonexistent</span><span class="o">=</span><span class="n">nonexistent</span><span class="p">,</span>
                <span class="n">creso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">new_dates</span> <span class="o">=</span> <span class="n">new_dates</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;M8[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">tz_to_dtype</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="n">freq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">timezones</span><span class="o">.</span><span class="n">is_utc</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isna</span><span class="p">(</span><span class="n">new_dates</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="c1"># we can preserve freq</span>
            <span class="c1"># TODO: Also for fixed-offsets</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
        <span class="k">elif</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no-op</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">new_dates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------</span>
    <span class="c1"># Conversion Methods - Vectorized analogues of Timestamp methods</span>

    <span class="k">def</span> <span class="nf">to_pydatetime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an ndarray of datetime.datetime objects.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ints_to_pydatetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert times to midnight.</span>

<span class="sd">        The time component of the date-time is converted to midnight i.e.</span>
<span class="sd">        00:00:00. This is useful in cases, when the time does not matter.</span>
<span class="sd">        Length is unaltered. The timezones are unaffected.</span>

<span class="sd">        This method is available on Series with datetime values under</span>
<span class="sd">        the ``.dt`` accessor, and directly on Datetime Array/Index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DatetimeArray, DatetimeIndex or Series</span>
<span class="sd">            The same type as the original data. Series will have the same</span>
<span class="sd">            name and index. DatetimeIndex will have the same name.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        floor : Floor the datetimes to the specified freq.</span>
<span class="sd">        ceil : Ceil the datetimes to the specified freq.</span>
<span class="sd">        round : Round the datetimes to the specified freq.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(start=&#39;2014-08-01 10:00&#39;, freq=&#39;H&#39;,</span>
<span class="sd">        ...                     periods=3, tz=&#39;Asia/Calcutta&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2014-08-01 10:00:00+05:30&#39;,</span>
<span class="sd">                       &#39;2014-08-01 11:00:00+05:30&#39;,</span>
<span class="sd">                       &#39;2014-08-01 12:00:00+05:30&#39;],</span>
<span class="sd">                        dtype=&#39;datetime64[ns, Asia/Calcutta]&#39;, freq=&#39;H&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.normalize()</span>
<span class="sd">        DatetimeIndex([&#39;2014-08-01 00:00:00+05:30&#39;,</span>
<span class="sd">                       &#39;2014-08-01 00:00:00+05:30&#39;,</span>
<span class="sd">                       &#39;2014-08-01 00:00:00+05:30&#39;],</span>
<span class="sd">                       dtype=&#39;datetime64[ns, Asia/Calcutta]&#39;, freq=None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">normalize_i8_timestamps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>
        <span class="n">dt64_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndarray</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">dta</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">dt64_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt64_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">dta</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">_with_freq</span><span class="p">(</span><span class="s2">&quot;infer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dta</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dta</span>

    <span class="k">def</span> <span class="nf">to_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PeriodArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast to PeriodArray/Index at a particular frequency.</span>

<span class="sd">        Converts DatetimeArray/Index to PeriodArray/Index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : str or Offset, optional</span>
<span class="sd">            One of pandas&#39; :ref:`offset strings &lt;timeseries.offset_aliases&gt;`</span>
<span class="sd">            or an Offset object. Will be inferred by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PeriodArray/Index</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When converting a DatetimeArray/Index with non-regular values,</span>
<span class="sd">            so that a frequency cannot be inferred.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        PeriodIndex: Immutable ndarray holding ordinal values.</span>
<span class="sd">        DatetimeIndex.to_pydatetime: Return DatetimeIndex as object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;y&quot;: [1, 2, 3]},</span>
<span class="sd">        ...                   index=pd.to_datetime([&quot;2000-03-31 00:00:00&quot;,</span>
<span class="sd">        ...                                         &quot;2000-05-31 00:00:00&quot;,</span>
<span class="sd">        ...                                         &quot;2000-08-31 00:00:00&quot;]))</span>
<span class="sd">        &gt;&gt;&gt; df.index.to_period(&quot;M&quot;)</span>
<span class="sd">        PeriodIndex([&#39;2000-03&#39;, &#39;2000-05&#39;, &#39;2000-08&#39;],</span>
<span class="sd">                    dtype=&#39;period[M]&#39;)</span>

<span class="sd">        Infer the daily frequency</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(&quot;2017-01-01&quot;, periods=2)</span>
<span class="sd">        &gt;&gt;&gt; idx.to_period()</span>
<span class="sd">        PeriodIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;],</span>
<span class="sd">                    dtype=&#39;period[D]&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="n">PeriodArray</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Converting to PeriodArray/Index representation &quot;</span>
                <span class="s2">&quot;will drop timezone information.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqstr</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_freq</span>

            <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;You must pass a freq argument as current index has none.&quot;</span>
                <span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">get_period_alias</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

            <span class="c1">#  https://github.com/pandas-dev/pandas/issues/33358</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">freq</span>

            <span class="n">freq</span> <span class="o">=</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">PeriodArray</span><span class="o">.</span><span class="n">_from_datetime64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndarray</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># Properties - Vectorized Timestamp Properties/Methods</span>

    <span class="k">def</span> <span class="nf">month_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locale</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the month names with specified locale.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        locale : str, optional</span>
<span class="sd">            Locale determining the language in which to return the month name.</span>
<span class="sd">            Default is English locale (``&#39;en_US.utf8&#39;``). Use the command</span>
<span class="sd">            ``locale -a`` on your terminal on Unix systems to find your locale</span>
<span class="sd">            language code.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index</span>
<span class="sd">            Series or Index of month names.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(pd.date_range(start=&#39;2018-01&#39;, freq=&#39;M&#39;, periods=3))</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0   2018-01-31</span>
<span class="sd">        1   2018-02-28</span>
<span class="sd">        2   2018-03-31</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; s.dt.month_name()</span>
<span class="sd">        0     January</span>
<span class="sd">        1    February</span>
<span class="sd">        2       March</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(start=&#39;2018-01&#39;, freq=&#39;M&#39;, periods=3)</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-02-28&#39;, &#39;2018-03-31&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.month_name()</span>
<span class="sd">        Index([&#39;January&#39;, &#39;February&#39;, &#39;March&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        Using the ``locale`` parameter you can set a different locale language,</span>
<span class="sd">        for example: ``idx.month_name(locale=&#39;pt_BR.utf8&#39;)`` will return month</span>
<span class="sd">        names in Brazilian Portuguese language.</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(start=&#39;2018-01&#39;, freq=&#39;M&#39;, periods=3)</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-02-28&#39;, &#39;2018-03-31&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.month_name(locale=&#39;pt_BR.utf8&#39;) # doctest: +SKIP</span>
<span class="sd">        Index([&#39;Janeiro&#39;, &#39;Fevereiro&#39;, &#39;Maro&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_timestamps</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get_date_name_field</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span> <span class="s2">&quot;month_name&quot;</span><span class="p">,</span> <span class="n">locale</span><span class="o">=</span><span class="n">locale</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_mask_results</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">day_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locale</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the day names with specified locale.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        locale : str, optional</span>
<span class="sd">            Locale determining the language in which to return the day name.</span>
<span class="sd">            Default is English locale (``&#39;en_US.utf8&#39;``). Use the command</span>
<span class="sd">            ``locale -a`` on your terminal on Unix systems to find your locale</span>
<span class="sd">            language code.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or Index</span>
<span class="sd">            Series or Index of day names.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(pd.date_range(start=&#39;2018-01-01&#39;, freq=&#39;D&#39;, periods=3))</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0   2018-01-01</span>
<span class="sd">        1   2018-01-02</span>
<span class="sd">        2   2018-01-03</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; s.dt.day_name()</span>
<span class="sd">        0       Monday</span>
<span class="sd">        1      Tuesday</span>
<span class="sd">        2    Wednesday</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(start=&#39;2018-01-01&#39;, freq=&#39;D&#39;, periods=3)</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.day_name()</span>
<span class="sd">        Index([&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        Using the ``locale`` parameter you can set a different locale language,</span>
<span class="sd">        for example: ``idx.day_name(locale=&#39;pt_BR.utf8&#39;)`` will return day</span>
<span class="sd">        names in Brazilian Portuguese language.</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(start=&#39;2018-01-01&#39;, freq=&#39;D&#39;, periods=3)</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.day_name(locale=&#39;pt_BR.utf8&#39;) # doctest: +SKIP</span>
<span class="sd">        Index([&#39;Segunda&#39;, &#39;Tera&#39;, &#39;Quarta&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_timestamps</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get_date_name_field</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span> <span class="s2">&quot;day_name&quot;</span><span class="p">,</span> <span class="n">locale</span><span class="o">=</span><span class="n">locale</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_mask_results</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns numpy array of :class:`datetime.time` objects.</span>

<span class="sd">        The time part of the Timestamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the Timestamps have a timezone that is not UTC,</span>
        <span class="c1"># convert them into their i8 representation while</span>
        <span class="c1"># keeping their timezone and not using UTC</span>
        <span class="n">timestamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_timestamps</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ints_to_pydatetime</span><span class="p">(</span><span class="n">timestamps</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timetz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns numpy array of :class:`datetime.time` objects with timezones.</span>

<span class="sd">        The time part of the Timestamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ints_to_pydatetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">date</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns numpy array of python :class:`datetime.date` objects.</span>

<span class="sd">        Namely, the date part of Timestamps without time and</span>
<span class="sd">        timezone information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the Timestamps have a timezone that is not UTC,</span>
        <span class="c1"># convert them into their i8 representation while</span>
        <span class="c1"># keeping their timezone and not using UTC</span>
        <span class="n">timestamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_timestamps</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ints_to_pydatetime</span><span class="p">(</span><span class="n">timestamps</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isocalendar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate year, week, and day according to the ISO 8601 standard.</span>

<span class="sd">        .. versionadded:: 1.1.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            With columns year, week and day.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Timestamp.isocalendar : Function return a 3-tuple containing ISO year,</span>
<span class="sd">            week number, and weekday for the given Timestamp object.</span>
<span class="sd">        datetime.date.isocalendar : Return a named tuple object with</span>
<span class="sd">            three components: year, week and weekday.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(start=&#39;2019-12-29&#39;, freq=&#39;D&#39;, periods=4)</span>
<span class="sd">        &gt;&gt;&gt; idx.isocalendar()</span>
<span class="sd">                    year  week  day</span>
<span class="sd">        2019-12-29  2019    52    7</span>
<span class="sd">        2019-12-30  2020     1    1</span>
<span class="sd">        2019-12-31  2020     1    2</span>
<span class="sd">        2020-01-01  2020     1    3</span>
<span class="sd">        &gt;&gt;&gt; idx.isocalendar().week</span>
<span class="sd">        2019-12-29    52</span>
<span class="sd">        2019-12-30     1</span>
<span class="sd">        2019-12-31     1</span>
<span class="sd">        2020-01-01     1</span>
<span class="sd">        Freq: D, Name: week, dtype: UInt32</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_timestamps</span><span class="p">()</span>
        <span class="n">sarray</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">build_isocalendar_sarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">reso</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_creso</span><span class="p">)</span>
        <span class="n">iso_calendar_df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">sarray</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="s2">&quot;week&quot;</span><span class="p">,</span> <span class="s2">&quot;day&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;UInt32&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hasna</span><span class="p">:</span>
            <span class="n">iso_calendar_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">iso_calendar_df</span>

    <span class="n">year</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Y&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The year of the datetime.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; datetime_series = pd.Series(</span>
<span class="sd">        ...     pd.date_range(&quot;2000-01-01&quot;, periods=3, freq=&quot;Y&quot;)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; datetime_series</span>
<span class="sd">        0   2000-12-31</span>
<span class="sd">        1   2001-12-31</span>
<span class="sd">        2   2002-12-31</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; datetime_series.dt.year</span>
<span class="sd">        0    2000</span>
<span class="sd">        1    2001</span>
<span class="sd">        2    2002</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">month</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;month&quot;</span><span class="p">,</span>
        <span class="s2">&quot;M&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The month as January=1, December=12.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; datetime_series = pd.Series(</span>
<span class="sd">        ...     pd.date_range(&quot;2000-01-01&quot;, periods=3, freq=&quot;M&quot;)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; datetime_series</span>
<span class="sd">        0   2000-01-31</span>
<span class="sd">        1   2000-02-29</span>
<span class="sd">        2   2000-03-31</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; datetime_series.dt.month</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">day</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;day&quot;</span><span class="p">,</span>
        <span class="s2">&quot;D&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The day of the datetime.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; datetime_series = pd.Series(</span>
<span class="sd">        ...     pd.date_range(&quot;2000-01-01&quot;, periods=3, freq=&quot;D&quot;)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; datetime_series</span>
<span class="sd">        0   2000-01-01</span>
<span class="sd">        1   2000-01-02</span>
<span class="sd">        2   2000-01-03</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; datetime_series.dt.day</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">hour</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;hour&quot;</span><span class="p">,</span>
        <span class="s2">&quot;h&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The hours of the datetime.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; datetime_series = pd.Series(</span>
<span class="sd">        ...     pd.date_range(&quot;2000-01-01&quot;, periods=3, freq=&quot;h&quot;)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; datetime_series</span>
<span class="sd">        0   2000-01-01 00:00:00</span>
<span class="sd">        1   2000-01-01 01:00:00</span>
<span class="sd">        2   2000-01-01 02:00:00</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; datetime_series.dt.hour</span>
<span class="sd">        0    0</span>
<span class="sd">        1    1</span>
<span class="sd">        2    2</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">minute</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;minute&quot;</span><span class="p">,</span>
        <span class="s2">&quot;m&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The minutes of the datetime.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; datetime_series = pd.Series(</span>
<span class="sd">        ...     pd.date_range(&quot;2000-01-01&quot;, periods=3, freq=&quot;T&quot;)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; datetime_series</span>
<span class="sd">        0   2000-01-01 00:00:00</span>
<span class="sd">        1   2000-01-01 00:01:00</span>
<span class="sd">        2   2000-01-01 00:02:00</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; datetime_series.dt.minute</span>
<span class="sd">        0    0</span>
<span class="sd">        1    1</span>
<span class="sd">        2    2</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">second</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;second&quot;</span><span class="p">,</span>
        <span class="s2">&quot;s&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The seconds of the datetime.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; datetime_series = pd.Series(</span>
<span class="sd">        ...     pd.date_range(&quot;2000-01-01&quot;, periods=3, freq=&quot;s&quot;)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; datetime_series</span>
<span class="sd">        0   2000-01-01 00:00:00</span>
<span class="sd">        1   2000-01-01 00:00:01</span>
<span class="sd">        2   2000-01-01 00:00:02</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; datetime_series.dt.second</span>
<span class="sd">        0    0</span>
<span class="sd">        1    1</span>
<span class="sd">        2    2</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">microsecond</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;microsecond&quot;</span><span class="p">,</span>
        <span class="s2">&quot;us&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The microseconds of the datetime.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; datetime_series = pd.Series(</span>
<span class="sd">        ...     pd.date_range(&quot;2000-01-01&quot;, periods=3, freq=&quot;us&quot;)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; datetime_series</span>
<span class="sd">        0   2000-01-01 00:00:00.000000</span>
<span class="sd">        1   2000-01-01 00:00:00.000001</span>
<span class="sd">        2   2000-01-01 00:00:00.000002</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; datetime_series.dt.microsecond</span>
<span class="sd">        0       0</span>
<span class="sd">        1       1</span>
<span class="sd">        2       2</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">nanosecond</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;nanosecond&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ns&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The nanoseconds of the datetime.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; datetime_series = pd.Series(</span>
<span class="sd">        ...     pd.date_range(&quot;2000-01-01&quot;, periods=3, freq=&quot;ns&quot;)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; datetime_series</span>
<span class="sd">        0   2000-01-01 00:00:00.000000000</span>
<span class="sd">        1   2000-01-01 00:00:00.000000001</span>
<span class="sd">        2   2000-01-01 00:00:00.000000002</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; datetime_series.dt.nanosecond</span>
<span class="sd">        0       0</span>
<span class="sd">        1       1</span>
<span class="sd">        2       2</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">_dayofweek_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    The day of the week with Monday=0, Sunday=6.</span>

<span class="s2">    Return the day of the week. It is assumed the week starts on</span>
<span class="s2">    Monday, which is denoted by 0 and ends on Sunday which is denoted</span>
<span class="s2">    by 6. This method is available on both Series with datetime</span>
<span class="s2">    values (using the `dt` accessor) or DatetimeIndex.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    Series or Index</span>
<span class="s2">        Containing integers indicating the day number.</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    Series.dt.dayofweek : Alias.</span>
<span class="s2">    Series.dt.weekday : Alias.</span>
<span class="s2">    Series.dt.day_name : Returns the name of the day of the week.</span>

<span class="s2">    Examples</span>
<span class="s2">    --------</span>
<span class="s2">    &gt;&gt;&gt; s = pd.date_range(&#39;2016-12-31&#39;, &#39;2017-01-08&#39;, freq=&#39;D&#39;).to_series()</span>
<span class="s2">    &gt;&gt;&gt; s.dt.dayofweek</span>
<span class="s2">    2016-12-31    5</span>
<span class="s2">    2017-01-01    6</span>
<span class="s2">    2017-01-02    0</span>
<span class="s2">    2017-01-03    1</span>
<span class="s2">    2017-01-04    2</span>
<span class="s2">    2017-01-05    3</span>
<span class="s2">    2017-01-06    4</span>
<span class="s2">    2017-01-07    5</span>
<span class="s2">    2017-01-08    6</span>
<span class="s2">    Freq: D, dtype: int32</span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="n">day_of_week</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span><span class="s2">&quot;day_of_week&quot;</span><span class="p">,</span> <span class="s2">&quot;dow&quot;</span><span class="p">,</span> <span class="n">_dayofweek_doc</span><span class="p">)</span>
    <span class="n">dayofweek</span> <span class="o">=</span> <span class="n">day_of_week</span>
    <span class="n">weekday</span> <span class="o">=</span> <span class="n">day_of_week</span>

    <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;dayofyear&quot;</span><span class="p">,</span>
        <span class="s2">&quot;doy&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ordinal day of the year.</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">dayofyear</span> <span class="o">=</span> <span class="n">day_of_year</span>
    <span class="n">quarter</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;quarter&quot;</span><span class="p">,</span>
        <span class="s2">&quot;q&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The quarter of the date.</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">days_in_month</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;days_in_month&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dim&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of days in the month.</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">daysinmonth</span> <span class="o">=</span> <span class="n">days_in_month</span>
    <span class="n">_is_month_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Indicates whether the date is the </span><span class="si">{first_or_last}</span><span class="s2"> day of the month.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        Series or array</span>
<span class="s2">            For Series, returns a Series with boolean values.</span>
<span class="s2">            For DatetimeIndex, returns a boolean array.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        is_month_start : Return a boolean indicating whether the date</span>
<span class="s2">            is the first day of the month.</span>
<span class="s2">        is_month_end : Return a boolean indicating whether the date</span>
<span class="s2">            is the last day of the month.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        This method is available on Series with datetime values under</span>
<span class="s2">        the ``.dt`` accessor, and directly on DatetimeIndex.</span>

<span class="s2">        &gt;&gt;&gt; s = pd.Series(pd.date_range(&quot;2018-02-27&quot;, periods=3))</span>
<span class="s2">        &gt;&gt;&gt; s</span>
<span class="s2">        0   2018-02-27</span>
<span class="s2">        1   2018-02-28</span>
<span class="s2">        2   2018-03-01</span>
<span class="s2">        dtype: datetime64[ns]</span>
<span class="s2">        &gt;&gt;&gt; s.dt.is_month_start</span>
<span class="s2">        0    False</span>
<span class="s2">        1    False</span>
<span class="s2">        2    True</span>
<span class="s2">        dtype: bool</span>
<span class="s2">        &gt;&gt;&gt; s.dt.is_month_end</span>
<span class="s2">        0    False</span>
<span class="s2">        1    True</span>
<span class="s2">        2    False</span>
<span class="s2">        dtype: bool</span>

<span class="s2">        &gt;&gt;&gt; idx = pd.date_range(&quot;2018-02-27&quot;, periods=3)</span>
<span class="s2">        &gt;&gt;&gt; idx.is_month_start</span>
<span class="s2">        array([False, False, True])</span>
<span class="s2">        &gt;&gt;&gt; idx.is_month_end</span>
<span class="s2">        array([False, True, False])</span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="n">is_month_start</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;is_month_start&quot;</span><span class="p">,</span> <span class="s2">&quot;is_month_start&quot;</span><span class="p">,</span> <span class="n">_is_month_doc</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">first_or_last</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">is_month_end</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;is_month_end&quot;</span><span class="p">,</span> <span class="s2">&quot;is_month_end&quot;</span><span class="p">,</span> <span class="n">_is_month_doc</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">first_or_last</span><span class="o">=</span><span class="s2">&quot;last&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">is_quarter_start</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;is_quarter_start&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_quarter_start&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicator for whether the date is the first day of a quarter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_quarter_start : Series or DatetimeIndex</span>
<span class="sd">            The same type as the original data with boolean values. Series will</span>
<span class="sd">            have the same name and index. DatetimeIndex will have the same</span>
<span class="sd">            name.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        quarter : Return the quarter of the date.</span>
<span class="sd">        is_quarter_end : Similar property for indicating the quarter end.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This method is available on Series with datetime values under</span>
<span class="sd">        the ``.dt`` accessor, and directly on DatetimeIndex.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;dates&#39;: pd.date_range(&quot;2017-03-30&quot;,</span>
<span class="sd">        ...                   periods=4)})</span>
<span class="sd">        &gt;&gt;&gt; df.assign(quarter=df.dates.dt.quarter,</span>
<span class="sd">        ...           is_quarter_start=df.dates.dt.is_quarter_start)</span>
<span class="sd">               dates  quarter  is_quarter_start</span>
<span class="sd">        0 2017-03-30        1             False</span>
<span class="sd">        1 2017-03-31        1             False</span>
<span class="sd">        2 2017-04-01        2              True</span>
<span class="sd">        3 2017-04-02        2             False</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(&#39;2017-03-30&#39;, periods=4)</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2017-03-30&#39;, &#39;2017-03-31&#39;, &#39;2017-04-01&#39;, &#39;2017-04-02&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx.is_quarter_start</span>
<span class="sd">        array([False, False,  True, False])</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">is_quarter_end</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;is_quarter_end&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_quarter_end&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicator for whether the date is the last day of a quarter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_quarter_end : Series or DatetimeIndex</span>
<span class="sd">            The same type as the original data with boolean values. Series will</span>
<span class="sd">            have the same name and index. DatetimeIndex will have the same</span>
<span class="sd">            name.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        quarter : Return the quarter of the date.</span>
<span class="sd">        is_quarter_start : Similar property indicating the quarter start.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This method is available on Series with datetime values under</span>
<span class="sd">        the ``.dt`` accessor, and directly on DatetimeIndex.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;dates&#39;: pd.date_range(&quot;2017-03-30&quot;,</span>
<span class="sd">        ...                    periods=4)})</span>
<span class="sd">        &gt;&gt;&gt; df.assign(quarter=df.dates.dt.quarter,</span>
<span class="sd">        ...           is_quarter_end=df.dates.dt.is_quarter_end)</span>
<span class="sd">               dates  quarter    is_quarter_end</span>
<span class="sd">        0 2017-03-30        1             False</span>
<span class="sd">        1 2017-03-31        1              True</span>
<span class="sd">        2 2017-04-01        2             False</span>
<span class="sd">        3 2017-04-02        2             False</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(&#39;2017-03-30&#39;, periods=4)</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2017-03-30&#39;, &#39;2017-03-31&#39;, &#39;2017-04-01&#39;, &#39;2017-04-02&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx.is_quarter_end</span>
<span class="sd">        array([False,  True, False, False])</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">is_year_start</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;is_year_start&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_year_start&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicate whether the date is the first day of a year.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DatetimeIndex</span>
<span class="sd">            The same type as the original data with boolean values. Series will</span>
<span class="sd">            have the same name and index. DatetimeIndex will have the same</span>
<span class="sd">            name.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        is_year_end : Similar property indicating the last day of the year.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This method is available on Series with datetime values under</span>
<span class="sd">        the ``.dt`` accessor, and directly on DatetimeIndex.</span>

<span class="sd">        &gt;&gt;&gt; dates = pd.Series(pd.date_range(&quot;2017-12-30&quot;, periods=3))</span>
<span class="sd">        &gt;&gt;&gt; dates</span>
<span class="sd">        0   2017-12-30</span>
<span class="sd">        1   2017-12-31</span>
<span class="sd">        2   2018-01-01</span>
<span class="sd">        dtype: datetime64[ns]</span>

<span class="sd">        &gt;&gt;&gt; dates.dt.is_year_start</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2    True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(&quot;2017-12-30&quot;, periods=3)</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2017-12-30&#39;, &#39;2017-12-31&#39;, &#39;2018-01-01&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx.is_year_start</span>
<span class="sd">        array([False, False,  True])</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">is_year_end</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;is_year_end&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_year_end&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicate whether the date is the last day of the year.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DatetimeIndex</span>
<span class="sd">            The same type as the original data with boolean values. Series will</span>
<span class="sd">            have the same name and index. DatetimeIndex will have the same</span>
<span class="sd">            name.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        is_year_start : Similar property indicating the start of the year.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This method is available on Series with datetime values under</span>
<span class="sd">        the ``.dt`` accessor, and directly on DatetimeIndex.</span>

<span class="sd">        &gt;&gt;&gt; dates = pd.Series(pd.date_range(&quot;2017-12-30&quot;, periods=3))</span>
<span class="sd">        &gt;&gt;&gt; dates</span>
<span class="sd">        0   2017-12-30</span>
<span class="sd">        1   2017-12-31</span>
<span class="sd">        2   2018-01-01</span>
<span class="sd">        dtype: datetime64[ns]</span>

<span class="sd">        &gt;&gt;&gt; dates.dt.is_year_end</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(&quot;2017-12-30&quot;, periods=3)</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2017-12-30&#39;, &#39;2017-12-31&#39;, &#39;2018-01-01&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx.is_year_end</span>
<span class="sd">        array([False,  True, False])</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">is_leap_year</span> <span class="o">=</span> <span class="n">_field_accessor</span><span class="p">(</span>
        <span class="s2">&quot;is_leap_year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_leap_year&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Boolean indicator if the date belongs to a leap year.</span>

<span class="sd">        A leap year is a year, which has 366 days (instead of 365) including</span>
<span class="sd">        29th of February as an intercalary day.</span>
<span class="sd">        Leap years are years which are multiples of four with the exception</span>
<span class="sd">        of years divisible by 100 but not by 400.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or ndarray</span>
<span class="sd">             Booleans indicating if dates belong to a leap year.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This method is available on Series with datetime values under</span>
<span class="sd">        the ``.dt`` accessor, and directly on DatetimeIndex.</span>

<span class="sd">        &gt;&gt;&gt; idx = pd.date_range(&quot;2012-01-01&quot;, &quot;2015-01-01&quot;, freq=&quot;Y&quot;)</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2012-12-31&#39;, &#39;2013-12-31&#39;, &#39;2014-12-31&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;A-DEC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.is_leap_year</span>
<span class="sd">        array([ True, False, False])</span>

<span class="sd">        &gt;&gt;&gt; dates_series = pd.Series(idx)</span>
<span class="sd">        &gt;&gt;&gt; dates_series</span>
<span class="sd">        0   2012-12-31</span>
<span class="sd">        1   2013-12-31</span>
<span class="sd">        2   2014-12-31</span>
<span class="sd">        dtype: datetime64[ns]</span>
<span class="sd">        &gt;&gt;&gt; dates_series.dt.is_leap_year</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_julian_date</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert Datetime Array to float64 ndarray of Julian Dates.</span>
<span class="sd">        0 Julian date is noon January 1, 4713 BC.</span>
<span class="sd">        https://en.wikipedia.org/wiki/Julian_day</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># http://mysite.verizon.net/aesir_research/date/jdalg2.htm</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
        <span class="n">month</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">month</span><span class="p">)</span>
        <span class="n">day</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">day</span><span class="p">)</span>
        <span class="n">testarr</span> <span class="o">=</span> <span class="n">month</span> <span class="o">&lt;</span> <span class="mi">3</span>
        <span class="n">year</span><span class="p">[</span><span class="n">testarr</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">month</span><span class="p">[</span><span class="n">testarr</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">12</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">day</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">((</span><span class="mi">153</span> <span class="o">*</span> <span class="n">month</span> <span class="o">-</span> <span class="mi">457</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span>
            <span class="o">+</span> <span class="mi">365</span> <span class="o">*</span> <span class="n">year</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">year</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">year</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">year</span> <span class="o">/</span> <span class="mi">400</span><span class="p">)</span>
            <span class="o">+</span> <span class="mf">1_721_118.5</span>
            <span class="o">+</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hour</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">minute</span> <span class="o">/</span> <span class="mi">60</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">/</span> <span class="mi">3600</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mi">3600</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nanosecond</span> <span class="o">/</span> <span class="mi">3600</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span>
            <span class="p">)</span>
            <span class="o">/</span> <span class="mi">24</span>
        <span class="p">)</span>

    <span class="c1"># -----------------------------------------------------------------</span>
    <span class="c1"># Reductions</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sample standard deviation over requested axis.</span>

<span class="sd">        Normalized by N-1 by default. This can be changed using the ddof argument</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int optional, default None</span>
<span class="sd">            Axis for the function to be applied on.</span>
<span class="sd">            For `Series` this parameter is unused and defaults to `None`.</span>
<span class="sd">        ddof : int, default 1</span>
<span class="sd">            Degrees of Freedom. The divisor used in calculations is N - ddof,</span>
<span class="sd">            where N represents the number of elements.</span>
<span class="sd">        skipna : bool, default True</span>
<span class="sd">            Exclude NA/null values. If an entire row/column is NA, the result will be</span>
<span class="sd">            NA.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Timedelta</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Because std is translation-invariant, we can get self.std</span>
        <span class="c1">#  by calculating (self - Timestamp(0)).std, and we can do it</span>
        <span class="c1">#  without creating a copy by using a view on self._ndarray</span>
        <span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="n">TimedeltaArray</span>

        <span class="c1"># Find the td64 dtype with the same resolution as our dt64 dtype</span>
        <span class="n">dtype_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ndarray</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;datetime64&quot;</span><span class="p">,</span> <span class="s2">&quot;timedelta64&quot;</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype_str</span><span class="p">)</span>

        <span class="n">tda</span> <span class="o">=</span> <span class="n">TimedeltaArray</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tda</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>


<span class="c1"># -------------------------------------------------------------------</span>
<span class="c1"># Constructor Helpers</span>


<span class="k">def</span> <span class="nf">_sequence_to_dt64ns</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">tz</span><span class="p">:</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dayfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">yearfirst</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">ambiguous</span><span class="p">:</span> <span class="n">TimeAmbiguous</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="n">out_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list-like</span>
<span class="sd">    copy : bool, default False</span>
<span class="sd">    tz : tzinfo or None, default None</span>
<span class="sd">    dayfirst : bool, default False</span>
<span class="sd">    yearfirst : bool, default False</span>
<span class="sd">    ambiguous : str, bool, or arraylike, default &#39;raise&#39;</span>
<span class="sd">        See pandas._libs.tslibs.tzconversion.tz_localize_to_utc.</span>
<span class="sd">    out_unit : str or None, default None</span>
<span class="sd">        Desired output resolution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : numpy.ndarray</span>
<span class="sd">        The sequence converted to a numpy array with dtype ``datetime64[ns]``.</span>
<span class="sd">    tz : tzinfo or None</span>
<span class="sd">        Either the user-provided tzinfo or one inferred from the data.</span>
<span class="sd">    inferred_freq : Tick or None</span>
<span class="sd">        The inferred frequency of the sequence.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError : PeriodDType data is passed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inferred_freq</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">data</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">dtl</span><span class="o">.</span><span class="n">ensure_arraylike_for_datetimelike</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">cls_name</span><span class="o">=</span><span class="s2">&quot;DatetimeArray&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DatetimeArray</span><span class="p">):</span>
        <span class="n">inferred_freq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span>

    <span class="c1"># By this point we are assured to have either a numpy array or Index</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">maybe_convert_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
    <span class="n">data_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">DT64NS_DTYPE</span>
    <span class="k">if</span> <span class="n">out_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;M8[</span><span class="si">{</span><span class="n">out_unit</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">data_dtype</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">is_string_dtype</span><span class="p">(</span><span class="n">data_dtype</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">is_sparse</span><span class="p">(</span><span class="n">data_dtype</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="c1"># TODO: We do not have tests specific to string-dtypes,</span>
        <span class="c1">#  also complex or categorical or other extension</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;integer&quot;</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ambiguous</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: yearfirst/dayfirst/etc?</span>
            <span class="n">obj_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">i8data</span> <span class="o">=</span> <span class="n">tslib</span><span class="o">.</span><span class="n">array_to_datetime_with_tz</span><span class="p">(</span><span class="n">obj_data</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i8data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">DT64NS_DTYPE</span><span class="p">),</span> <span class="n">tz</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># data comes back here as either i8 to denote UTC timestamps</span>
            <span class="c1">#  or M8[ns] to denote wall times</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">inferred_tz</span> <span class="o">=</span> <span class="n">objects_to_datetime64ns</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span>
                <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">,</span>
                <span class="n">allow_object</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">tz</span> <span class="ow">and</span> <span class="n">inferred_tz</span><span class="p">:</span>
                <span class="c1">#  two timezones: convert to intended from base UTC repr</span>
                <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;i8&quot;</span>
                <span class="c1"># GH#42505</span>
                <span class="c1"># by convention, these are _already_ UTC, e.g</span>
                <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">DT64NS_DTYPE</span><span class="p">),</span> <span class="n">tz</span><span class="p">,</span> <span class="kc">None</span>

            <span class="k">elif</span> <span class="n">inferred_tz</span><span class="p">:</span>
                <span class="n">tz</span> <span class="o">=</span> <span class="n">inferred_tz</span>

        <span class="n">data_dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># `data` may have originally been a Categorical[datetime64[ns, tz]],</span>
    <span class="c1"># so we need to handle these types.</span>
    <span class="k">if</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">data_dtype</span><span class="p">):</span>
        <span class="c1"># DatetimeArray -&gt; ndarray</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">_maybe_infer_tz</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_ndarray</span>

    <span class="k">elif</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">data_dtype</span><span class="p">):</span>
        <span class="c1"># tz-naive DatetimeArray or ndarray[datetime64]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;_ndarray&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">data_unit</span> <span class="o">=</span> <span class="n">get_unit_from_dtype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_supported_unit</span><span class="p">(</span><span class="n">data_unit</span><span class="p">):</span>
            <span class="c1"># Cast to the nearest supported unit, generally &quot;s&quot;</span>
            <span class="n">new_reso</span> <span class="o">=</span> <span class="n">get_supported_reso</span><span class="p">(</span><span class="n">data_unit</span><span class="p">)</span>
            <span class="n">new_unit</span> <span class="o">=</span> <span class="n">npy_unit_to_abbrev</span><span class="p">(</span><span class="n">new_reso</span><span class="p">)</span>
            <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;M8[</span><span class="si">{</span><span class="n">new_unit</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">astype_overflowsafe</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">data_unit</span> <span class="o">=</span> <span class="n">get_unit_from_dtype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: better way to handle this?  non-copying alternative?</span>
            <span class="c1">#  without this, test_constructor_datetime64_bigendian fails</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">))</span>
            <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Convert tz-naive to UTC</span>
            <span class="c1"># TODO: if tz is UTC, are there situations where we *don&#39;t* want a</span>
            <span class="c1">#  copy?  tz_localize_to_utc always makes one.</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">tzconversion</span><span class="o">.</span><span class="n">tz_localize_to_utc</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">),</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">,</span> <span class="n">creso</span><span class="o">=</span><span class="n">data_unit</span>
            <span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">new_dtype</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># must be integer dtype otherwise</span>
        <span class="c1"># assume this data are epoch timestamps</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">INT64_DTYPE</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span>
    <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;M8&quot;</span>
    <span class="k">assert</span> <span class="n">is_supported_unit</span><span class="p">(</span><span class="n">get_unit_from_dtype</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">inferred_freq</span>


<span class="k">def</span> <span class="nf">objects_to_datetime64ns</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">dayfirst</span><span class="p">,</span>
    <span class="n">yearfirst</span><span class="p">,</span>
    <span class="n">utc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">errors</span><span class="p">:</span> <span class="n">DateTimeErrorChoices</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="n">allow_object</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert data to array of timestamps.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray[object]</span>
<span class="sd">    dayfirst : bool</span>
<span class="sd">    yearfirst : bool</span>
<span class="sd">    utc : bool, default False</span>
<span class="sd">        Whether to convert/localize timestamps to UTC.</span>
<span class="sd">    errors : {&#39;raise&#39;, &#39;ignore&#39;, &#39;coerce&#39;}</span>
<span class="sd">    allow_object : bool</span>
<span class="sd">        Whether to return an object-dtype ndarray instead of raising if the</span>
<span class="sd">        data contains more than one timezone.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray</span>
<span class="sd">        np.int64 dtype if returned values represent UTC timestamps</span>
<span class="sd">        np.datetime64[ns] if returned values represent wall times</span>
<span class="sd">        object if mixed timezones</span>
<span class="sd">    inferred_tz : tzinfo or None</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError : if data cannot be converted to datetimes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">errors</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="s2">&quot;coerce&quot;</span><span class="p">]</span>

    <span class="c1"># if str-dtype, convert</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>

    <span class="n">result</span><span class="p">,</span> <span class="n">tz_parsed</span> <span class="o">=</span> <span class="n">tslib</span><span class="o">.</span><span class="n">array_to_datetime</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
        <span class="n">utc</span><span class="o">=</span><span class="n">utc</span><span class="p">,</span>
        <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span>
        <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">tz_parsed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># We can take a shortcut since the datetime64 numpy array</span>
        <span class="c1">#  is in UTC</span>
        <span class="c1"># Return i8 values to denote unix timestamps</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">),</span> <span class="n">tz_parsed</span>
    <span class="k">elif</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
        <span class="c1"># returning M8[ns] denotes wall-times; since tz is None</span>
        <span class="c1">#  the distinction is a thin one</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">tz_parsed</span>
    <span class="k">elif</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
        <span class="c1"># GH#23675 when called via `pd.to_datetime`, returning an object-dtype</span>
        <span class="c1">#  array is allowed.  When called via `pd.DatetimeIndex`, we can</span>
        <span class="c1">#  only accept datetime64 dtype, so raise TypeError if object-dtype</span>
        <span class="c1">#  is returned, as that indicates the values can be recognized as</span>
        <span class="c1">#  datetimes but they have conflicting timezones/awareness</span>
        <span class="k">if</span> <span class="n">allow_object</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">tz_parsed</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># GH#23675 this TypeError should never be hit, whereas the TypeError</span>
        <span class="c1">#  in the object-dtype branch above is reachable.</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">maybe_convert_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">tz</span><span class="p">:</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert data based on dtype conventions, issuing</span>
<span class="sd">    errors where appropriate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray or pd.Index</span>
<span class="sd">    copy : bool</span>
<span class="sd">    tz : tzinfo or None, default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : np.ndarray or pd.Index</span>
<span class="sd">    copy : bool</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError : PeriodDType data is passed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">):</span>
        <span class="c1"># e.g. collections.deque</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">copy</span>

    <span class="k">if</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># pre-2.0 we treated these as wall-times, inconsistent with ints</span>
        <span class="c1"># GH#23675, GH#45573 deprecated to treat symmetrically with integer dtypes.</span>
        <span class="c1"># Note: data.astype(np.int64) fails ARM tests, see</span>
        <span class="c1"># https://github.com/pandas-dev/pandas/issues/49468.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">DT64NS_DTYPE</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">elif</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># GH#29794 enforcing deprecation introduced in GH#23539</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dtype </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> cannot be converted to datetime64[ns]&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_period_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># Note: without explicitly raising here, PeriodIndex</span>
        <span class="c1">#  test_setops.test_join_does_not_recur fails</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Passing PeriodDtype data is invalid. Use `data.to_timestamp()` instead&quot;</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># TODO: We have no tests for these</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">copy</span>


<span class="c1"># -------------------------------------------------------------------</span>
<span class="c1"># Validation and Inference</span>


<span class="k">def</span> <span class="nf">_maybe_infer_tz</span><span class="p">(</span><span class="n">tz</span><span class="p">:</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inferred_tz</span><span class="p">:</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If a timezone is inferred from data, check that it is compatible with</span>
<span class="sd">    the user-provided timezone, if any.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tz : tzinfo or None</span>
<span class="sd">    inferred_tz : tzinfo or None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tz : tzinfo or None</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError : if both timezones are present but do not match</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">inferred_tz</span>
    <span class="k">elif</span> <span class="n">inferred_tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">timezones</span><span class="o">.</span><span class="n">tz_compare</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">inferred_tz</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;data is already tz-aware </span><span class="si">{</span><span class="n">inferred_tz</span><span class="si">}</span><span class="s2">, unable to &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;set specified tz: </span><span class="si">{</span><span class="n">tz</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">tz</span>


<span class="k">def</span> <span class="nf">_validate_dt64_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check that a dtype, if passed, represents either a numpy datetime64[ns]</span>
<span class="sd">    dtype or a pandas DatetimeTZDtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dtype : object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dtype : None, numpy.dtype, or DatetimeTZDtype</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError : invalid dtype</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Unlike _validate_tz_from_dtype, this does _not_ allow non-existent</span>
<span class="sd">    tz errors to go through</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;M8&quot;</span><span class="p">)):</span>
            <span class="c1"># no precision, disallowed GH#24806</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Passing in &#39;datetime64&#39; dtype with no precision is not allowed. &quot;</span>
                <span class="s2">&quot;Please pass in &#39;datetime64[ns]&#39; instead.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s2">&quot;M&quot;</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_supported_unit</span><span class="p">(</span><span class="n">get_unit_from_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)))</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">DatetimeTZDtype</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected value for &#39;dtype&#39;: &#39;</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="s2">&quot;Must be &#39;datetime64[s]&#39;, &#39;datetime64[ms]&#39;, &#39;datetime64[us]&#39;, &quot;</span>
                <span class="s2">&quot;&#39;datetime64[ns]&#39; or DatetimeTZDtype&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;tz&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># https://github.com/pandas-dev/pandas/issues/18595</span>
            <span class="c1"># Ensure that we have a standard timezone for pytz objects.</span>
            <span class="c1"># Without this, things like adding an array of timedeltas and</span>
            <span class="c1"># a  tz-aware Timestamp (with a tz specific to its datetime) will</span>
            <span class="c1"># be incorrect(ish?) for the array as a whole</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DatetimeTZDtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">DatetimeTZDtype</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">timezones</span><span class="o">.</span><span class="n">tz_standardize</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">tz</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">dtype</span>


<span class="k">def</span> <span class="nf">_validate_tz_from_dtype</span><span class="p">(</span>
    <span class="n">dtype</span><span class="p">,</span> <span class="n">tz</span><span class="p">:</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">explicit_tz_none</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If the given dtype is a DatetimeTZDtype, extract the implied</span>
<span class="sd">    tzinfo object from it and check that it does not conflict with the given</span>
<span class="sd">    tz.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dtype : dtype, str</span>
<span class="sd">    tz : None, tzinfo</span>
<span class="sd">    explicit_tz_none : bool, default False</span>
<span class="sd">        Whether tz=None was passed explicitly, as opposed to lib.no_default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tz : consensus tzinfo</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError : on tzinfo mismatch</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">DatetimeTZDtype</span><span class="o">.</span><span class="n">construct_from_string</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># Things like `datetime64[ns]`, which is OK for the</span>
                <span class="c1"># constructors, but also nonsense, which should be validated</span>
                <span class="c1"># but not by us. We *do* allow non-existent tz errors to</span>
                <span class="c1"># go through</span>
                <span class="k">pass</span>
        <span class="n">dtz</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;tz&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">timezones</span><span class="o">.</span><span class="n">tz_compare</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">dtz</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot supply both a tz and a dtype with a tz&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">explicit_tz_none</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot pass both a timezone-aware dtype and tz=None&quot;</span><span class="p">)</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">dtz</span>

        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># We also need to check for the case where the user passed a</span>
            <span class="c1">#  tz-naive dtype (i.e. datetime64[ns])</span>
            <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">timezones</span><span class="o">.</span><span class="n">tz_compare</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">dtz</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot supply both a tz and a &quot;</span>
                    <span class="s2">&quot;timezone-naive dtype (i.e. datetime64[ns])&quot;</span>
                <span class="p">)</span>

    <span class="k">return</span> <span class="n">tz</span>


<span class="k">def</span> <span class="nf">_infer_tz_from_endpoints</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Timestamp</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">Timestamp</span><span class="p">,</span> <span class="n">tz</span><span class="p">:</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tzinfo</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If a timezone is not explicitly given via `tz`, see if one can</span>
<span class="sd">    be inferred from the `start` and `end` endpoints.  If more than one</span>
<span class="sd">    of these inputs provides a timezone, require that they all agree.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : Timestamp</span>
<span class="sd">    end : Timestamp</span>
<span class="sd">    tz : tzinfo or None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tz : tzinfo or None</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError : if start and end timezones do not agree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">inferred_tz</span> <span class="o">=</span> <span class="n">timezones</span><span class="o">.</span><span class="n">infer_tzinfo</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="c1"># infer_tzinfo raises AssertionError if passed mismatched timezones</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Start and end cannot both be tz-aware with different timezones&quot;</span>
        <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

    <span class="n">inferred_tz</span> <span class="o">=</span> <span class="n">timezones</span><span class="o">.</span><span class="n">maybe_get_tz</span><span class="p">(</span><span class="n">inferred_tz</span><span class="p">)</span>
    <span class="n">tz</span> <span class="o">=</span> <span class="n">timezones</span><span class="o">.</span><span class="n">maybe_get_tz</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">inferred_tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">timezones</span><span class="o">.</span><span class="n">tz_compare</span><span class="p">(</span><span class="n">inferred_tz</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Inferred time zone not equal to passed time zone&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">inferred_tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">inferred_tz</span>

    <span class="k">return</span> <span class="n">tz</span>


<span class="k">def</span> <span class="nf">_maybe_normalize_endpoints</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Timestamp</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">Timestamp</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>


<span class="k">def</span> <span class="nf">_maybe_localize_point</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">is_none</span><span class="p">,</span> <span class="n">is_not_none</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Localize a start or end Timestamp to the timezone of the corresponding</span>
<span class="sd">    start or end Timestamp</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : start or end Timestamp to potentially localize</span>
<span class="sd">    is_none : argument that should be None</span>
<span class="sd">    is_not_none : argument that should not be None</span>
<span class="sd">    freq : Tick, DateOffset, or None</span>
<span class="sd">    tz : str, timezone object or None</span>
<span class="sd">    ambiguous: str, localization behavior for ambiguous times</span>
<span class="sd">    nonexistent: str, localization behavior for nonexistent times</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ts : Timestamp</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure start and end are timezone localized if:</span>
    <span class="c1"># 1) freq = a Timedelta-like frequency (Tick)</span>
    <span class="c1"># 2) freq = None i.e. generating a linspaced range</span>
    <span class="k">if</span> <span class="n">is_none</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_not_none</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Note: We can&#39;t ambiguous=&#39;infer&#39; a singular ambiguous time; however,</span>
        <span class="c1"># we have historically defaulted ambiguous=False</span>
        <span class="n">ambiguous</span> <span class="o">=</span> <span class="n">ambiguous</span> <span class="k">if</span> <span class="n">ambiguous</span> <span class="o">!=</span> <span class="s2">&quot;infer&quot;</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">localize_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ambiguous&quot;</span><span class="p">:</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="s2">&quot;nonexistent&quot;</span><span class="p">:</span> <span class="n">nonexistent</span><span class="p">,</span> <span class="s2">&quot;tz&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">Tick</span><span class="p">)</span> <span class="ow">or</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">localize_args</span><span class="p">[</span><span class="s2">&quot;tz&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tz</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="o">**</span><span class="n">localize_args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ts</span>


<span class="k">def</span> <span class="nf">_generate_range</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Timestamp</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">end</span><span class="p">:</span> <span class="n">Timestamp</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="n">BaseOffset</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a sequence of dates corresponding to the specified time</span>
<span class="sd">    offset. Similar to dateutil.rrule except uses pandas DateOffset</span>
<span class="sd">    objects to represent time increments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : Timestamp or None</span>
<span class="sd">    end : Timestamp or None</span>
<span class="sd">    periods : int or None</span>
<span class="sd">    offset : DateOffset</span>
<span class="sd">    unit : str</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * This method is faster for generating weekdays than dateutil.rrule</span>
<span class="sd">    * At least two of (start, end, periods) must be specified.</span>
<span class="sd">    * If both start and end are specified, the returned dates will</span>
<span class="sd">    satisfy start &lt;= date &lt;= end.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dates : generator object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

    <span class="c1"># Argument 1 to &quot;Timestamp&quot; has incompatible type &quot;Optional[Timestamp]&quot;;</span>
    <span class="c1"># expected &quot;Union[integer[Any], float, str, date, datetime64]&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NaT</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">as_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Argument 1 to &quot;Timestamp&quot; has incompatible type &quot;Optional[Timestamp]&quot;;</span>
    <span class="c1"># expected &quot;Union[integer[Any], float, str, date, datetime64]&quot;</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NaT</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">as_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">start</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">offset</span><span class="o">.</span><span class="n">is_on_offset</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
        <span class="c1"># Incompatible types in assignment (expression has type &quot;datetime&quot;,</span>
        <span class="c1"># variable has type &quot;Optional[Timestamp]&quot;)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">rollforward</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>  <span class="c1"># type: ignore[assignment]</span>

    <span class="k">elif</span> <span class="n">end</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">offset</span><span class="o">.</span><span class="n">is_on_offset</span><span class="p">(</span><span class="n">end</span><span class="p">):</span>
        <span class="c1"># Incompatible types in assignment (expression has type &quot;datetime&quot;,</span>
        <span class="c1"># variable has type &quot;Optional[Timestamp]&quot;)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>  <span class="c1"># type: ignore[assignment]</span>

    <span class="c1"># Unsupported operand types for &lt; (&quot;Timestamp&quot; and &quot;None&quot;)</span>
    <span class="k">if</span> <span class="n">periods</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">offset</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># type: ignore[operator]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">periods</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># error: No overload variant of &quot;__radd__&quot; of &quot;BaseOffset&quot; matches</span>
        <span class="c1"># argument type &quot;None&quot;</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">periods</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">offset</span>  <span class="c1"># type: ignore[operator]</span>

    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># error: No overload variant of &quot;__radd__&quot; of &quot;BaseOffset&quot; matches</span>
        <span class="c1"># argument type &quot;None&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="p">(</span><span class="n">periods</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">offset</span>  <span class="c1"># type: ignore[operator]</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="n">cur</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">if</span> <span class="n">offset</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">cur</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">cur</span>

            <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                <span class="c1"># GH#24252 avoid overflows by not performing the addition</span>
                <span class="c1"># in offset.apply unless we have to</span>
                <span class="k">break</span>

            <span class="c1"># faster than cur + offset</span>
            <span class="n">next_date</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="o">.</span><span class="n">as_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_date</span> <span class="o">&lt;=</span> <span class="n">cur</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Offset </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2"> did not increment date&quot;</span><span class="p">)</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">next_date</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">cur</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">cur</span>

            <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                <span class="c1"># GH#24252 avoid overflows by not performing the addition</span>
                <span class="c1"># in offset.apply unless we have to</span>
                <span class="k">break</span>

            <span class="c1"># faster than cur + offset</span>
            <span class="n">next_date</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="o">.</span><span class="n">as_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_date</span> <span class="o">&gt;=</span> <span class="n">cur</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Offset </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2"> did not decrement date&quot;</span><span class="p">)</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">next_date</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso Furlanello, and Daniel Hug.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>