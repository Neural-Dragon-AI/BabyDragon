{"id": 2, "start_time": 1691426487, "output": "{\n    \"sections\": [\n        \"Experimental APIs\",\n        \"Reentrant Code Generation\"\n    ],\n    \"functions\": {},\n    \"classes\": {\n        \"libcst.metadata.ExperimentalReentrantCodegenProvider\": \"\",\n        \"libcst.metadata.CodegenPartial\": \"\"\n    },\n    \"code\": []\n}", "prompt_tokens": 213, "completion_tokens": 61, "total_tokens": 274, "end_time": 1691426488}
{"id": 0, "start_time": 1691426487, "output": "{\n    \"sections\": [\"Introduction:\", \"Tutorial:\", \"Reference:\"],\n    \"functions\": {},\n    \"classes\": {},\n    \"code\": []\n}", "prompt_tokens": 408, "completion_tokens": 31, "total_tokens": 439, "end_time": 1691426489}
{"id": 4, "start_time": 1691426487, "output": "{\n    \"sections\": [\n        \"Why LibCST?\",\n        \"Abstract Syntax Trees (AST)\",\n        \"Concrete Syntax Trees (CST)\",\n        \"LibCST\"\n    ],\n    \"functions\": {},\n    \"classes\": {},\n    \"code\": []\n}", "prompt_tokens": 3140, "completion_tokens": 54, "total_tokens": 3194, "end_time": 1691426488}
{"id": 7, "start_time": 1691426489, "output": "{\n    \"sections\": [\n        \"Motivation\",\n        \"Exact Representation\",\n        \"Ease of Traversal\",\n        \"Ease of Modification\",\n        \"Well Tested\"\n    ],\n    \"functions\": {},\n    \"classes\": {},\n    \"code\": []\n}", "prompt_tokens": 912, "completion_tokens": 52, "total_tokens": 964, "end_time": 1691426490}
{"id": 1, "start_time": 1691426487, "output": "{\n    \"sections\": [\"Parsing\", \"Syntax Errors\"],\n    \"functions\": {\n        \"parse_module\": \"The most useful function here, since it accepts the entire contents of a file and returns a new tree.\",\n        \"parse_expression\": \"Useful when inserting new nodes into the tree, because they're easier to use than the equivalent node constructors.\",\n        \"parse_statement\": \"Useful when inserting new nodes into the tree, because they're easier to use than the equivalent node constructors.\"\n    },\n    \"classes\": {\n        \"PartialParserConfig\": \"\"\n    },\n    \"code\": [\n        \"import libcst as cst\\ncst.parse_expression(\\\"1 + 2\\\")\\nBinaryOperation(\\nleft=Integer(\\nvalue='1',\\nlpar=[],\\nrpar=[],\\n),\\noperator=Add(\\nwhitespace_before=SimpleWhitespace(\\nvalue=' ',\\n),\\nwhitespace_after=SimpleWhitespace(\\nvalue=' ',\\n),\\n),\\nright=Integer(\\nvalue='2',\\nlpar=[],\\nrpar=[],\\n),\\nlpar=[],\\nrpar=[],\\n)\"\n    ]\n}", "prompt_tokens": 408, "completion_tokens": 239, "total_tokens": 647, "end_time": 1691426488}
{"id": 5, "start_time": 1691426487, "output": "{\n    \"sections\": [\n        \"Working With Codemods\",\n        \"Setting up and Running Codemods\",\n        \"Writing a Codemod\",\n        \"Testing Codemods\"\n    ],\n    \"functions\": {\n        \"ConvertConstantCommand.add_args\": \"Add command-line args that a user can specify for running this\\ncodemod.\",\n        \"ConvertConstantCommand.__init__\": \"Initialize the base class with context, and save our args. Remember, the\\n# \\\"dest\\\" for each argument we added above must match a parameter name in\\n# this init.\",\n        \"ConvertConstantCommand.leave_SimpleString\": \"This codemod is pretty simple. It defines a command-line description, sets up to parse\\na few required command-line args, initializes its own member variables with the\\ncommand-line args that were parsed for it by \\\"libcst.tool codemod\\\" and finally\\nreplaces any string which matches our string command-line argument with a constant.\\nIt also takes care of adding the import required for the constant to be defined properly.\",\n        \"TestConvertConstantCommand.test_noop\": \"Verify that if we don't have a valid string match, we don't make\\nany substitutions.\",\n        \"TestConvertConstantCommand.test_substitution\": \"Verify that if we do have a valid string match, we make a substitution\\nas well as import the constant.\"\n    },\n    \"classes\": {\n        \"ConvertConstantCommand\": \"Converts raw strings to constant accesses.\",\n        \"TestConvertConstantCommand\": null\n    },\n    \"code\": [\n        \"python3 -m libcst.tool initialize .\",\n        \"python3 -m libcst.tool list\",\n        \"python3 -m libcst.tool codemod convert_format_to_fstring.ConvertFormatStringCommand .\",\n        \"python3 -m libcst.tool codemod constant_folding.ConvertConstantCommand --help\",\n        \"python3 -m unittest libcst.codemod.commands.tests.test_constant_folding\"\n    ]\n}", "prompt_tokens": 1969, "completion_tokens": 410, "total_tokens": 2379, "end_time": 1691426489}
{"id": 9, "start_time": 1691426490, "output": "{\n    \"sections\": [\n        \"Visitors\",\n        \"Visit and Leave Helper Functions\",\n        \"Traversal Order\",\n        \"Batched Visitors\"\n    ],\n    \"functions\": {\n        \"libcst.RemoveFromParent\": None,\n        \"libcst.visit_batched\": None\n    },\n    \"classes\": {\n        \"libcst.CSTVisitor\": None,\n        \"libcst.CSTTransformer\": None,\n        \"libcst.RemovalSentinel\": None,\n        \"libcst.FlattenSentinel\": None,\n        \"libcst.BatchableCSTVisitor\": None\n    },\n    \"code\": [\n        \"class FooingAround(libcst.CSTVisitor):\\n    def visit_FunctionDef(self, node: libcst.FunctionDef) -> bool:\\n        return \\\"foo\\\" not in node.name.value\\n\\n    def visit_SimpleString(self, node: libcst.SimpleString) -> None:\\n        print(node.value)\\n\\nimport libcst\\n\\ndemo = libcst.parse_module(\\\"'abc'\\\\n'123'\\\\ndef foo():\\\\n    'not printed'\\\")\\n_ = demo.visit(FooingAround())\\n'abc'\\n'123'\"\n    ]\n}", "prompt_tokens": 1336, "completion_tokens": 252, "total_tokens": 1588, "end_time": 1691426492}
{"id": 12, "start_time": 1691426498, "output": "{\n    \"sections\": [\n        \"Helpers\",\n        \"Construction Helpers\",\n        \"Transformation Helpers\",\n        \"Traversing Helpers\"\n    ],\n    \"functions\": {\n        \"libcst.helpers.parse_template_module\": \"\",\n        \"libcst.helpers.parse_template_expression\": \"\",\n        \"libcst.helpers.parse_template_statement\": \"\",\n        \"libcst.helpers.insert_header_comments\": \"\",\n        \"libcst.helpers.get_full_name_for_node\": \"\",\n        \"libcst.helpers.get_full_name_for_node_or_raise\": \"\",\n        \"libcst.helpers.ensure_type\": \"\"\n    },\n    \"classes\": {},\n    \"code\": []\n}", "prompt_tokens": 340, "completion_tokens": 122, "total_tokens": 462, "end_time": 1691426499}
{"id": 6, "start_time": 1691426487, "output": "{\n    \"sections\": [\n        \"Metadata\",\n        \"Metadata APIs\",\n        \"Accessing Metadata\",\n        \"Providing Metadata\",\n        \"Metadata Providers\",\n        \"Position Metadata\",\n        \"Expression Context Metadata\",\n        \"Scope Metadata\",\n        \"Qualified Name Metadata\",\n        \"Parent Node Metadata\",\n        \"File Path Metadata\",\n        \"Type Inference Metadata\"\n    ],\n    \"functions\": {\n        \"visit_Name\": \"pos = self.get_metadata(cst.metadata.PositionProvider, node).start\\nprint(f\\\"{node.value} found at line {pos.line}, column {pos.column}\\\")\",\n        \"resolve\": \"The wrapper provides a :func:`~libcst.metadata.MetadataWrapper.resolve` function\",\n        \"resolve_many\": \"The wrapper provides a :func:`~libcst.metadata.MetadataWrapper.resolve_many` function\",\n        \"__init__\": \"Metadata is generated through provider classes that can be be passed to\\n:meth:`MetadataWrapper.resolve() <libcst.metadata.MetadataWrapper.resolve>` or\\ndeclared as a dependency of a :class:`~libcst.metadata.MetadataDependent`\",\n        \"__contains__\": \".. autoclass:: libcst.metadata.Scope\\n   :no-undoc-members:\\n   :special-members: __contains__, __getitem__, __iter__\",\n        \"__getitem__\": \".. autoclass:: libcst.metadata.Scope\\n   :no-undoc-members:\\n   :special-members: __contains__, __getitem__, __iter__\",\n        \"__iter__\": \".. autoclass:: libcst.metadata.Scope\\n   :no-undoc-members:\\n   :special-members: __contains__, __getitem__, __iter__\",\n    },\n    \"classes\": {\n        \"NamePrinter\": \"class NamePrinter(cst.CSTVisitor):\\n        METADATA_DEPENDENCIES = (cst.metadata.PositionProvider,)\",\n        \"MetadataWrapper\": \"class:`~libcst.metadata.MetadataWrapper`\\n   :special-members: __init__\",\n        \"MetadataDependent\": \".. autoclass:: libcst.MetadataDependent\"\n    },\n    \"code\": [\n        \"class NamePrinter(cst.CSTVisitor):\\n        METADATA_DEPENDENCIES = (cst.metadata.PositionProvider,)\\n\\n        def visit_Name(self, node: cst.Name) -> None:\\n            pos = self.get_metadata(cst.metadata.PositionProvider, node).start\\n            print(f\\\"{node.value} found at line {pos.line}, column {pos.column}\\\")\",\n        \".. autoclass:: libcst.metadata.MetadataWrapper\\n   :special-members: __init__\",\n        \".. autoclass:: libcst.metadata.MetadataDependent\",\n        \".. autoclass:: libcst.BaseMetadataProvider\\n.. autoclass:: libcst.metadata.BatchableMetadataProvider\\n.. autoclass:: libcst.metadata.VisitorMetadataProvider\",\n        \".. autoclass:: libcst.metadata.PositionProvider\\n.. autoclass:: libcst.metadata.WhitespaceInclusivePositionProvider\",\n        \".. autoclass:: libcst.metadata.CodeRange\\n.. autoclass:: libcst.metadata.CodePosition\",\n        \".. autoclass:: libcst.metadata.ByteSpanPositionProvider\\n.. autoclass:: libcst.metadata.CodeSpan\",\n        \".. autoclass:: libcst.metadata.ExpressionContextProvider\\n   :no-undoc-members:\\n\\n.. autoclass:: libcst.metadata.ExpressionContext\",\n        \".. autoclass:: libcst.metadata.ScopeProvider\\n   :no-undoc-members:\\n\\n.. autoclass:: libcst.metadata.BaseAssignment\\n   :no-undoc-members:\\n\\n.. autoclass:: libcst.metadata.Access\\n.. autoclass:: libcst.metadata.Assignment\\n.. autoclass:: libcst.metadata.BuiltinAssignment\",\n        \".. autoclass:: libcst.metadata.Scope\\n   :no-undoc-members:\\n   :special-members: __contains__, __getitem__, __iter__\\n\\n.. autoclass:: libcst.metadata.BuiltinScope\\n   :no-undoc-members:\\n\\n.. autoclass:: libcst.metadata.GlobalScope\\n   :no-undoc-members:\\n\\n.. autoclass:: libcst.metadata.FunctionScope\\n.. autoclass:: libcst.metadata.ClassScope\\n.. autoclass:: libcst.metadata.ComprehensionScope\",\n        \".. autoclass:: libcst.metadata.QualifiedNameSource\\n.. autoclass:: libcst.metadata.QualifiedName\\n.. autoclass:: libcst.metadata.QualifiedNameProvider\\n   :no-undoc-members:\\n\\n.. autoclass:: libcst.metadata.FullyQualifiedNameProvider\\n   :no-undoc-members:\",\n        \".. autoclass:: libcst.metadata.ParentNodeProvider\\n   :no-undoc-members:\",\n        \".. autoclass:: libcst.metadata.FilePathProvider\\n   :no-undoc-members:\",\n        \".. autoclass:: libcst.metadata.TypeInferenceProvider\\n   :no-undoc-members:\\n\\n.. autoclass:: libcst.metadata.FullRepoManager\\n   :no-undoc-members:\\n   :special-members: __init__\"\n    ]\n}", "prompt_tokens": 2358, "completion_tokens": 1008, "total_tokens": 3366, "end_time": 1691426488}
{"id": 3, "start_time": 1691426487, "output": "{\n    \"sections\": [\n        \"Best Practices\",\n        \"Avoid isinstance when traversing\",\n        \"Prefer updated_node when modifying trees\",\n        \"Provide a config when generating code from templates\"\n    ],\n    \"functions\": {\n        \"get_identifier_name\": \"Optional[str]\\n\\n    def get_identifier_name(node: cst.CSTNode) -> Optional[str]:\",\n        \"CountBazFoobarArgs\": \"\\\"\\\"\\\"\\n    Given a set of function names, count how many arguments to those function\\n    calls are the identifiers \\\"baz\\\" or \\\"foobar\\\".\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, functions: Set[str]) -> None:\",\n        \"_count_args\": \"See if the most shallow call is one we're interested in, so we can\\n    # count the args we care about only in calls we care about.\\n    if self.call_stack[-1] in self.functions:\\n        self.arg_count += 1\",\n        \"FunctionRenamer\": \"def leave_Call(self, original_node: cst.Call, updated_node: cst.Call) -> cst.Call:\",\n        \"get_identifier_name\": \"Optional[str]\\n\\n    def get_identifier_name(node: cst.CSTNode) -> Optional[str]:\"\n    },\n    \"classes\": {\n        \"CountBazFoobarArgs\": \"\\\"\\\"\\\"\\n    Given a set of function names, count how many arguments to those function\\n    calls are the identifiers \\\"baz\\\" or \\\"foobar\\\".\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, functions: Set[str]) -> None:\",\n        \"FunctionRenamer\": \"class FunctionRenamer(cst.CSTTransformer):\",\n        \"FunctionRenamer\": \"class FunctionRenamer(cst.CSTTransformer):\",\n        \"CountBazFoobarArgs\": \"class CountBazFoobarArgs(m.MatcherDecoratableVisitor):\"\n    },\n    \"code\": [\n        \"def get_identifier_name(node: cst.CSTNode) -> Optional[str]:\\n    if m.matches(node, m.Name()):\\n        assert isinstance(node, cst.Name)\\n        return node.value\\n    return None\",\n        \"def get_identifier_name(node: cst.CSTNode) -> Optional[str]:\\n    return (\\n        cst.ensure_type(node, cst.Name).value\\n        if m.matches(node, m.Name())\\n        else None\\n    )\",\n        \"class CountBazFoobarArgs(cst.CSTVisitor):\\n    \\\"\\\"\\\"\\n    Given a set of function names, count how many arguments to those function\\n    calls are the identifiers \\\"baz\\\" or \\\"foobar\\\".\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, functions: Set[str]) -> None:\\n        super().__init__()\\n        self.functions: Set[str] = functions\\n        self.arg_count: int = 0\\n\\n    def visit_Call(self, node: cst.Call) -> None:\\n        # See if the call itself is one of our functions we care about\\n        if isinstance(node.func, cst.Name) and node.func.value in self.functions:\\n            # Loop through each argument\\n            for arg in node.args:\\n                # See if the argument is an identifier matching what we want to count\\n                if isinstance(arg.value, cst.Name) and arg.value.value in {\\\"baz\\\", \\\"foobar\\\"}:\\n                    self.arg_count += 1\",\n        \"class CountBazFoobarArgs(m.MatcherDecoratableVisitor):\\n    \\\"\\\"\\\"\\n    Given a set of function names, count how many arguments to those function\\n    calls are the identifiers \\\"baz\\\" or \\\"foobar\\\".\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, functions: Set[str]) -> None:\\n        super().__init__()\\n        self.functions: Set[str] = functions\\n        self.arg_count: int = 0\\n        self.call_stack: List[str] = []\\n\\n    def visit_Call(self, node: cst.Call) -> None:\\n        # Store all calls in a stack\\n        if m.matches(node.func, m.Name()):\\n            self.call_stack.append(cst.ensure_type(node.func, cst.Name).value)\\n\\n    def leave_Call(self, original_node: cst.Call) -> None:\\n        # Pop the latest call off the stack\\n        if m.matches(node.func, m.Name()):\\n            self.call_stack.pop()\\n\\n    @m.visit(m.Arg(m.Name(\\\"baz\\\")\",\n        \"class FunctionRenamer(cst.CSTTransformer):\\n    def leave_Call(self, original_node: cst.Call, updated_node: cst.Call) -> cst.Call:\\n        if m.matches(original_node.func, m.Name()):\\n            return original_node.with_changes(\\n                func=cst.Name(\\n                    \\\"renamed_\\\" + cst.ensure_type(original_node.func, cst.Name).value\\n                )\\n            )\\n        return original_node\",\n        \"class FunctionRenamer(cst.CSTTransformer):\\n    def leave_Call(self, original_node: cst.Call, updated_node: cst.Call) -> cst.Call:\\n        if m.matches(updated_node.func, m.Name()):\\n            return updated_node.with_changes(\\n                func=cst.Name(\\n                    \\\"renamed_\\\" + cst.ensure_type(updated_node.func, cst.Name).value\\n                )\\n            )\\n        return updated_node\",\n        \"module = cst.parse_module(some_code_string)\\nnew_module = module.with_changes(\\n    body=(\\n        *module.body,\\n        cst.parse_statement(\\n            \\\"print('Hello, world!')\\\",\\n            config=module.config_for_parsing,\\n        ),\\n    ),\\n)\\nnew_code_string = new_module.code\"\n    ]\n}", "prompt_tokens": 1950, "completion_tokens": 1206, "total_tokens": 3156, "end_time": 1691426489}
{"id": 8, "start_time": 1691426489, "output": "{\n  \"sections\": [\n    \"Codemods\",\n    \"Codemod Base\",\n    \"Execution Interface\",\n    \"Command-Line Support\",\n    \"Command-Line Toolkit\",\n    \"Library of Transforms\"\n  ],\n  \"functions\": {},\n  \"classes\": {\n    \"Codemod\": \"All codemods derive from a common base, :class:`~libcst.codemod.Codemod`...\\\\n.. autoclass:: libcst.codemod.Codemod\\\\n.. autoclass:: libcst.codemod.CodemodContext\",\n    \"CodemodContext\": \"All codemods derive from a common base, :class:`~libcst.codemod.Codemod`...\\\\n.. autoclass:: libcst.codemod.Codemod\\\\n.. autoclass:: libcst.codemod.CodemodContext\",\n    \"ContextAwareTransformer\": \"As a convenience, LibCST-compatible visitors are provided...\\\\n.. autoclass:: libcst.codemod.ContextAwareTransformer\\\\n  :exclude-members: transform_module_impl\",\n    \"ContextAwareVisitor\": \"As a convenience, LibCST-compatible visitors are provided...\\\\n.. autoclass:: libcst.codemod.ContextAwareTransformer\\\\n  :exclude-members: transform_module_impl\",\n    \"SkipFile\": \"It is often necessary to bail out of a codemod mid-operation when you realize that...\\\\n.. autoclass:: libcst.codemod.SkipFile\",\n    \"CodemodTest\": \"Finally, its often easier to test codemods by writing verification tests...\\\\n.. autoclass:: libcst.codemod.CodemodTest\\\\n  :inherited-members:\\\\n  :exclude-members: addCleanup, addTypeEqualityFunc,...\",\n    \"TransformResult\": \"As documented in the Codemod Base section above, codemods are meant to be...\\\\n.. autofunction:: libcst.codemod.transform_module\\\\n.. autoclass::...\",\n    \"TransformSuccess\": \"As documented in the Codemod Base section above, codemods are meant to be...\\\\n.. autofunction:: libcst.codemod.transform_module\\\\n.. autoclass::...\",\n    \"TransformFailure\": \"As documented in the Codemod Base section above, codemods are meant to be...\\\\n.. autofunction:: libcst.codemod.transform_module\\\\n.. autoclass::...\",\n    \"TransformSkip\": \"As documented in the Codemod Base section above, codemods are meant to be...\\\\n.. autofunction:: libcst.codemod.transform_module\\\\n.. autoclass::...\",\n    \"SkipReason\": \"As documented in the Codemod Base section above, codemods are meant to be...\\\\n.. autofunction:: libcst.codemod.transform_module\\\\n.. autoclass::...\",\n    \"CodemodCommand\": \"LibCST includes additional support to facilitate faster development of codemods...\\\\n.. autoclass:: libcst.codemod.CodemodCommand\\\\n  :exclude-members: transform_module\",\n    \"VisitorBasedCodemodCommand\": \"Additionally, a few convenience classes have been provided which take the boilerplate...\\\\n.. autoclass:: libcst.codemod.VisitorBasedCodemodCommand\",\n    \"MagicArgsCodemodCommand\": \"Additionally, a few convenience classes have been provided which take the boilerplate...\\\\n.. autoclass:: libcst.codemod.MagicArgsCodemodCommand\\\\n  :exclude-members: transform_module_impl\",\n    \"ParallelTransformResult\": \"Several helpers for constructing a command-line interface are provided. These are used...\\\\n.. autofunction:: libcst.codemod.gather_files\\\\n.. autofunction::...\",\n    \"GatherImportsVisitor\": \"LibCST additionally includes a library of transforms to reduce the need for boilerplate...\\\\n.. autoclass:: libcst.codemod.visitors.GatherImportsVisitor\\\\n  :no-undoc-members:\",\n    \"GatherExportsVisitor\": \"LibCST additionally includes a library of transforms to reduce the need for boilerplate...\\\\n.. autoclass:: libcst.codemod.visitors.GatherExportsVisitor\\\\n  :no-undoc-members:\",\n    \"AddImportsVisitor\": \"LibCST additionally includes a library of transforms to reduce the need for boilerplate...\\\\n.. autoclass:: libcst.codemod.visitors.AddImportsVisitor\\\\n  :no-undoc-members:\",\n    \"RemoveImportsVisitor\": \"LibCST additionally includes a library of transforms to reduce the need for boilerplate...\\\\n.. autoclass:: libcst.codemod.visitors.RemoveImportsVisitor\\\\n  :no-undoc-members:\",\n    \"ApplyTypeAnnotationsVisitor\": \"LibCST additionally includes a library of transforms to reduce the need for boilerplate...\\\\n.. autoclass:: libcst.codemod.visitors.ApplyTypeAnnotationsVisitor\\\\n  :no-undoc-members:\",\n    \"GatherUnusedImportsVisitor\": \"LibCST additionally includes a library of transforms to reduce the need for boilerplate...\\\\n.. autoclass:: libcst.codemod.visitors.GatherUnusedImportsVisitor\\\\n  :no-undoc-members:\",\n    \"GatherCommentsVisitor\": \"LibCST additionally includes a library of transforms to reduce the need for boilerplate...\\\\n.. autoclass:: libcst.codemod.visitors.GatherCommentsVisitor\\\\n  :no-undoc-members:\",\n    \"GatherNamesFromStringAnnotationsVisitor\": \"LibCST additionally includes a library of transforms to reduce the need for boilerplate...\\\\n.. autoclass:: libcst.codemod.visitors.GatherNamesFromStringAnnotationsVisitor\\\\n  :no-undoc-members:\"\n  },\n  \"code\": [\n    \"python3 -m libcst.tool codemod --help\",\n    \"python3 -m libcst.tool codemod noop.NOOPCommand --help\",\n    \"python3 -m libcst.tool list\",\n    \"python3 -m libcst.tool initialize --help\"\n  ]\n}", "prompt_tokens": 2026, "completion_tokens": 1263, "total_tokens": 3289, "end_time": 1691426491}
{"id": 11, "start_time": 1691426495, "output": "{\n    \"sections\": [\n        \"Matchers\",\n        \"Matcher APIs\",\n        \"Decorators\",\n        \"Matcher Types\",\n        \"Concrete Matchers\",\n        \"Special Matchers\",\n        \"Sequence Wildcard Matchers\"\n    ],\n    \"functions\": {\n        \"matches\": \"Matchers can be used either by calling :func:`~libcst.matchers.matches` or\\n:func:`~libcst.matchers.findall` directly, or by using various decorators to\\nselectively control when LibCST calls visitor functions.\",\n        \"findall\": \"Matchers can be used either by calling :func:`~libcst.matchers.matches` or\\n:func:`~libcst.matchers.findall` directly, or by using various decorators to\\nselectively control when LibCST calls visitor functions.\",\n        \"extract\": \"Matchers can be used either by calling :func:`~libcst.matchers.matches` or\\n:func:`~libcst.matchers.findall` directly, or by using various decorators to\\nselectively control when LibCST calls visitor functions.\",\n        \"extractall\": \"Matchers can be used either by calling :func:`~libcst.matchers.matches` or\\n:func:`~libcst.matchers.findall` directly, or by using various decorators to\\nselectively control when LibCST calls visitor functions.\",\n        \"replace\": \"Matchers can be used either by calling :func:`~libcst.matchers.matches` or\\n:func:`~libcst.matchers.findall` directly, or by using various decorators to\\nselectively control when LibCST calls visitor functions.\",\n        \"visit\": \"The following decorators can be placed onto a method in a visitor or transformer\\nin order to convert it into a visitor which is called when the provided matcher is\\ntrue.\",\n        \"leave\": \"The following decorators can be placed onto a method in a visitor or transformer\\nin order to convert it into a visitor which is called when the provided matcher is\\ntrue.\",\n        \"call_if_inside\": \"When using matcher decorators, your visitors must subclass from\\n:class:`~libcst.matchers.MatcherDecoratableVisitor` instead of :class:`libcst.CSTVisitor`,\\nand from :class:`~libcst.matchers.MatcherDecoratableTransformer` instead of\\n:class:`libcst.CSTTransformer`.\",\n        \"call_if_not_inside\": \"When using matcher decorators, your visitors must subclass from\\n:class:`~libcst.matchers.MatcherDecoratableVisitor` instead of :class:`libcst.CSTVisitor`,\\nand from :class:`~libcst.matchers.MatcherDecoratableTransformer` instead of\\n:class:`libcst.CSTTransformer`.\"\n    },\n    \"classes\": {\n        \"MatcherDecoratableVisitor\": \"When using matcher decorators, your visitors must subclass from\\n:class:`~libcst.matchers.MatcherDecoratableVisitor` instead of :class:`libcst.CSTVisitor`,\\nand from :class:`~libcst.matchers.MatcherDecoratableTransformer` instead of\\n:class:`libcst.CSTTransformer`.\",\n        \"MatcherDecoratableTransformer\": \"When using matcher decorators, your visitors must subclass from\\n:class:`~libcst.matchers.MatcherDecoratableVisitor` instead of :class:`libcst.CSTVisitor`,\\nand from :class:`~libcst.matchers.MatcherDecoratableTransformer` instead of\\n:class:`libcst.CSTTransformer`.\",\n        \"BaseMatcherNode\": \"For each node found in :ref:`libcst-nodes`, a corresponding concrete matcher\\nhas been generated.\",\n        \"OneOf\": \"Special matchers are matchers that don't have a corresponding LibCST node. Concrete\\nmatchers only match against their corresponding LibCST node, limiting their use\\nunder certain circumstances.\",\n        \"AllOf\": \"Special matchers are matchers that don't have a corresponding LibCST node. Concrete\\nmatchers only match against their corresponding LibCST node, limiting their use\\nunder certain circumstances.\",\n        \"TypeOf\": \"Special matchers are matchers that don't have a corresponding LibCST node. Concrete\\nmatchers only match against their corresponding LibCST node, limiting their use\\nunder certain circumstances.\",\n        \"DoesNotMatch\": \"Special matchers are matchers that don't have a corresponding LibCST node. Concrete\\nmatchers only match against their corresponding LibCST node, limiting their use\\nunder certain circumstances.\",\n        \"MatchIfTrue\": \"Special matchers are matchers that don't have a corresponding LibCST node. Concrete\\nmatchers only match against their corresponding LibCST node, limiting their use\\nunder certain circumstances.\",\n        \"MatchRegex\": \"Special matchers are matchers that don't have a corresponding LibCST node. Concrete\\nmatchers only match against their corresponding LibCST node, limiting their use\\nunder certain circumstances.\",\n        \"MatchMetadata\": \"Special matchers are matchers that don't have a corresponding LibCST node. Concrete\\nmatchers only match against their corresponding LibCST node, limiting their use\\nunder certain circumstances.\",\n        \"MatchMetadataIfTrue\": \"Special matchers are matchers that don't have a corresponding LibCST node. Concrete\\nmatchers only match against their corresponding LibCST node, limiting their use\\nunder certain circumstances.\",\n        \"SaveMatchedNode\": \"Special matchers are matchers that don't have a corresponding LibCST node. Concrete\\nmatchers only match against their corresponding LibCST node, limiting their use\\nunder certain circumstances.\",\n        \"DoNotCare\": \"Special matchers are matchers that don't have a corresponding LibCST node. Concrete\\nmatchers only match against their corresponding LibCST node, limiting their use\\nunder certain circumstances.\",\n        \"AtLeastN\": \"Sequence wildcard matchers are matchers that only get used when constructing a\\nsequence to match against. Not all LibCST nodes have attributes which are sequences,\\nbut for those that do, sequence wildcard matchers offer a great degree of\\nflexibility.\",\n        \"AtMostN\": \"Sequence wildcard matchers are matchers that only get used when constructing a\\nsequence to match against. Not all LibCST nodes have attributes which are sequences,\\nbut for those that do, sequence wildcard matchers offer a great degree of\\nflexibility.\"\n    },\n    \"code\": []\n}", "prompt_tokens": 2158, "completion_tokens": 1283, "total_tokens": 3441, "end_time": 1691426496}
{"id": 10, "start_time": 1691426491, "output": "{\n    \"sections\": [\"Nodes\", \"CSTNode\", \"Module\", \"Expressions\", \"Names and Object Attributes\", \"Operations and Comparisons\", \"Control Flow\", \"Lambdas and Function Calls\", \"Literal Values\", \"Numbers\", \"Strings\", \"Formatted Strings (f-strings)\", \"Collections\", \"Simple Collections\", \"Simple Collection Elements\", \"Dictionaries\", \"Dictionary Elements\", \"Comprehensions\", \"Subscripts and Slices\", \"Parenthesis, Brackets, and Braces\", \"Statements\", \"Simple Statements\", \"Compound Statements\", \"Helper Nodes\", \"Statement Blocks\", \"Operators\", \"Unary Operators\", \"Boolean Operators\", \"Binary Operators\", \"Comparison Operators\", \"Augmented Assignment Operators\", \"Miscellaneous\", \"Whitespace\", \"Maybe Sentinel\"],\n    \"functions\": {},\n    \"classes\": {\n        \"libcst.CSTNode\": \"The base node type which all other nodes derive from.\",\n        \"libcst.Module\": \"A node that represents an entire python module.\",\n        \"libcst.BaseExpression\": \"An expression is anything that represents a value (e.g. it could be returned from a function). All expressions subclass from BaseExpression.\",\n        \"libcst.Name\": \"Names and Object Attributes\",\n        \"libcst.Attribute\": \"Names and Object Attributes\",\n        \"libcst.UnaryOperation\": \"Operations and Comparisons\",\n        \"libcst.BinaryOperation\": \"Operations and Comparisons\",\n        \"libcst.BooleanOperation\": \"Operations and Comparisons\",\n        \"libcst.Comparison\": \"Operations and Comparisons\",\n        \"libcst.ComparisonTarget\": \"Operations and Comparisons\",\n        \"libcst.Asynchronous\": \"Control Flow\",\n        \"libcst.Await\": \"Control Flow\",\n        \"libcst.Yield\": \"Control Flow\",\n        \"libcst.From\": \"Control Flow\",\n        \"libcst.IfExp\": \"Control Flow\",\n        \"libcst.Lambda\": \"Lambdas and Function Calls\",\n        \"libcst.Call\": \"Lambdas and Function Calls\",\n        \"libcst.Arg\": \"Lambdas and Function Calls\",\n        \"libcst.Ellipsis\": \"Literal Values\",\n        \"libcst.BaseNumber\": \"Numbers\",\n        \"libcst.Integer\": \"Numbers\",\n        \"libcst.Float\": \"Numbers\",\n        \"libcst.Imaginary\": \"Numbers\",\n        \"libcst.BaseString\": \"Strings\",\n        \"libcst.SimpleString\": \"Strings\",\n        \"libcst.ConcatenatedString\": \"Strings\",\n        \"libcst.FormattedString\": \"Formatted Strings (f-strings)\",\n        \"libcst.BaseFormattedStringContent\": \"Formatted Strings (f-strings)\",\n        \"libcst.FormattedStringText\": \"Formatted Strings (f-strings)\",\n        \"libcst.FormattedStringExpression\": \"Formatted Strings (f-strings)\",\n        \"libcst.Tuple\": \"Collections\",\n        \"libcst.BaseList\": \"Collections\",\n        \"libcst.List\": \"Collections\",\n        \"libcst.BaseSet\": \"Collections\",\n        \"libcst.Set\": \"Collections\",\n        \"libcst.BaseElement\": \"Simple Collection Elements\",\n        \"libcst.Element\": \"Simple Collection Elements\",\n        \"libcst.StarredElement\": \"Simple Collection Elements\",\n        \"libcst.BaseDict\": \"Dictionaries\",\n        \"libcst.Dict\": \"Dictionaries\",\n        \"libcst.BaseDictElement\": \"Dictionary Elements\",\n        \"libcst.DictElement\": \"Dictionary Elements\",\n        \"libcst.StarredDictElement\": \"Dictionary Elements\",\n        \"libcst.BaseComp\": \"Comprehensions\",\n        \"libcst.BaseSimpleComp\": \"Comprehensions\",\n        \"libcst.GeneratorExp\": \"Comprehensions\",\n        \"libcst.ListComp\": \"Comprehensions\",\n        \"libcst.SetComp\": \"Comprehensions\",\n        \"libcst.DictComp\": \"Comprehensions\",\n        \"libcst.CompFor\": \"Comprehensions\",\n        \"libcst.CompIf\": \"Comprehensions\",\n        \"libcst.Subscript\": \"Sub-scripts and Slices\",\n        \"libcst.BaseSlice\": \"Sub-scripts and Slices\",\n        \"libcst.Index\": \"Sub-scripts and Slices\",\n        \"libcst.Slice\": \"Sub-scripts and Slices\",\n        \"libcst.SubscriptElement\": \"Sub-scripts and Slices\",\n        \"libcst.LeftParen\": \"Parenthesis, Brackets, and Braces\",\n        \"libcst.RightParen\": \"Parenthesis, Brackets, and Braces\",\n        \"libcst.LeftSquareBracket\": \"Parenthesis, Brackets, and Braces\",\n        \"libcst.RightSquareBracket\": \"Parenthesis, Brackets, and Braces\",\n        \"libcst.LeftCurlyBrace\": \"Parenthesis, Brackets, and Braces\",\n        \"libcst.RightCurlyBrace\": \"Parenthesis, Brackets, and Braces\",\n        \"libcst.BaseSmallStatement\": \"Statements\",\n        \"libcst.AnnAssign\": \"Statements\",\n        \"libcst.Assert\": \"Statements\",\n        \"libcst.Assign\": \"Statements\",\n        \"libcst.AugAssign\": \"Statements\",\n        \"libcst.Break\": \"Statements\",\n        \"libcst.Continue\": \"Statements\",\n        \"libcst.Del\": \"Statements\",\n        \"libcst.Expr\": \"Statements\",\n        \"libcst.Global\": \"Statements\",\n        \"libcst.Import\": \"Statements\",\n        \"libcst.ImportFrom\": \"Statements\",\n        \"libcst.Nonlocal\": \"Statements\",\n        \"libcst.Pass\": \"Statements\",\n        \"libcst.Raise\": \"Statements\",\n        \"libcst.Return\": \"Statements\",\n        \"libcst.BaseCompoundStatement\": \"Compound Statements\",\n        \"libcst.ClassDef\": \"Compound Statements\",\n        \"libcst.For\": \"Compound Statements\",\n        \"libcst.FunctionDef\": \"Compound Statements\",\n        \"libcst.If\": \"Compound Statements\",\n        \"libcst.Try\": \"Compound Statements\",\n        \"libcst.While\": \"Compound Statements\",\n        \"libcst.With\": \"Compound Statements\",\n        \"libcst.Annotation\": \"Helper Nodes\",\n        \"libcst.AsName\": \"Helper Nodes\",\n        \"libcst.AssignTarget\": \"Helper Nodes\",\n        \"libcst.BaseAssignTargetExpression\": \"Helper Nodes\",\n        \"libcst.BaseDelTargetExpression\": \"Helper Nodes\",\n        \"libcst.Decorator\": \"Helper Nodes\",\n        \"libcst.Else\": \"Helper Nodes\",\n        \"libcst.ExceptHandler\": \"Helper Nodes\",\n        \"libcst.Finally\": \"Helper Nodes\",\n        \"libcst.ImportAlias\": \"Helper Nodes\",\n        \"libcst.NameItem\": \"Helper Nodes\",\n        \"libcst.Parameters\": \"Helper Nodes\",\n        \"libcst.Param\": \"Helper Nodes\",\n        \"libcst.ParamSlash\": \"Helper Nodes\",\n        \"libcst.ParamStar\": \"Helper Nodes\",\n        \"libcst.WithItem\": \"Helper Nodes\",\n        \"libcst.BaseSuite\": \"Statement Blocks\",\n        \"libcst.SimpleStatementLine\": \"Statement Blocks\",\n        \"libcst.SimpleStatementSuite\": \"Statement Blocks\",\n        \"libcst.IndentedBlock\": \"Statement Blocks\",\n        \"libcst.BitInvert\": \"Operators\",\n        \"libcst.Minus\": \"Operators\",\n        \"libcst.Not\": \"Operators\",\n        \"libcst.Plus\": \"Operators\",\n        \"libcst.And\": \"Operators\",\n        \"libcst.Or\": \"Operators\",\n        \"libcst.Add\": \"Operators\",\n        \"libcst.BitAnd\": \"Operators\",\n        \"libcst.BitOr\": \"Operators\",\n        \"libcst.BitXor\": \"Operators\",\n        \"libcst.Divide\": \"Operators\",\n        \"libcst.FloorDivide\": \"Operators\",\n        \"libcst.LeftShift\": \"Operators\",\n        \"libcst.MatrixMultiply\": \"Operators\",\n        \"libcst.Modulo\": \"Operators\",\n        \"libcst.Multiply\": \"Operators\",\n        \"libcst.Power\": \"Operators\",\n        \"libcst.RightShift\": \"Operators\",\n        \"libcst.Subtract\": \"Operators\",\n        \"libcst.Equal\": \"Comparison Operators\",\n        \"libcst.GreaterThan\": \"Comparison Operators\",\n        \"libcst.GreaterThanEqual\": \"Comparison Operators\",\n        \"libcst.In\": \"Comparison Operators\",\n        \"libcst.Is\": \"Comparison Operators\",\n        \"libcst.LessThan\": \"Comparison Operators\",\n        \"libcst.LessThanEqual\": \"Comparison Operators\",\n        \"libcst.NotEqual\": \"Comparison Operators\",\n        \"libcst.IsNot\": \"Comparison Operators\",\n        \"libcst.NotIn\": \"Comparison Operators\",\n        \"libcst.AddAssign\": \"Augmented Assignment Operators\",\n        \"libcst.BitAndAssign\": \"Augmented Assignment Operators\",\n        \"libcst.BitOrAssign\": \"Augmented Assignment Operators\",\n        \"libcst.BitXorAssign\": \"Augmented Assignment Operators\",\n        \"libcst.DivideAssign\": \"Augmented Assignment Operators\",\n        \"libcst.FloorDivideAssign\": \"Augmented Assignment Operators\",\n        \"libcst.LeftShiftAssign\": \"Augmented Assignment Operators\",\n        \"libcst.MatrixMultiplyAssign\": \"Augmented Assignment Operators\",\n        \"libcst.ModuloAssign\": \"Augmented Assignment Operators\",\n        \"libcst.MultiplyAssign\": \"Augmented Assignment Operators\",\n        \"libcst.PowerAssign\": \"Augmented Assignment Operators\",\n        \"libcst.RightShiftAssign\": \"Augmented Assignment Operators\",\n        \"libcst.SubtractAssign\": \"Augmented Assignment Operators\",\n        \"libcst.AssignEqual\": \"Miscellaneous\",\n        \"libcst.Colon\": \"Miscellaneous\",\n        \"libcst.Comma\": \"Miscellaneous\",\n        \"libcst.Dot\": \"Miscellaneous\",\n        \"libcst.ImportStar\": \"Miscellaneous\",\n        \"libcst.Semicolon\": \"Miscellaneous\",\n        \"libcst.Comment\": \"Whitespace\",\n        \"libcst.EmptyLine\": \"Whitespace\",\n        \"libcst.Newline\": \"Whitespace\",\n        \"libcst.ParenthesizedWhitespace\": \"Whitespace\",\n        \"libcst.SimpleWhitespace\": \"Whitespace\",\n        \"libcst.TrailingWhitespace\": \"Whitespace\",\n        \"libcst.BaseParenthesizableWhitespace\": \"Whitespace\",\n        \"libcst.MaybeSentinel\": \"Maybe Sentinel\"\n    },\n    \"code\": []\n}", "prompt_tokens": 2596, "completion_tokens": 2113, "total_tokens": 4709, "end_time": 1691426492}
